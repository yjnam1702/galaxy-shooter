<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>갤럭시 비행기 게임</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            gap: 30px;
        }

        #rightPanel {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        #gameContainer {
            text-align: center;
            position: relative;
        }

        #gameCanvasWrapper {
            position: relative;
            display: inline-block;
        }

        #overlayUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #topOverlay {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #bottomOverlay {
            display: block;
        }

        /* Ensure overlay UI doesn't interfere during special effects */
        #overlayUI.special-attack {
            opacity: 0.7;
        }

        #leftOverlay {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #rightOverlay {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .overlay-panel {
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(8px);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }

        .overlay-panel:hover {
            background: rgba(0, 0, 0, 0.85);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .score-panel {
            background: none !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            backdrop-filter: none !important;
            box-shadow: none !important;
        }

        .score-panel:hover {
            background: none !important;
            border: none !important;
        }

        #overlayScore {
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            background: none;
            padding: 0;
            border-radius: 0;
            backdrop-filter: none;
            text-align: left;
        }


        #overlayGaugeContainer {
            position: absolute;
            bottom: 0px;
            left: 0px;
            width: 100%;
            height: 8px;
            z-index: 1000;
        }

        #overlayGauge {
            width: 100%;
            height: 100%;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background: rgba(0, 0, 0, 0.7);
            border-radius: 3px;
            overflow: hidden;
            margin: 0;
        }

        #overlayGaugeFill {
            height: 100%;
            background: linear-gradient(to right, #ff4444, #ffff44, #44ff44);
            width: 0%;
            transition: width 0.2s;
            border-radius: 2px;
        }

        #overlayGaugeText {
            display: none;
        }

        /* Removed overlayInventory and overlay-item-slot CSS - top-right items display removed */

        #equippedItemsDisplay {
            position: absolute;
            bottom: 35px;
            right: 10px;
            background: rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 8px;
            min-width: 180px;
            z-index: 1001;
        }

        #equippedItemsTitle {
            color: #00ffff;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 6px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #equippedItemsList {
            display: flex;
            flex-direction: column;
            gap: 3px;
            font-size: 11px;
        }

        .equipped-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #ffffff;
        }

        .equipped-item-symbol {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            font-weight: bold;
            font-size: 12px;
        }

        .equipped-item-desc {
            flex: 1;
            color: #cccccc;
        }

        #controlsPanel {
            width: 320px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            color: white;
            backdrop-filter: blur(5px);
            margin-top: 20px;
        }

        .item-description {
            color: #ffcc99;
            font-size: 12px;
            margin-left: 10px;
            font-style: italic;
        }

        #controlsTitle {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 12px;
            color: #00ffff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .control-item {
            padding: 6px 0;
            font-size: 14px;
            color: #cccccc;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-item:last-child {
            border-bottom: none;
        }

        .control-key {
            color: #ffd700;
            font-weight: bold;
        }

        #rankingContainer {
            width: 320px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            color: white;
            backdrop-filter: blur(10px);
        }

        #rankingTitle {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 4px solid #FFD700;
        }

        .ranking-rank {
            font-weight: bold;
            font-size: 18px;
            color: #FFD700;
            min-width: 30px;
        }

        .ranking-score {
            font-size: 16px;
            font-weight: bold;
        }

        .ranking-date {
            font-size: 12px;
            color: #aaa;
        }

        .ranking-item:nth-child(1) .ranking-rank { color: #FFD700; }
        .ranking-item:nth-child(2) .ranking-rank { color: #C0C0C0; }
        .ranking-item:nth-child(3) .ranking-rank { color: #CD7F32; }
        
        canvas {
            border: 2px solid #333;
            background: linear-gradient(to bottom, #001122, #000033);
        }
        
        #ui {
            color: white;
            margin-top: 10px;
        }
        
        #score {
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        #gaugeContainer {
            margin-bottom: 10px;
        }
        
        #gauge {
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            background: #333;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        
        #gaugeFill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
            width: 0%;
            transition: width 0.2s;
        }
        
        #gaugeText {
            color: white;
            font-size: 14px;
            margin-top: 5px;
        }
        
        #inventory {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .item-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #666;
            background: #222;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .item-slot.filled {
            border-color: #00ff00;
            background: #004400;
        }
        
        #gameOver {
            display: none;
            color: red;
            font-size: 24px;
            margin-top: 20px;
        }

        #rankingModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        #rankingContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #0f3460;
            border-radius: 10px;
            padding: 30px;
            color: white;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        #nameInput {
            background: #2a2a4e;
            border: 2px solid #0080ff;
            color: white;
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            margin: 10px;
            text-align: center;
        }

        #nameInput:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #rankingList {
            margin: 20px 0;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
        }

        .rankingItem {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border-left: 4px solid #00ffff;
        }

        .rankingItem.newRecord {
            background: rgba(255, 215, 0, 0.2);
            border-left-color: #ffd700;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }
        
        #pauseScreen {
            display: none;
            color: white;
            font-size: 24px;
            margin-top: 20px;
        }
        
        button {
            background: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
        }
        
        button:hover {
            background: #555;
        }

        /* 모바일 반응형 스타일 */
        @media (max-width: 768px) {
            body {
                padding: 0;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                justify-content: flex-start;
            }

            #gameContainer {
                width: 100%;
                max-width: 100vw;
                order: -1;
                margin-top: 0;
            }

            #gameCanvasWrapper {
                width: 100%;
                height: auto;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
                max-width: 100vw;
                touch-action: none;
            }

            #rightPanel {
                width: 100%;
                padding: 10px;
            }

            .overlay-panel {
                padding: 6px 10px;
                font-size: 14px;
            }

            #overlayGaugeContainer {
                padding: 8px;
            }
        }

        /* 모바일 터치 컨트롤 */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            z-index: 200;
            pointer-events: none;
            display: none;
        }

        @media (max-width: 768px), (pointer: coarse) {
            #mobileControls {
                display: block;
            }
        }


        /* 필살기 버튼 */
        #specialAttackBtn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 50, 50, 1);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            line-height: 74px;
            pointer-events: all;
            touch-action: none;
            opacity: 1;
            transition: all 0.3s ease;
            display: none;
            box-shadow: 0 0 20px rgba(255, 50, 50, 0.5);
            animation: pulse 1s infinite;
        }

        #specialAttackBtn.show {
            display: block;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* 터치 피드백 */
        .btn-pressed {
            transform: scale(0.9) !important;
            opacity: 0.7 !important;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameCanvasWrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>

            <!-- Overlay UI Elements -->
            <div id="overlayUI">
                <div id="topOverlay">
                    <div id="leftOverlay">
                        <div class="overlay-panel score-panel">
                            <div id="overlayScore">점수: 0</div>
                        </div>
                    </div>
                    <div id="rightOverlay">
                        <!-- Top-right items display removed as requested -->
                    </div>
                </div>
                <div id="bottomOverlay">
                    <div id="overlayGaugeContainer">
                        <div id="overlayGauge">
                            <div id="overlayGaugeFill"></div>
                        </div>
                        <div id="overlayGaugeText">필살기 게이지: 0%</div>
                    </div>
                    <div id="equippedItemsDisplay">
                        <div id="equippedItemsTitle">장착된 아이템</div>
                        <div id="equippedItemsList"></div>
                    </div>
                </div>
            </div>

            <!-- 모바일 터치 컨트롤 -->
            <div id="mobileControls">
                <div id="specialAttackBtn">필살기</div>
            </div>
        </div>

        <div id="ui">
            <!-- Keep original elements hidden but functional for backwards compatibility -->
            <div id="score" style="display: none;">점수: 0</div>
            <div id="gaugeContainer" style="display: none;">
                <div id="gauge">
                    <div id="gaugeFill"></div>
                </div>
                <div id="gaugeText">필살기 게이지: 0%</div>
            </div>
            <div id="inventory" style="display: none;">
                <div class="item-slot" id="slot0"></div>
                <div class="item-slot" id="slot1"></div>
            </div>

            <div id="pauseScreen">
                <div>게임 일시정지</div>
                <div style="font-size: 16px; margin-top: 10px;">P키를 눌러 계속</div>
            </div>
            <div id="gameOver">
                <div>게임 오버!</div>
                <button onclick="restartGame()">다시 시작</button>
            </div>
        </div>
    </div>

    <div id="rankingModal">
        <div id="rankingContent">
            <h2 style="color: #00ffff; margin-bottom: 20px;">🏆 게임 결과 🏆</h2>
            <div id="finalScore" style="font-size: 24px; color: #ffd700; margin-bottom: 20px;"></div>
            <div id="nameInputSection">
                <div style="margin-bottom: 10px;">이름을 입력하세요:</div>
                <input type="text" id="nameInput" maxlength="10" placeholder="플레이어 이름">
                <br>
                <button onclick="saveScore()" style="margin-top: 15px;">기록 저장</button>
            </div>
            <div id="rankingList"></div>
            <div style="margin-top: 20px;">
                <button onclick="closeRanking()">닫기</button>
                <button onclick="restartGame()">다시 시작</button>
            </div>
        </div>
    </div>

    <div id="rightPanel">
        <div id="rankingContainer">
            <div id="rankingTitle">🏆 명예의 전당 🏆</div>
            <div id="liveRankingList">
                <div class="ranking-item">
                    <span class="ranking-rank">1</span>
                    <div>
                        <div class="ranking-score">기록 없음</div>
                        <div class="ranking-date">-</div>
                    </div>
                </div>
            </div>
            <div id="lastUpdated" style="font-size: 10px; color: #666; text-align: center; margin-top: 5px; padding: 0 10px;">
                마지막 업데이트: -
            </div>
        </div>

        <div id="controlsPanel">
            <div id="controlsTitle">🎮 게임 조작법 🎮</div>
            <div class="control-item"><span class="control-key">방향키</span> : 비행기 이동</div>
            <div class="control-item"><span class="control-key">Z키</span> : 필살기 발동</div>
            <div class="control-item"><span class="control-key">P키</span> : 일시정지/재개</div>
            <div class="control-item" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: #88ff88; font-weight: bold; margin-bottom: 4px;">📦 아이템 종류</div>
                <div><span class="control-key">H</span> : 호밍 미사일 <span class="item-description">적을 추적하는 유도탄</span></div>
                <div><span class="control-key">R</span> : 연사 탄환 <span class="item-description">빠른 연사 속도</span></div>
                <div><span class="control-key">P</span> : 관통 탄환 <span class="item-description">적을 관통해서 지나감</span></div>
                <div><span class="control-key">M</span> : 멀티샷 <span class="item-description">3방향 동시 발사</span></div>
                <div><span class="control-key">B</span> : 바운싱 탄환 <span class="item-description">벽에 튕기는 탄환</span></div>
                <div><span class="control-key">S</span> : 사이드킥 <span class="item-description">아이템 획득시 동반자 추가</span></div>
            </div>
            <div class="control-item" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 12px; color: #ff9999;">⚠️ 5초간 가만히 있으면 카미카제 적군 출현!</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameRunning = true;
        let gamePaused = false;
        let score = 0;
        let specialGauge = 0;
        let maxGauge = 100;
        let specialAttackActive = false;
        let specialAttackTimer = 0;
        let playerItems = [];
        let maxItems = 2;
        let multiShotActive = false;
        let rapidFireActive = false;
        let pierceActive = false;
        let homingActive = false;
        let bouncingActive = false;
        let itemEffectTimers = {
            multiShot: 0,
            rapidFire: 0,
            pierce: 0,
            homing: 0,
            bouncing: 0
        };
        let sidekicks = [];
        let maxSidekicks = 2;
        let lastSidekickShot = 0;
        let explosions = [];
        let difficultyLevel = 1;
        let maxDifficultyLevel = 999;
        let rankings = [];
        let maxRankings = 5;
        let lastMovementTime = 0;
        let idleThreshold = 5000; // 5초
        let kamikazeActive = false;
        let kamikazeEnemy = null;
        let playerLastX = 0;
        let playerLastY = 0;
        let bossActive = false;
        let currentBoss = null;
        let lastStage = 0;
        let flameWave = [];
        let flameWaveActive = false;
        let flameWaveHeight = 0;
        let baseEnemySpawnRate = 45;
        let currentEnemySpawnRate = 42;
        let basePlayerSpeed = 5;
        let currentPlayerSpeed = 5.15;
        let baseShotDelay = 60;
        let currentShotDelay = 57;
        let enemySpeedMultiplier = 1.05;
        
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false,
            space: false,
            z: false
        };

        let pKeyPressed = false;

        // 모바일 터치 컨트롤 변수들
        let touchControls = {
            joystick: {
                active: false,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                deltaX: 0,
                deltaY: 0
            },
            firing: false,
            specialAttack: false
        };

        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                      (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
        
        class GameObject {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            
            collidesWith(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }
        
        class Player extends GameObject {
            constructor() {
                super(canvas.width / 2 - 20, canvas.height - 60, 40, 50, '#00ff00');
                this.baseSpeed = 5;
                this.autoPilotTargetX = this.x;
                this.autoPilotTargetY = this.y;
            }
            
            update() {
                const speed = currentPlayerSpeed;
                let moved = false;

                if (keys.left && this.x > 0) {
                    this.x -= speed;
                    moved = true;
                }
                if (keys.right && this.x < canvas.width - this.width) {
                    this.x += speed;
                    moved = true;
                }
                if (keys.up && this.y > 0) {
                    this.y -= speed;
                    moved = true;
                }
                if (keys.down && this.y < canvas.height - this.height) {
                    this.y += speed;
                    moved = true;
                }

                // 움직임 감지 (카미카제 적은 제거하지 않음)
                if (moved || this.x !== playerLastX || this.y !== playerLastY) {
                    lastMovementTime = Date.now();
                    playerLastX = this.x;
                    playerLastY = this.y;
                }

                // 카미카제 적 스폰 체크 (플레이어가 가만히 있으면 계속 스폰) - 모바일에서는 비활성화
                if (!isMobile && Date.now() - lastMovementTime > idleThreshold) {
                    // 3초마다 새로운 카미카제 적 스폰
                    if (Date.now() - lastMovementTime > idleThreshold && (Date.now() - lastMovementTime) % 3000 < 100) {
                        spawnKamikazeEnemy();
                    }
                }
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                ctx.save();

                // 현대식 전투기 스타일 (F-22 랩터 같은 느낌)

                // 제트 엔진 배기 (이중 엔진)
                const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 12);
                exhaustGradient.addColorStop(0, '#0099ff');
                exhaustGradient.addColorStop(0.3, '#0066cc');
                exhaustGradient.addColorStop(0.7, '#004499');
                exhaustGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = exhaustGradient;
                // 이중 제트 엔진
                ctx.fillRect(centerX - 6, this.y + this.height, 4, 12);
                ctx.fillRect(centerX + 2, this.y + this.height, 4, 12);

                // 메인 동체 (스텔스 회색)
                const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                fuselageGradient.addColorStop(0, '#4a4a5a');
                fuselageGradient.addColorStop(0.5, '#5a5a6a');
                fuselageGradient.addColorStop(1, '#4a4a5a');

                ctx.fillStyle = fuselageGradient;
                ctx.fillRect(centerX - 10, this.y + 8, 20, 36);

                // 델타 날개 (스텔스 형태)
                const wingGradient = ctx.createLinearGradient(this.x - 22, centerY, this.x + this.width + 22, centerY);
                wingGradient.addColorStop(0, '#5a5a6a');
                wingGradient.addColorStop(0.5, '#6a6a7a');
                wingGradient.addColorStop(1, '#5a5a6a');

                ctx.fillStyle = wingGradient;

                // 좌측 델타 날개 (삼각형 모양)
                ctx.beginPath();
                ctx.moveTo(this.x - 20, this.y + 30);
                ctx.lineTo(centerX - 8, this.y + 18);
                ctx.lineTo(centerX - 8, this.y + 26);
                ctx.closePath();
                ctx.fill();

                // 우측 델타 날개
                ctx.beginPath();
                ctx.moveTo(this.x + this.width + 20, this.y + 30);
                ctx.lineTo(centerX + 8, this.y + 18);
                ctx.lineTo(centerX + 8, this.y + 26);
                ctx.closePath();
                ctx.fill();

                // 기수 (스텔스 각진 형태)
                const noseGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + 15);
                noseGradient.addColorStop(0, '#6a6a7a');
                noseGradient.addColorStop(1, '#5a5a6a');

                ctx.fillStyle = noseGradient;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX - 8, this.y + 12);
                ctx.lineTo(centerX + 8, this.y + 12);
                ctx.closePath();
                ctx.fill();

                // 조종석 (어두운 캐노피)
                ctx.fillStyle = '#1a1a2a';
                ctx.fillRect(centerX - 4, this.y + 10, 8, 12);

                // 레이더 흡수 재료 디테일
                ctx.strokeStyle = '#3a3a4a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX - 8, this.y + 15);
                ctx.lineTo(centerX + 8, this.y + 15);
                ctx.moveTo(centerX - 8, this.y + 25);
                ctx.lineTo(centerX + 8, this.y + 25);
                ctx.stroke();

                // 현대식 마킹 (별과 바)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(centerX - 8, this.y + 30, 4, 2);
                ctx.fillRect(centerX + 4, this.y + 30, 4, 2);

                ctx.fillStyle = '#0066cc';
                ctx.fillRect(centerX - 7, this.y + 30.5, 2, 1);
                ctx.fillRect(centerX + 5, this.y + 30.5, 2, 1);

                // 미사일 하드포인트
                ctx.fillStyle = '#666';
                ctx.fillRect(this.x - 18, this.y + 25, 3, 2);
                ctx.fillRect(this.x + this.width + 15, this.y + 25, 3, 2);

                // 공기 흡입구
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(centerX - 8, this.y + 20, 3, 6);
                ctx.fillRect(centerX + 5, this.y + 20, 3, 6);

                ctx.restore();
            }
        }
        
        class Bullet extends GameObject {
            constructor(x, y, isHoming = false, isPierce = false) {
                super(x, y, 4, 10, '#ffff00');
                this.speed = isHoming ? 7.2 : 12; // 호밍 미사일은 60% 속도
                this.isHoming = isHoming;
                this.isPierce = isPierce;
                this.hitEnemies = [];
            }
            
            update() {
                if (this.isHoming && enemies.length > 0) {
                    let nearestEnemy = enemies[0];
                    let minDistance = this.distanceTo(nearestEnemy);

                    enemies.forEach(enemy => {
                        const distance = this.distanceTo(enemy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestEnemy = enemy;
                        }
                    });

                    const dx = (nearestEnemy.x + nearestEnemy.width/2) - (this.x + this.width/2);
                    const dy = (nearestEnemy.y + nearestEnemy.height/2) - (this.y + this.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if (distance > 0) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                } else {
                    this.y -= this.speed;
                }
            }
            
            distanceTo(enemy) {
                const dx = (enemy.x + enemy.width/2) - (this.x + this.width/2);
                const dy = (enemy.y + enemy.height/2) - (this.y + this.height/2);
                return Math.sqrt(dx*dx + dy*dy);
            }
            
            draw() {
                if (this.isHoming) {
                    ctx.fillStyle = '#ff00ff';
                } else if (this.isPierce) {
                    ctx.fillStyle = '#00ffff';
                } else {
                    ctx.fillStyle = '#ffff00';
                }
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class BouncingBullet extends GameObject {
            constructor(x, y) {
                super(x, y, 4, 8, '#ffaa00');
                this.speed = 10;

                // Random direction: 40% straight up, 30% diagonal left, 30% diagonal right
                const direction = Math.random();
                if (direction < 0.4) {
                    // Straight up
                    this.vx = 0;
                    this.vy = -this.speed;
                } else if (direction < 0.7) {
                    // Diagonal left
                    this.vx = -this.speed * 0.7;
                    this.vy = -this.speed * 0.7;
                } else {
                    // Diagonal right
                    this.vx = this.speed * 0.7;
                    this.vy = -this.speed * 0.7;
                }

                this.bounces = 0;
                this.maxBounces = 4;
                this.hitEnemies = [];
                this.isBouncing = true;
            }

            update() {
                // Move the bullet
                this.x += this.vx;
                this.y += this.vy;

                // Check for wall collisions and bounce
                if (this.bounces < this.maxBounces) {
                    // Left wall collision
                    if (this.x <= 0) {
                        this.x = 0;
                        this.vx = Math.abs(this.vx);
                        this.bounces++;
                    }
                    // Right wall collision
                    else if (this.x + this.width >= canvas.width) {
                        this.x = canvas.width - this.width;
                        this.vx = -Math.abs(this.vx);
                        this.bounces++;
                    }

                    // Top wall collision
                    if (this.y <= 0) {
                        this.y = 0;
                        this.vy = Math.abs(this.vy);
                        this.bounces++;
                    }
                    // Bottom wall collision
                    else if (this.y + this.height >= canvas.height) {
                        this.y = canvas.height - this.height;
                        this.vy = -Math.abs(this.vy);
                        this.bounces++;
                    }
                }

                // Remove bullet if it has bounced too many times or goes off screen after max bounces
                return this.bounces >= this.maxBounces && (this.y < 0 || this.y > canvas.height || this.x < 0 || this.x > canvas.width);
            }

            draw() {
                // Create a glowing effect for bouncing bullets
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // Outer glow
                const glowGradient = ctx.createRadialGradient(centerX, centerY, 1, centerX, centerY, 8);
                glowGradient.addColorStop(0, '#ffaa00');
                glowGradient.addColorStop(0.5, '#ff6600');
                glowGradient.addColorStop(1, 'rgba(255, 102, 0, 0)');

                ctx.fillStyle = glowGradient;
                ctx.fillRect(this.x - 4, this.y - 4, this.width + 8, this.height + 8);

                // Main bullet body
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Inner highlight
                ctx.fillStyle = '#ffdd44';
                ctx.fillRect(this.x + 1, this.y + 1, this.width - 2, this.height - 2);
            }
        }

        class KamikazeEnemy extends GameObject {
            constructor(x, y, targetX, targetY) {
                super(x, y, 35, 40, '#ff0000');
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 6;
                this.isKamikaze = true;

                // 타겟 방향 계산
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // 카미카제 적 디자인 (빨간색 + 경고 효과)
                const warningGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 20);
                warningGradient.addColorStop(0, '#FF0000');
                warningGradient.addColorStop(0.7, '#AA0000');
                warningGradient.addColorStop(1, '#660000');

                ctx.fillStyle = warningGradient;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX - 15, this.y + 15);
                ctx.lineTo(centerX - 10, centerY);
                ctx.lineTo(centerX - 8, this.y + 30);
                ctx.lineTo(centerX - 4, this.y + this.height);
                ctx.lineTo(centerX + 4, this.y + this.height);
                ctx.lineTo(centerX + 8, this.y + 30);
                ctx.lineTo(centerX + 10, centerY);
                ctx.lineTo(centerX + 15, this.y + 15);
                ctx.closePath();
                ctx.fill();

                // 경고 표시
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('!', centerX, centerY + 3);
                ctx.textAlign = 'left';
                ctx.shadowBlur = 0;

                // 추진 효과
                const engineGradient = ctx.createRadialGradient(centerX, this.y + this.height + 8, 2, centerX, this.y + this.height + 8, 12);
                engineGradient.addColorStop(0, '#FFFFFF');
                engineGradient.addColorStop(0.3, '#FF4500');
                engineGradient.addColorStop(0.7, '#FF0000');
                engineGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = engineGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, this.y + this.height + 8, 8, 15, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        class BossEnemy extends GameObject {
            constructor(stageScore) {
                super(canvas.width / 2 - 60, -120, 120, 100, '#000000');
                this.hp = stageScore; // 스테이지 점수만큼의 HP
                this.maxHp = stageScore;
                this.speed = 1;
                this.shootTimer = 0;
                this.moveTimer = 0;
                this.moveDirection = Math.random() < 0.5 ? -1 : 1; // 랜덤 초기 방향
                this.isBoss = true;
                this.phase = 1;
                this.attackPattern = 0;
                this.patternTimer = 0;
            }

            update() {
                // 보스 등장 애니메이션 (위에서 내려옴)
                if (this.y < 50) {
                    this.y += this.speed;
                } else {
                    // 좌우 움직임 (더 균형적이고 중앙 지향적)
                    this.moveTimer++;
                    if (this.moveTimer > 180) { // 200에서 180으로 조정
                        this.moveDirection *= -1;
                        this.moveTimer = 0;
                    }

                    // 중앙으로 끌리는 힘 추가
                    const centerX = canvas.width / 2 - this.width / 2;
                    const distanceFromCenter = this.x - centerX;
                    const centerPull = distanceFromCenter * -0.02; // 중앙으로 끌리는 힘

                    this.x += this.moveDirection * 1.2 + centerPull; // 움직임 속도 약간 감소

                    // 경계 체크 (더 여유롭게)
                    if (this.x < 20) {
                        this.x = 20;
                        this.moveDirection = 1;
                        this.moveTimer = 0; // 방향 변경 시 타이머 리셋
                    }
                    if (this.x > canvas.width - this.width - 20) {
                        this.x = canvas.width - this.width - 20;
                        this.moveDirection = -1;
                        this.moveTimer = 0; // 방향 변경 시 타이머 리셋
                    }

                    // 공격 패턴
                    this.patternTimer++;
                    this.updateAttackPattern();
                }
                return false; // Boss should not be removed by update
            }

            updateAttackPattern() {
                // HP에 따른 페이즈 변경
                if (this.hp < this.maxHp * 0.3 && this.phase === 1) {
                    this.phase = 2;
                    this.attackPattern = 0;
                    this.patternTimer = 0;
                }

                if (this.phase === 1) {
                    // 페이즈 1: 직선 발사 (더 느리게 - 60에서 100으로 증가)
                    if (this.patternTimer % 100 === 0) {
                        this.shootStraight();
                    }
                } else {
                    // 페이즈 2: 산탄 발사 (더 느리게 - 40에서 70으로 증가)
                    if (this.patternTimer % 70 === 0) {
                        this.shootSpread();
                    }
                }
            }

            shootStraight() {
                // 플레이어 방향으로 직선 발사
                const centerX = this.x + this.width / 2;
                enemies.push(new BossBullet(centerX - 5, this.y + this.height, 0));
                enemies.push(new BossBullet(centerX + 5, this.y + this.height, 0));
            }

            shootSpread() {
                // 산탄 발사
                const centerX = this.x + this.width / 2;
                for (let i = -2; i <= 2; i++) {
                    enemies.push(new BossBullet(centerX, this.y + this.height, i * 0.5));
                }
            }

            takeDamage(damage = 1) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    // 보스 처치시 폭발 효과
                    for (let i = 0; i < 10; i++) {
                        createExplosion(
                            this.x + Math.random() * this.width,
                            this.y + Math.random() * this.height
                        );
                    }
                    if (bossActive) { // 정상적인 보스 처치시에만 점수 증가
                        const stageScore = difficultyLevel * 500;
                        score += Math.floor(stageScore * 0.5); // 스테이지 점수의 50%
                    }
                    bossActive = false;
                    currentBoss = null;

                    // 보스 처치 후 보스 탄환 모두 제거
                    enemies = enemies.filter(enemy => !enemy.isBossBullet);

                    // 스테이지 클리어 메시지
                    showStageClearMessage();

                    // 보스 처치 후 지연된 스테이지 진행 체크
                    setTimeout(() => {
                        updateDifficulty();
                    }, 1000);

                    return true;
                }
                return false;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // 스타워즈 스타 디스트로이어 디자인
                ctx.save();

                // 메인 삼각형 선체 (Star Destroyer 특징적인 쐐기 모양)
                const hullGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + this.height);
                hullGradient.addColorStop(0, '#C0C0C0');
                hullGradient.addColorStop(0.3, '#909090');
                hullGradient.addColorStop(0.7, '#707070');
                hullGradient.addColorStop(1, '#505050');

                ctx.fillStyle = hullGradient;
                ctx.beginPath();
                // 스타 디스트로이어 쐐기 모양
                ctx.moveTo(centerX, this.y + 10); // 뾰족한 앞부분
                ctx.lineTo(centerX - 55, this.y + this.height - 10); // 좌측 후면
                ctx.lineTo(centerX + 55, this.y + this.height - 10); // 우측 후면
                ctx.closePath();
                ctx.fill();

                // 상부 구조물 (브리지 타워)
                const bridgeGradient = ctx.createLinearGradient(centerX, this.y + 20, centerX, this.y + 50);
                bridgeGradient.addColorStop(0, '#B0B0B0');
                bridgeGradient.addColorStop(0.5, '#808080');
                bridgeGradient.addColorStop(1, '#606060');

                ctx.fillStyle = bridgeGradient;
                // 중앙 브리지 타워
                ctx.fillRect(centerX - 25, this.y + 20, 50, 25);

                // 브리지 상부 구조
                ctx.fillRect(centerX - 30, this.y + 15, 60, 15);

                // 함교 (Command Bridge)
                ctx.fillStyle = '#404040';
                ctx.fillRect(centerX - 20, this.y + 8, 40, 12);

                // 브리지 창문들 (Imperial officers' viewing windows)
                ctx.fillStyle = 'rgba(100, 150, 255, 0.8)';
                for (let i = 0; i < 8; i++) {
                    ctx.fillRect(centerX - 18 + i * 4.5, this.y + 10, 3, 6);
                }

                // 엔진 글로우 (후방 추진기들)
                const engineGradient = ctx.createLinearGradient(centerX, this.y + this.height - 15, centerX, this.y + this.height + 5);
                engineGradient.addColorStop(0, '#4080FF');
                engineGradient.addColorStop(0.5, '#2060FF');
                engineGradient.addColorStop(1, 'rgba(32, 96, 255, 0)');

                ctx.fillStyle = engineGradient;
                // 대형 주 엔진들 (Star Destroyer 특징적인 후방 엔진)
                ctx.fillRect(centerX - 45, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX - 30, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX - 15, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX + 3, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX + 18, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX + 33, this.y + this.height - 12, 12, 18);

                // 표면 세부 사항 (Imperial hull paneling)
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = 1;

                // 선체 패널 라인들
                ctx.beginPath();
                ctx.moveTo(centerX - 40, this.y + 30);
                ctx.lineTo(centerX + 40, this.y + 30);
                ctx.moveTo(centerX - 35, this.y + 45);
                ctx.lineTo(centerX + 35, this.y + 45);
                ctx.moveTo(centerX - 30, this.y + 60);
                ctx.lineTo(centerX + 30, this.y + 60);
                ctx.stroke();

                // 측면 무기 하드포인트 (Turbolaser batteries)
                ctx.fillStyle = '#505050';

                // 좌측 터보레이저 포탑들
                ctx.fillRect(centerX - 50, this.y + 40, 8, 6);
                ctx.fillRect(centerX - 50, this.y + 55, 8, 6);
                ctx.fillRect(centerX - 45, this.y + 70, 6, 4);

                // 우측 터보레이저 포탑들
                ctx.fillRect(centerX + 42, this.y + 40, 8, 6);
                ctx.fillRect(centerX + 42, this.y + 55, 8, 6);
                ctx.fillRect(centerX + 39, this.y + 70, 6, 4);

                // 제국 마크/로고 위치 (중앙 상부)
                ctx.fillStyle = '#303030';
                ctx.beginPath();
                ctx.arc(centerX, this.y + 35, 8, 0, Math.PI * 2);
                ctx.fill();

                // 안테나/통신 장비
                ctx.strokeStyle = '#606060';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX - 10, this.y + 15);
                ctx.lineTo(centerX - 10, this.y + 5);
                ctx.moveTo(centerX + 10, this.y + 15);
                ctx.lineTo(centerX + 10, this.y + 5);
                // Star Destroyer 특징적인 디테일 완성
                ctx.fillStyle = '#808080';

                // 하위 포탑들 (Heavy turbolaser turrets)
                ctx.fillRect(centerX - 15, this.y + 50, 5, 3);
                ctx.fillRect(centerX + 10, this.y + 50, 5, 3);
                ctx.fillRect(centerX - 8, this.y + 65, 4, 3);
                ctx.fillRect(centerX + 4, this.y + 65, 4, 3);

                // Imperial insignia (제국 로고)
                ctx.fillStyle = '#202020';
                ctx.beginPath();
                ctx.arc(centerX, this.y + 55, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // HP 바
                const hpBarWidth = this.width;
                const hpBarHeight = 8;
                const hpPercentage = this.hp / this.maxHp;

                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x, this.y - 15, hpBarWidth, hpBarHeight);

                ctx.fillStyle = hpPercentage > 0.3 ? '#00FF00' : '#FF0000';
                ctx.fillRect(this.x, this.y - 15, hpBarWidth * hpPercentage, hpBarHeight);

                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - 15, hpBarWidth, hpBarHeight);

                // 페이즈 2에서 빨간 경고 효과
                if (this.phase === 2) {
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                    ctx.shadowBlur = 0;
                }
            }
        }

        class BossBullet extends GameObject {
            constructor(x, y, angle) {
                super(x, y, 8, 12, '#FF0000');
                this.speed = 4;
                this.angle = angle;
                this.vx = Math.sin(angle) * this.speed;
                this.vy = this.speed;
                this.isBossBullet = true;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // 보스 총알은 화면을 벗어나면 다시 위에서 나타남 (순환)
                if (this.y > canvas.height + 20) {
                    this.y = -20;
                }
                if (this.x < -20) {
                    this.x = canvas.width + 20;
                } else if (this.x > canvas.width + 20) {
                    this.x = -20;
                }
                if (this.y < -20) {
                    this.y = canvas.height + 20;
                }
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // 빨간 에너지 탄환
                const bulletGradient = ctx.createRadialGradient(centerX, centerY, 2, centerX, centerY, 6);
                bulletGradient.addColorStop(0, '#FFFF00');
                bulletGradient.addColorStop(0.5, '#FF4500');
                bulletGradient.addColorStop(1, '#FF0000');

                ctx.fillStyle = bulletGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 4, 6, 0, 0, 2 * Math.PI);
                ctx.fill();

                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 2, 3, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class UAPBullet extends GameObject {
            constructor(x, y, vx, vy) {
                super(x, y, 6, 14, '#00FFAA');
                this.vx = vx;
                this.vy = vy;
                this.isUAPBullet = true;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // UAP 총알은 화면을 벗어나면 제거됨 (BossBullet과 달리 순환하지 않음)
                if (this.y < -20 || this.y > canvas.height + 20 ||
                    this.x < -20 || this.x > canvas.width + 20) {
                    return true; // 제거 신호
                }
                return false;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // 외계 에너지 빔 효과 (청록색)
                const bulletGradient = ctx.createRadialGradient(centerX, centerY, 1, centerX, centerY, 7);
                bulletGradient.addColorStop(0, '#FFFFFF');
                bulletGradient.addColorStop(0.3, '#00FFFF');
                bulletGradient.addColorStop(0.7, '#00CCAA');
                bulletGradient.addColorStop(1, '#004455');

                ctx.fillStyle = bulletGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 3, 7, 0, 0, 2 * Math.PI);
                ctx.fill();

                // 내부 밝은 코어
                ctx.shadowColor = '#00FFAA';
                ctx.shadowBlur = 12;
                ctx.fillStyle = '#AAFFFF';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 1.5, 4, 0, 0, 2 * Math.PI);
                ctx.fill();

                // 에너지 파장 효과
                ctx.shadowBlur = 6;
                ctx.strokeStyle = '#00FFAA';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 4, 8, 0, 0, 2 * Math.PI);
                ctx.stroke();

                ctx.shadowBlur = 0;
            }
        }

        class EliteEnemy extends GameObject {
            constructor(x, y, hp) {
                super(x, y, 40, 45, '#ff0000');
                this.baseSpeed = 1.5 + Math.random() * 1;
                this.speed = this.baseSpeed * enemySpeedMultiplier;
                this.type = Math.floor(Math.random() * 3);
                this.hp = hp;
                this.maxHp = hp;
                this.isElite = true;
            }

            takeDamage(damage = 1) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    return true; // 처치됨
                }
                return false;
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // 강화 적은 기존 디자인에 황금색 테두리와 HP 바 추가
                if (this.type === 0) {
                    // UAP 강화형
                    const uapGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 20);
                    uapGradient.addColorStop(0, '#FFD700');
                    uapGradient.addColorStop(0.4, '#FFA500');
                    uapGradient.addColorStop(0.8, '#FF8C00');
                    uapGradient.addColorStop(1, '#FF4500');

                    ctx.fillStyle = uapGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 18, 10, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // 상단 돔
                    const domeGradient = ctx.createRadialGradient(centerX, centerY - 3, 2, centerX, centerY - 3, 12);
                    domeGradient.addColorStop(0, '#FFFF00');
                    domeGradient.addColorStop(0.6, '#FFD700');
                    domeGradient.addColorStop(1, '#FFA500');

                    ctx.fillStyle = domeGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY - 3, 12, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // 황금 빛
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 22, 12, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                } else if (this.type === 1) {
                    // TIE Fighter 강화형
                    const imperialGold = '#FFD700';
                    const darkGold = '#B8860B';

                    // 중앙 조종실
                    const cockpitGradient = ctx.createRadialGradient(centerX, centerY, 3, centerX, centerY, 10);
                    cockpitGradient.addColorStop(0, '#FFD700');
                    cockpitGradient.addColorStop(0.7, '#DAA520');
                    cockpitGradient.addColorStop(1, '#B8860B');

                    ctx.fillStyle = cockpitGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 10, 10, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // 황금 솔라 패널
                    ctx.fillStyle = imperialGold;
                    ctx.beginPath();
                    ctx.moveTo(this.x - 18, centerY - 12);
                    ctx.lineTo(this.x - 5, centerY - 14);
                    ctx.lineTo(this.x - 2, centerY - 10);
                    ctx.lineTo(this.x - 2, centerY + 10);
                    ctx.lineTo(this.x - 5, centerY + 14);
                    ctx.lineTo(this.x - 18, centerY + 12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width + 18, centerY - 12);
                    ctx.lineTo(this.x + this.width + 5, centerY - 14);
                    ctx.lineTo(this.x + this.width + 2, centerY - 10);
                    ctx.lineTo(this.x + this.width + 2, centerY + 10);
                    ctx.lineTo(this.x + this.width + 5, centerY + 14);
                    ctx.lineTo(this.x + this.width + 18, centerY + 12);
                    ctx.closePath();
                    ctx.fill();

                } else {
                    // 강화 구축함
                    const goldGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + this.height);
                    goldGradient.addColorStop(0, '#FFD700');
                    goldGradient.addColorStop(0.5, '#DAA520');
                    goldGradient.addColorStop(1, '#B8860B');

                    ctx.fillStyle = goldGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 18, this.y + 10);
                    ctx.lineTo(centerX - 15, this.y + this.height);
                    ctx.lineTo(centerX + 15, this.y + this.height);
                    ctx.lineTo(centerX + 18, this.y + 10);
                    ctx.closePath();
                    ctx.fill();
                }

                // HP 바
                const hpBarWidth = this.width + 10;
                const hpBarHeight = 6;
                const hpPercentage = this.hp / this.maxHp;

                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x - 5, this.y - 12, hpBarWidth, hpBarHeight);

                ctx.fillStyle = hpPercentage > 0.5 ? '#FFD700' : hpPercentage > 0.25 ? '#FFA500' : '#FF4500';
                ctx.fillRect(this.x - 5, this.y - 12, hpBarWidth * hpPercentage, hpBarHeight);

                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x - 5, this.y - 12, hpBarWidth, hpBarHeight);

                // 황금 테두리 효과
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
                ctx.shadowBlur = 0;
            }
        }

        class Enemy extends GameObject {
            constructor(x, y) {
                super(x, y, 30, 35, '#ff0000');
                this.baseSpeed = 2 + Math.random() * 2;
                this.speed = this.baseSpeed * enemySpeedMultiplier;
                this.type = Math.floor(Math.random() * 3);
            }
            
            update() {
                this.y += this.speed;
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // 값 유효성 검사
                if (!isFinite(centerX) || !isFinite(centerY) || !isFinite(this.x) || !isFinite(this.y) ||
                    !isFinite(this.width) || !isFinite(this.height)) {
                    return; // 잘못된 값이면 그리기 중단
                }

                ctx.save();

                if (this.type === 0) {
                    // German Messerschmitt Bf 109 style (larger and more detailed)

                    // Engine exhaust (larger)
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 4, this.y + this.height, 8, 10);

                    // Main fuselage (dark gray with better contrast)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                    fuselageGradient.addColorStop(0, '#2a2a2a');
                    fuselageGradient.addColorStop(0.5, '#4a4a4a');
                    fuselageGradient.addColorStop(1, '#2a2a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 8, this.y + 6, 16, 30);

                    // Engine cowling
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(centerX - 6, this.y + 2, 12, 8);

                    // Wings (larger and more realistic)
                    const wingGradient = ctx.createLinearGradient(this.x - 20, centerY, this.x + this.width + 20, centerY);
                    wingGradient.addColorStop(0, '#3a3a3a');
                    wingGradient.addColorStop(0.5, '#5a5a5a');
                    wingGradient.addColorStop(1, '#3a3a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing
                    ctx.fillRect(this.x - 16, this.y + 18, 20, 8);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 18, 20, 8);

                    // Nose/propeller area
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 6, this.y + 10);
                    ctx.lineTo(centerX + 6, this.y + 10);
                    ctx.closePath();
                    ctx.fill();

                    // German Balkenkreuz (Iron Cross)
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(centerX - 1, this.y + 12, 2, 12);
                    ctx.fillRect(centerX - 6, this.y + 17, 12, 2);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 5, this.y + 17.5, 4, 1);
                    ctx.fillRect(centerX + 1, this.y + 17.5, 4, 1);

                    // Wing guns
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(this.x - 14, this.y + 20, 2, 4);
                    ctx.fillRect(this.x + this.width + 12, this.y + 20, 2, 4);

                } else if (this.type === 1) {
                    // Japanese Mitsubishi A6M Zero style (larger and more detailed)

                    // Engine exhaust
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 3, this.y + this.height, 6, 10);

                    // Main fuselage (olive/dark green)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 8, centerY, centerX + 8, centerY);
                    fuselageGradient.addColorStop(0, '#2a3a2a');
                    fuselageGradient.addColorStop(0.5, '#3a4a3a');
                    fuselageGradient.addColorStop(1, '#2a3a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 7, this.y + 4, 14, 32);

                    // Engine cowling
                    ctx.fillStyle = '#1a2a1a';
                    ctx.fillRect(centerX - 5, this.y + 1, 10, 8);

                    // Wings (longer, typical of Zero)
                    const wingGradient = ctx.createLinearGradient(this.x - 18, centerY, this.x + this.width + 18, centerY);
                    wingGradient.addColorStop(0, '#3a4a3a');
                    wingGradient.addColorStop(0.5, '#4a5a4a');
                    wingGradient.addColorStop(1, '#3a4a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing (longer)
                    ctx.fillRect(this.x - 18, this.y + 16, 22, 7);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 16, 22, 7);

                    // Nose
                    ctx.fillStyle = '#4a5a4a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 5, this.y + 8);
                    ctx.lineTo(centerX + 5, this.y + 8);
                    ctx.closePath();
                    ctx.fill();

                    // Japanese Hinomaru (Rising Sun)
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(centerX, this.y + 18, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#cc0000';
                    ctx.beginPath();
                    ctx.arc(centerX, this.y + 18, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Wing guns
                    ctx.fillStyle = '#ffaa44';
                    ctx.fillRect(this.x - 16, this.y + 18, 2, 3);
                    ctx.fillRect(this.x + this.width + 14, this.y + 18, 2, 3);

                } else {
                    // Italian/Other Axis Macchi C.202 style (larger and more detailed)

                    // Engine exhaust
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 4, this.y + this.height, 8, 10);

                    // Main fuselage (sand/brown camo)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                    fuselageGradient.addColorStop(0, '#4a3a2a');
                    fuselageGradient.addColorStop(0.5, '#5a4a3a');
                    fuselageGradient.addColorStop(1, '#4a3a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 8, this.y + 5, 16, 30);

                    // Engine cowling
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(centerX - 6, this.y + 2, 12, 8);

                    // Wings
                    const wingGradient = ctx.createLinearGradient(this.x - 17, centerY, this.x + this.width + 17, centerY);
                    wingGradient.addColorStop(0, '#5a4a3a');
                    wingGradient.addColorStop(0.5, '#6a5a4a');
                    wingGradient.addColorStop(1, '#5a4a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing
                    ctx.fillRect(this.x - 15, this.y + 17, 19, 8);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 17, 19, 8);

                    // Nose
                    ctx.fillStyle = '#6a5a4a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 6, this.y + 9);
                    ctx.lineTo(centerX + 6, this.y + 9);
                    ctx.closePath();
                    ctx.fill();

                    // Italian fasces symbol (simplified)
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(centerX - 4, this.y + 15, 8, 2);
                    ctx.fillRect(centerX - 1, this.y + 13, 2, 6);
                    ctx.fillStyle = '#006600';
                    ctx.fillRect(centerX - 3, this.y + 15.5, 6, 1);

                    // Wing guns
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(this.x - 13, this.y + 19, 2, 4);
                    ctx.fillRect(this.x + this.width + 11, this.y + 19, 2, 4);
                }

                ctx.restore();
            }
        }

        class UAPEnemy extends GameObject {
            constructor() {
                // 구름 위치에서 스폰 (구름과 비슷한 위치)
                const cloudX = Math.random() * canvas.width;
                const cloudY = Math.random() * canvas.height * 0.7; // 화면 상단 70%에서 스폰
                super(cloudX, cloudY, 30, 20, '#silver');

                this.speed = 3 + Math.random() * 3; // 더 빠르게
                this.rotationAngle = 0;
                this.glowIntensity = 0;
                this.isUAP = true;
                this.isEmerging = true; // 등장 상태
                this.emergingTimer = 0;
                this.attackMode = false;
                this.shootTimer = 0;

                // 초기에는 숨어있음 (투명)
                this.alpha = 0;
                this.originalY = this.y;

                // 잠시 후 플레이어를 추적하기 시작
                this.updateTarget();
            }

            updateTarget() {
                // 플레이어를 향한 방향 계산
                const dx = (player.x + player.width / 2) - (this.x + this.width / 2);
                const dy = (player.y + player.height / 2) - (this.y + this.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                }
            }

            update() {
                this.emergingTimer++;

                if (this.isEmerging) {
                    // 구름에서 서서히 등장 (2초간)
                    if (this.emergingTimer < 120) {
                        this.alpha = Math.min(1, this.emergingTimer / 60);
                        // 살짝 위아래로 움직임 (등장 효과)
                        this.y = this.originalY + Math.sin(this.emergingTimer * 0.1) * 5;
                    } else {
                        // 등장 완료, 공격 모드 시작
                        this.isEmerging = false;
                        this.attackMode = true;
                        this.alpha = 1;
                        this.updateTarget(); // 플레이어 위치 재계산
                    }
                } else if (this.attackMode) {
                    // 공격 모드: 플레이어를 향해 빠르게 돌진
                    this.x += this.vx;
                    this.y += this.vy;

                    // 주기적으로 방향 업데이트 (유도 미사일처럼)
                    if (this.emergingTimer % 30 === 0) {
                        this.updateTarget();
                    }

                    // UAP 발사 (매 60프레임마다)
                    this.shootTimer++;
                    if (this.shootTimer >= 60) {
                        this.shoot();
                        this.shootTimer = 0;
                    }
                }

                // 회전 효과
                this.rotationAngle += 0.1;
                this.glowIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;

                // 화면 밖으로 나가면 제거 대상
                if (this.x < -50 || this.x > canvas.width + 50 ||
                    this.y < -50 || this.y > canvas.height + 50) {
                    return true; // 제거 신호
                }
                return false;
            }

            shoot() {
                // UAP 에너지 탄환 발사
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // 플레이어를 향한 에너지 탄환
                const dx = (player.x + player.width / 2) - centerX;
                const dy = (player.y + player.height / 2) - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const bulletSpeed = 4;
                    const vx = (dx / distance) * bulletSpeed;
                    const vy = (dy / distance) * bulletSpeed;

                    // UAP 전용 탄환 생성
                    enemies.push(new UAPBullet(centerX - 2, centerY, vx, vy));
                }
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.rotationAngle);

                // UAP 몸체 (원반형)
                const uapGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 18);
                uapGradient.addColorStop(0, '#E6E6FA');
                uapGradient.addColorStop(0.4, '#C0C0C0');
                uapGradient.addColorStop(0.8, '#808080');
                uapGradient.addColorStop(1, '#404040');

                ctx.fillStyle = uapGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 8, 0, 0, 2 * Math.PI);
                ctx.fill();

                // 상단 돔
                const domeGradient = ctx.createRadialGradient(0, -3, 2, 0, -3, 10);
                domeGradient.addColorStop(0, '#F0F8FF');
                domeGradient.addColorStop(0.6, '#B0C4DE');
                domeGradient.addColorStop(1, '#778899');

                ctx.fillStyle = domeGradient;
                ctx.beginPath();
                ctx.ellipse(0, -3, 10, 5, 0, 0, 2 * Math.PI);
                ctx.fill();

                // 주변 글로우 효과
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 12 * this.glowIntensity;
                ctx.fillStyle = `rgba(0, 255, 255, ${0.4 * this.glowIntensity})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, 18, 10, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;

                // 빛 점들
                ctx.fillStyle = '#00FFFF';
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI / 3) + this.rotationAngle;
                    const lightX = Math.cos(angle) * 12;
                    const lightY = Math.sin(angle) * 7;
                    ctx.beginPath();
                    ctx.arc(lightX, lightY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Cloud {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = 0.3 + Math.random() * 0.8; // 구름은 더 천천히
                this.size = 20 + Math.random() * 40; // 구름은 더 크게
                this.alpha = 0.3 + Math.random() * 0.4; // 구름은 더 투명하게
                this.offsetX = Math.random() * 10; // 수평 이동
            }

            update() {
                this.y += this.speed;
                this.x += Math.sin(Date.now() * 0.001 + this.offsetX) * 0.2; // 부드러운 수평 움직임

                if (this.y > canvas.height + 50) {
                    this.y = -50;
                    this.x = Math.random() * canvas.width;
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;

                // 구름 그리기 (여러 원을 겹쳐서 구름 모양)
                const cloudGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                cloudGradient.addColorStop(0, '#ffffff');
                cloudGradient.addColorStop(0.7, '#e6e6e6');
                cloudGradient.addColorStop(1, 'rgba(200, 200, 200, 0)');

                ctx.fillStyle = cloudGradient;

                // 메인 구름 몸체 (여러 원으로 구성)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.3, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x + this.size * 0.3, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x, this.y - this.size * 0.2, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        
        class Item extends GameObject {
            constructor(x, y) {
                super(x, y, 20, 20, '#00ff00');
                this.speed = 3;
                this.types = ['multiShot', 'rapidFire', 'pierce', 'homing', 'bouncing'];
                this.type = this.types[Math.floor(Math.random() * this.types.length)];
                this.colors = {
                    multiShot: '#ff6600',
                    rapidFire: '#ff0066',
                    pierce: '#00ffff',
                    homing: '#ff00ff',
                    bouncing: '#ffaa00'
                };
                this.symbols = {
                    multiShot: 'M',
                    rapidFire: 'R',
                    pierce: 'P',
                    homing: 'H',
                    bouncing: 'B'
                };
                this.color = this.colors[this.type];
            }
            
            update() {
                this.y += this.speed;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.symbols[this.type], this.x + this.width/2, this.y + this.height/2 + 4);
                ctx.textAlign = 'left';
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - 1, this.y - 1, this.width + 2, this.height + 2);
            }
        }
        
        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.timer = 0;
                this.maxTimer = 20;
                
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 1.0
                    });
                }
            }
            
            update() {
                this.timer++;
                this.particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.95;
                    particle.vy *= 0.95;
                    particle.life -= 0.05;
                });
            }
            
            draw() {
                this.particles.forEach(particle => {
                    if (particle.life > 0) {
                        ctx.globalAlpha = particle.life;
                        ctx.fillStyle = `hsl(${30 + Math.random() * 30}, 100%, 60%)`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                });
            }
            
            isDead() {
                return this.timer >= this.maxTimer;
            }
        }
        
        class Sidekick extends GameObject {
            constructor(side) {
                super(0, 0, 15, 20, '#00aa00');
                this.side = side;
                this.lastShot = 0; // 개별 발사 타이머
                this.lastBouncingShot = 0; // 바운싱 총알 발사 타이머
                if (side === 'left') {
                    this.offsetX = -30;
                    this.offsetY = 10;
                } else {
                    this.offsetX = 30;
                    this.offsetY = 10;
                }
            }
            
            update(playerX, playerY) {
                // 플레이어 기체의 중심에서 계산
                const playerCenterX = playerX + 20;
                const playerCenterY = playerY + 25;
                
                this.x = playerCenterX + this.offsetX - this.width / 2;
                this.y = playerCenterY + this.offsetY - this.height / 2;
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Main body (green)
                ctx.fillStyle = '#00AA00';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 6, 8, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Wing (darker green)
                ctx.fillStyle = '#007700';
                if (this.side === 'left') {
                    ctx.beginPath();
                    ctx.moveTo(this.x - 3, centerY);
                    ctx.lineTo(this.x + 3, centerY - 5);
                    ctx.lineTo(this.x + 3, centerY + 5);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width + 3, centerY);
                    ctx.lineTo(this.x + this.width - 3, centerY - 5);
                    ctx.lineTo(this.x + this.width - 3, centerY + 5);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Engine (bright green)
                ctx.fillStyle = '#00FF00';
                ctx.beginPath();
                ctx.ellipse(centerX, this.y + this.height + 2, 2, 4, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Core (cyan)
                ctx.fillStyle = '#00FFAA';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 3, 4, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        const player = new Player();
        let bullets = [];
        let enemies = [];
        const clouds = []; // 구름
        let items = [];
        let sidekickBullets = [];
        let bouncingBullets = [];

        // 구름 초기화 (개수 줄임)
        for (let i = 0; i < 15; i++) {
            clouds.push(new Cloud());
        }
        
        let lastShot = 0;
        let lastBouncingShot = 0;
        let enemySpawnTimer = 0;
        let itemSpawnTimer = 0;
        
        function spawnEnemy() {
            // 플레이어 위치와 속도를 고려한 스폰 위치 계산
            const playerCenterX = player.x + player.width / 2;
            const playerSpeed = currentPlayerSpeed;

            // 적이 화면을 가로지르는 시간 계산 (대략적)
            const enemySpeed = 2 + Math.random() * 2; // 적의 기본 속도
            const timeToReachPlayer = canvas.height / (enemySpeed * enemySpeedMultiplier);

            // 플레이어가 이동할 수 있는 최대 거리
            const maxPlayerMovement = playerSpeed * timeToReachPlayer;

            // 플레이어가 도달 가능한 범위 계산
            const minReachableX = Math.max(0, playerCenterX - maxPlayerMovement);
            const maxReachableX = Math.min(canvas.width, playerCenterX + maxPlayerMovement);

            // 도달 가능한 범위에서 적 스폰 (약간의 여유 추가)
            const safetyMargin = 50; // 여유 공간
            const spawnMinX = Math.max(0, minReachableX - safetyMargin);
            const spawnMaxX = Math.min(canvas.width - 25, maxReachableX + safetyMargin);

            // 최소 스폰 범위 보장
            const minSpawnRange = 200;
            let finalSpawnRange = spawnMaxX - spawnMinX;

            if (finalSpawnRange < minSpawnRange) {
                // 범위가 너무 좁으면 플레이어 중심으로 최소 범위 확보
                const centerX = (spawnMinX + spawnMaxX) / 2;
                const halfRange = minSpawnRange / 2;
                const newMinX = Math.max(0, centerX - halfRange);
                const newMaxX = Math.min(canvas.width - 25, centerX + halfRange);

                const x = newMinX + Math.random() * (newMaxX - newMinX);
                enemies.push(new Enemy(x, -25));
            } else {
                const x = spawnMinX + Math.random() * (spawnMaxX - spawnMinX);
                enemies.push(new Enemy(x, -25));
            }
        }
        
        function updateDifficulty() {
            // 스테이지별 필요 점수: 1→2(500), 2→3(1500), 3→4(3000), 4→5(4500)...
            let newDifficultyLevel = 1;
            const stageThresholds = [];

            // 스테이지 2: 500점
            // 스테이지 3: 1500점 (500 + 1000)
            // 스테이지 4: 3000점 (1500 + 1500)
            // 스테이지 5: 4500점 (3000 + 1500)
            // 패턴: n번째 스테이지 = (n-1) * n * 250
            for (let stage = 2; stage <= 100; stage++) {
                const threshold = (stage - 1) * stage * 250;
                stageThresholds.push(threshold);
            }

            for (let i = 0; i < stageThresholds.length; i++) {
                if (score >= stageThresholds[i]) {
                    newDifficultyLevel = i + 2; // i+2 because stage 1 starts at 0 points
                } else {
                    break;
                }
            }

            // 보스가 활성화되어 있으면 스테이지 진행을 막음
            if (newDifficultyLevel > difficultyLevel && !bossActive) {
                difficultyLevel = newDifficultyLevel;

                // 적 스폰 속도 (단계별 3프레임 감소, 최소 8프레임)
                currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (difficultyLevel * 3));

                // 적 이동 속도 (단계별 5% 증가, 최대 2배)
                enemySpeedMultiplier = Math.min(2.0, 1.0 + (difficultyLevel * 0.05));

                // 플레이어 이동 속도 (단계별 3% 증가, 최대 1.6배)
                currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + difficultyLevel * 0.03));

                // 플레이어 샇 속도 (단계별 3ms 감소, 최소 30ms)
                currentShotDelay = rapidFireActive ?
                    Math.max(15, baseShotDelay - (difficultyLevel * 3)) / 3 :
                    Math.max(30, baseShotDelay - (difficultyLevel * 3));

                // 스테이지 알림 먼저 표시
                showStageMessage();

                // 보스 소환 (2초 후, HP = 스테이지 점수)
                setTimeout(() => {
                    if (gameRunning && !gamePaused) { // 게임이 계속 진행 중일 때만 보스 소환
                        const stageScore = difficultyLevel * 500;
                        spawnBoss(stageScore);
                    }
                }, 2000);
            }
        }

        function spawnBoss(stageScore) {
            if (!bossActive) {
                bossActive = true;
                currentBoss = new BossEnemy(stageScore);
                enemies.push(currentBoss);

                // 보스 등장 시 일반 적 증가 (3-5마리 추가 스폰)
                const extraEnemyCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < extraEnemyCount; i++) {
                    setTimeout(() => {
                        const x = Math.random() * (canvas.width - 25);
                        enemies.push(new Enemy(x, -25));
                    }, i * 150); // 150ms 간격으로 스폰
                }

                showBossMessage();
            }
        }

        function spawnEliteEnemy(hp) {
            // 플레이어가 도달 가능한 범위에서 강화 적 스폰
            const playerCenterX = player.x + player.width / 2;
            const playerSpeed = currentPlayerSpeed;
            const enemySpeed = 1.5 + Math.random() * 1;
            const timeToReachPlayer = canvas.height / (enemySpeed * enemySpeedMultiplier);
            const maxPlayerMovement = playerSpeed * timeToReachPlayer;

            const minReachableX = Math.max(0, playerCenterX - maxPlayerMovement);
            const maxReachableX = Math.min(canvas.width, playerCenterX + maxPlayerMovement);

            const safetyMargin = 50;
            const spawnMinX = Math.max(0, minReachableX - safetyMargin);
            const spawnMaxX = Math.min(canvas.width - 40, maxReachableX + safetyMargin);

            const x = spawnMinX + Math.random() * (spawnMaxX - spawnMinX);
            enemies.push(new EliteEnemy(x, -45, hp));
        }

        function showBossMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2;

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #ff0000;
                font-size: 36px;
                font-weight: bold;
                z-index: 1001;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: bossWarning 2.5s ease-in-out;
            `;
            message.textContent = `⚠️ STAGE ${difficultyLevel} BOSS ⚠️`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes bossWarning {
                    0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    10%, 90% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 2500);
        }

        function showStageClearMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2 - 50; // Slightly above center

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #00ff00;
                font-size: 32px;
                font-weight: bold;
                z-index: 1002;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: stageClear 1.8s ease-in-out;
            `;
            message.textContent = `🎉 STAGE ${difficultyLevel} CLEAR! 🎉`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes stageClear {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 1800);
        }

        function showStageMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2 + 50; // Slightly below center

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #ffd700;
                font-size: 28px;
                font-weight: bold;
                z-index: 1000;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: stageUp 1.5s ease-in-out;
            `;
            message.textContent = `⭐ STAGE ${difficultyLevel} ⭐`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes stageUp {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 1500);
        }
        
        function showDifficultyMessage() {
            // 화면에 잠깐 난이도 증가 메시지 표시
            const message = document.createElement('div');
            const isMaxLevel = difficultyLevel >= maxDifficultyLevel;
            message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${isMaxLevel ? '#ff0000' : '#ff6600'};
                font-size: ${isMaxLevel ? '32px' : '28px'};
                font-weight: bold;
                z-index: 1000;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                pointer-events: none;
            `;
            
            if (isMaxLevel) {
                message.textContent = '최고 난이도 달성!';
            } else {
                message.textContent = `난이도 ${difficultyLevel}단계!`;
            }
            
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
            }, isMaxLevel ? 3000 : 2000);
        }
        
        function spawnKamikazeEnemy() {
            kamikazeActive = true;

            // 플레이어 위치 기준으로 화면 가장자리에서 스폰
            let spawnX, spawnY;
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            // 랜덤하게 4방향 중 하나에서 스폰
            const side = Math.floor(Math.random() * 4);
            switch(side) {
                case 0: // 위쪽
                    spawnX = Math.random() * canvas.width;
                    spawnY = -50;
                    break;
                case 1: // 아래쪽
                    spawnX = Math.random() * canvas.width;
                    spawnY = canvas.height + 50;
                    break;
                case 2: // 왼쪽
                    spawnX = -50;
                    spawnY = Math.random() * canvas.height;
                    break;
                case 3: // 오른쪽
                    spawnX = canvas.width + 50;
                    spawnY = Math.random() * canvas.height;
                    break;
            }

            kamikazeEnemy = new KamikazeEnemy(spawnX, spawnY, playerCenterX, playerCenterY);
            enemies.push(kamikazeEnemy);
        }

        function update() {
            if (!gameRunning || gamePaused) return;
            
            player.update();
            
            // Regular shooting logic - always fires regardless of bouncing effect
            if (Date.now() - lastShot > currentShotDelay) {
                // 기본 더블 샷
                bullets.push(new Bullet(player.x + player.width / 2 - 8, player.y - 5));
                bullets.push(new Bullet(player.x + player.width / 2 + 4, player.y - 5));
                lastShot = Date.now();
            }

            // Bouncing bullets - additional shots when bouncing effect is active
            if (bouncingActive) {
                if (Date.now() - lastBouncingShot > 800) {
                    bouncingBullets.push(new BouncingBullet(player.x + player.width / 2 - 2, player.y - 5));
                    lastBouncingShot = Date.now();
                }
            }
            
            // Sidekick shooting with individual item abilities
            sidekicks.forEach((sidekick, index) => {
                // 각 사이드킥은 해당 인덱스의 아이템 효과를 사용
                const hasItem = playerItems.length > index;

                if (hasItem) {
                    const item = playerItems[index];
                    const isMultiShot = item.type === 'multiShot';
                    const isHoming = item.type === 'homing';
                    const isPierce = item.type === 'pierce';
                    const isRapidFire = item.type === 'rapidFire';
                    const isBouncing = item.type === 'bouncing';

                    // 각 아이템 유형별 발사 간격
                    const baseDelay = 200;
                    let currentDelay = baseDelay;

                    if (isRapidFire) {
                        currentDelay = isHoming ? 230 : 70; // 연사 + 호밍조합
                    } else if (isHoming) {
                        currentDelay = 670; // 호밍만
                    }

                    // Regular bullets from sidekicks - always fire regardless of bouncing effect
                    if (Date.now() - sidekick.lastShot > currentDelay) {
                        if (isMultiShot) {
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 6, sidekick.y - 5, isHoming, isPierce));
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, isHoming, isPierce));
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 + 2, sidekick.y - 5, isHoming, isPierce));
                        } else {
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, isHoming, isPierce));
                        }
                        sidekick.lastShot = Date.now();
                    }

                    // Bouncing bullets from sidekicks - additional shots when bouncing effect is active
                    if (isBouncing && Date.now() - sidekick.lastBouncingShot > 1200) {
                        bouncingBullets.push(new BouncingBullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5));
                        sidekick.lastBouncingShot = Date.now();
                    }
                } else {
                    // 아이템이 없는 사이드킥은 기본 총알 발사
                    if (Date.now() - sidekick.lastShot > 200) {
                        sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, false, false));
                        sidekick.lastShot = Date.now();
                    }
                }
            });
            
            // Update sidekicks
            sidekicks.forEach(sidekick => {
                sidekick.update(player.x, player.y);
            });
            
            if (keys.z && specialGauge >= maxGauge && !specialAttackActive) {
                activateSpecialAttack();
            }
            
            bullets.forEach((bullet, bulletIndex) => {
                bullet.update();
                if (bullet.y < 0) {
                    bullets.splice(bulletIndex, 1);
                }
            });
            
            sidekickBullets.forEach((bullet, bulletIndex) => {
                bullet.update();
                if (bullet.y < 0) {
                    sidekickBullets.splice(bulletIndex, 1);
                }
            });

            bouncingBullets.forEach((bullet, bulletIndex) => {
                const shouldRemove = bullet.update();
                if (shouldRemove) {
                    bouncingBullets.splice(bulletIndex, 1);
                }
            });

            enemies.forEach((enemy, enemyIndex) => {
                const shouldRemove = enemy.update();
                if ((enemy.y > canvas.height && !enemy.isBoss && !enemy.isBossBullet) ||
                    (enemy.isUAPBullet && shouldRemove)) { // UAP 총알은 update에서 반환되는 값으로 제거 결정
                    enemies.splice(enemyIndex, 1);
                }
                
                if (player.collidesWith(enemy)) {
                    if (enemy.isBossBullet || enemy.isUAPBullet) {
                        // 보스 탄환 또는 UAP 탄환과 충돌 - 플레이어 죽음
                        enemies.splice(enemyIndex, 1);
                        gameOver();
                    } else if (enemy.isUAP) {
                        // UAP 적 자체와 충돌 - 플레이어는 죽지 않음 (UAP는 총알로만 위험함)
                        // UAP는 제거되지도 않음
                    } else {
                        // 일반 적 또는 보스와 충돌 - 플레이어 죽음
                        gameOver();
                    }
                }
                
                // Check sidekick collisions
                sidekicks.forEach((sidekick, sidekickIndex) => {
                    if (sidekick.collidesWith(enemy)) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        sidekicks.splice(sidekickIndex, 1);

                        if (enemy.isBoss) {
                            // 보스는 사이드킥 충돌로 데미지만 입음 (즉시 죽지 않음)
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else {
                            // 일반 적은 즉시 제거
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // 보스가 없을 때만 점수 증가
                                score += 5;
                                updateScore();
                            }
                        }
                    }
                });
                
                bullets.forEach((bullet, bulletIndex) => {
                    if (bullet.collidesWith(enemy) && !bullet.hitEnemies.includes(enemy) &&
                        !enemy.isBossBullet && !enemy.isUAPBullet) { // 총알류는 플레이어 총알과 충돌하지 않음
                        if (enemy.isBoss) {
                            // 보스는 HP 시스템 사용
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }

                            if (enemy.takeDamage(2)) { // 플레이어 총알 2배 데미지
                                // 보스 처치됨
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else if (enemy.isElite) {
                            // 강화 적은 HP 시스템 사용
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }

                            if (enemy.takeDamage(2)) { // 플레이어 총알 2배 데미지
                                // 강화 적 처치됨
                                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                enemies.splice(enemyIndex, 1);
                                if (!bossActive) { // 보스가 없을 때만 점수 증가
                                    score += 50; // 강화 적 보너스
                                    updateScore();
                                }
                                specialGauge = Math.min(specialGauge + 10, maxGauge);
                                updateGauge();
                            }
                        } else {
                            // 일반 적
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // 보스가 없을 때만 점수 증가
                                score += 10;
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 5, maxGauge);
                            updateGauge();
                        }
                    }
                });
                
                sidekickBullets.forEach((bullet, bulletIndex) => {
                    if (bullet.collidesWith(enemy) && !enemy.isBossBullet && !enemy.isUAPBullet) { // 총알류는 사이드킥 총알과도 충돌하지 않음
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        sidekickBullets.splice(bulletIndex, 1);

                        if (enemy.isBoss) {
                            // 보스는 사이드킥 총알에도 데미지만 입음
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else if (enemy.isElite) {
                            // 강화 적도 HP 시스템 사용
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                if (!bossActive) { // 보스가 없을 때만 점수 증가
                                    score += 50;
                                    updateScore();
                                }
                                specialGauge = Math.min(specialGauge + 10, maxGauge);
                                updateGauge();
                            }
                        } else {
                            // 일반 적은 즉시 제거
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // 보스가 없을 때만 점수 증가
                                score += 10;
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 3, maxGauge);
                            updateGauge();
                        }
                    }
                });

                bouncingBullets.forEach((bullet, bulletIndex) => {
                    if (bullet.collidesWith(enemy) && !bullet.hitEnemies.includes(enemy) && !enemy.isBossBullet && !enemy.isUAPBullet) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);

                        // Bouncing bullets can hit enemies multiple times like pierce bullets
                        bullet.hitEnemies.push(enemy);

                        if (enemy.isBoss) {
                            // 보스는 바운싱 총알에도 데미지 입음
                            if (enemy.takeDamage(2)) { // 바운싱 총알은 플레이어 총알과 같은 데미지
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else if (enemy.isElite) {
                            // 강화 적은 HP 시스템 사용
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                score += 50; // 강화 적 보너스
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 10, maxGauge);
                            updateGauge();
                        } else {
                            // 일반 적은 즉시 제거
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // 보스가 없을 때만 점수 증가
                                score += 10;
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 3, maxGauge);
                            updateGauge();
                        }
                    }
                });
            });

            clouds.forEach(particle => particle.update());

            items.forEach((item, itemIndex) => {
                item.update();
                if (item.y > canvas.height) {
                    items.splice(itemIndex, 1);
                }
                
                if (player.collidesWith(item)) {
                    collectItem(item);
                    items.splice(itemIndex, 1);
                }
            });
            
            updateItemEffects();
            updateDifficulty();
            
            explosions.forEach((explosion, index) => {
                explosion.update();
                if (explosion.isDead()) {
                    explosions.splice(index, 1);
                }
            });
            
            if (specialAttackActive) {
                specialAttackTimer++;
                if (specialAttackTimer > 60) {
                    specialAttackActive = false;
                    specialAttackTimer = 0;
                }
            }

            // 화염 웨이브 업데이트
            if (flameWaveActive) {
                updateFlameWave();
            }
            
            // 스테이지별 적 스폰 속도 증가 (더 빠르게)
            const baseSpawnRate = 60; // 기본 스폰 간격 (120에서 60으로 반으로 줄임)
            const currentSpawnRate = Math.max(15, baseSpawnRate - (difficultyLevel * 8)); // 스테이지마다 8프레임씩 빨라짐

            // 적 스폰 카운터
            enemySpawnTimer++;
            if (enemySpawnTimer % currentSpawnRate === 0) {
                // 스테이지별 적 개수 증가 (1-3개)
                const enemyCount = Math.min(3, Math.floor(difficultyLevel / 2) + 1);
                for (let i = 0; i < enemyCount; i++) {
                    const x = Math.random() * (canvas.width - 30);
                    enemies.push(new Enemy(x, -35));
                }
                enemySpawnTimer = 0;
            }

            // UAP 랜덤 스폰 (0.2% 확률)
            if (Math.random() < 0.002 && gameRunning && !gamePaused) {
                enemies.push(new UAPEnemy());
            }

            itemSpawnTimer++;
            // 난이도가 높을수록 아이템 스폰 빈도 증가
            const itemSpawnDelay = Math.max(150, 350 - (difficultyLevel * 15));
            if (itemSpawnTimer > itemSpawnDelay + Math.random() * 150) {
                spawnItem();
                itemSpawnTimer = 0;
            }
        }
        
        function draw() {
            // 미래도시 침공 배경
            drawCityBackground();

            // 건물들과 구름 효과 그리기
            clouds.forEach(particle => particle.draw());

            player.draw();
            bullets.forEach(bullet => bullet.draw());
            sidekickBullets.forEach(bullet => bullet.draw());
            bouncingBullets.forEach(bullet => bullet.draw());
            enemies.forEach(enemy => enemy.draw());
            items.forEach(item => item.draw());
            sidekicks.forEach(sidekick => sidekick.draw());
            explosions.forEach(explosion => explosion.draw());

            if (specialAttackActive) {
                drawSpecialAttackEffect();
            }
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // 게임 시작 시 1단계 설정 초기화
        function initializeGame() {
            difficultyLevel = 1;
            currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (1 * 3));
            currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + 1 * 0.03));
            currentShotDelay = Math.max(30, baseShotDelay - (1 * 3));
            enemySpeedMultiplier = Math.min(2.0, 1.0 + (1 * 0.05));
            updateEquippedItemsDisplay();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `점수: ${score}`;
            // Update overlay score as well
            document.getElementById('overlayScore').textContent = `점수: ${score}`;
        }

        function drawCityBackground() {
            // 푸른 바다 배경 (좌측)과 육지 (우측)
            const seaGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            seaGradient.addColorStop(0, '#1e3a5f');     // 깊은 바다색
            seaGradient.addColorStop(0.4, '#2d4a6e');   // 중간 바다색
            seaGradient.addColorStop(0.6, '#3a5a7d');   // 연한 바다색
            seaGradient.addColorStop(1, '#4a6a8d');     // 해안 근처

            ctx.fillStyle = seaGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 육지 (해안선과 섬들)
            drawLandMasses();

            // 전쟁터 배경
            drawBattlefield();

            // 군사 시설 - removed

            // 정적 해안선 효과
            drawWaterEffects();
        }

        function drawLandMasses() {
            ctx.save();

            // 좌측은 푸른 바다 (배경 그라디언트로 이미 처리됨)

            // 우측 해안선 (육지)
            ctx.fillStyle = '#6a5a4a'; // 갈색 육지

            // 우측 해안선 (곡선으로 자연스럽게)
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.65, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(canvas.width * 0.6, canvas.height);
            ctx.quadraticCurveTo(canvas.width * 0.62, canvas.height * 0.8, canvas.width * 0.64, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.66, canvas.height * 0.4, canvas.width * 0.63, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.65, canvas.height * 0.1, canvas.width * 0.65, 0);
            ctx.fill();

            // 해변 (밝은 모래색)
            ctx.fillStyle = '#d4c4a4';
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.65, 0);
            ctx.quadraticCurveTo(canvas.width * 0.62, canvas.height * 0.1, canvas.width * 0.6, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.63, canvas.height * 0.4, canvas.width * 0.61, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.59, canvas.height * 0.8, canvas.width * 0.6, canvas.height);
            ctx.lineTo(canvas.width * 0.62, canvas.height);
            ctx.quadraticCurveTo(canvas.width * 0.64, canvas.height * 0.8, canvas.width * 0.66, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.68, canvas.height * 0.4, canvas.width * 0.65, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.67, canvas.height * 0.1, canvas.width * 0.65, 0);
            ctx.fill();

            ctx.restore();
        }

        function drawBattlefield() {
            ctx.save();

            // 전쟁터 배경 (우측 육지)

            // 파괴된 건물들과 폐허
            const ruins = [
                // 파괴된 고층 건물들 (불규칙한 모양으로 파괴됨)
                {x: canvas.width * 0.68, y: canvas.height * 0.1, w: 25, h: 80, color: '#3a3a3a', destroyed: true},
                {x: canvas.width * 0.72, y: canvas.height * 0.25, w: 20, h: 60, color: '#4a4a4a', destroyed: true},
                {x: canvas.width * 0.75, y: canvas.height * 0.08, w: 30, h: 90, color: '#2a2a2a', destroyed: true},
                {x: canvas.width * 0.80, y: canvas.height * 0.22, w: 22, h: 70, color: '#5a5a5a', destroyed: true},
                {x: canvas.width * 0.84, y: canvas.height * 0.18, w: 18, h: 50, color: '#3a3a3a', destroyed: true},
                {x: canvas.width * 0.88, y: canvas.height * 0.24, w: 28, h: 65, color: '#4a4a4a', destroyed: true},

                // 중간 크기 파괴된 건물들
                {x: canvas.width * 0.70, y: canvas.height * 0.45, w: 15, h: 30, color: '#4a4a4a', destroyed: true},
                {x: canvas.width * 0.74, y: canvas.height * 0.48, w: 18, h: 25, color: '#3a3a3a', destroyed: true},
                {x: canvas.width * 0.77, y: canvas.height * 0.42, w: 20, h: 35, color: '#5a5a5a', destroyed: true},
                {x: canvas.width * 0.82, y: canvas.height * 0.50, w: 16, h: 20, color: '#2a2a2a', destroyed: true},
                {x: canvas.width * 0.86, y: canvas.height * 0.46, w: 22, h: 30, color: '#4a4a4a', destroyed: true},

                // 작은 파괴된 구조물들
                {x: canvas.width * 0.69, y: canvas.height * 0.65, w: 12, h: 15, color: '#5a5a5a', destroyed: true},
                {x: canvas.width * 0.73, y: canvas.height * 0.68, w: 14, h: 12, color: '#3a3a3a', destroyed: true},
                {x: canvas.width * 0.76, y: canvas.height * 0.62, w: 16, h: 18, color: '#4a4a4a', destroyed: true},
                {x: canvas.width * 0.81, y: canvas.height * 0.70, w: 13, h: 10, color: '#2a2a2a', destroyed: true}
            ];

            // 파괴된 건물들 그리기
            ruins.forEach(ruin => {
                // 건물 본체 (더 어둡고 손상된 색상)
                ctx.fillStyle = ruin.color;

                if (ruin.destroyed) {
                    // 불규칙한 파괴된 모양 만들기
                    ctx.beginPath();
                    ctx.moveTo(ruin.x, ruin.y + ruin.h);
                    ctx.lineTo(ruin.x, ruin.y + ruin.h * 0.3);
                    ctx.lineTo(ruin.x + ruin.w * 0.3, ruin.y + ruin.h * 0.2);
                    ctx.lineTo(ruin.x + ruin.w * 0.7, ruin.y);
                    ctx.lineTo(ruin.x + ruin.w, ruin.y + ruin.h * 0.4);
                    ctx.lineTo(ruin.x + ruin.w, ruin.y + ruin.h);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.fillRect(ruin.x, ruin.y, ruin.w, ruin.h);
                }

                // 파괴된 창문들 (불타는 오렌지/빨간 불빛)
                if (Math.random() > 0.5) { // 일부 건물만 불타고 있음
                    ctx.fillStyle = '#ff4400';
                    for (let i = 0; i < 3; i++) {
                        const fireX = ruin.x + Math.random() * ruin.w * 0.8;
                        const fireY = ruin.y + Math.random() * ruin.h * 0.8;
                        ctx.fillRect(fireX, fireY, 2, 3);
                    }
                }
            });

            // 폭탄 구덩이들 (크레이터)
            ctx.fillStyle = '#1a1a1a';
            const craters = [
                {x: canvas.width * 0.71, y: canvas.height * 0.35, size: 8},
                {x: canvas.width * 0.79, y: canvas.height * 0.55, size: 12},
                {x: canvas.width * 0.85, y: canvas.height * 0.65, size: 6},
                {x: canvas.width * 0.73, y: canvas.height * 0.72, size: 10},
                {x: canvas.width * 0.87, y: canvas.height * 0.38, size: 7}
            ];

            craters.forEach(crater => {
                ctx.beginPath();
                ctx.arc(crater.x, crater.y, crater.size, 0, Math.PI * 2);
                ctx.fill();

                // 크레이터 가장자리 (약간 밝은 색)
                ctx.strokeStyle = '#3a3a3a';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Zigzag trenches removed for cleaner battlefield look

            // 연기 기둥들
            const smokeColumns = [
                {x: canvas.width * 0.74, y: canvas.height * 0.15, intensity: 0.8},
                {x: canvas.width * 0.81, y: canvas.height * 0.08, intensity: 0.6},
                {x: canvas.width * 0.89, y: canvas.height * 0.20, intensity: 0.9},
                {x: canvas.width * 0.70, y: canvas.height * 0.45, intensity: 0.5}
            ];

            smokeColumns.forEach(smoke => {
                const smokeAlpha = smoke.intensity * 0.4;
                ctx.fillStyle = `rgba(60, 60, 60, ${smokeAlpha})`;

                // 연기 기둥을 여러 개의 원으로 그리기
                for (let i = 0; i < 8; i++) {
                    const offsetX = Math.sin(i * 0.5) * 3;
                    const smokeY = smoke.y - i * 8;
                    const smokeSize = 4 + i * 0.8;

                    ctx.beginPath();
                    ctx.arc(smoke.x + offsetX, smokeY, smokeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // 불타는 잔해들
            const burningDebris = [
                {x: canvas.width * 0.69, y: canvas.height * 0.75, size: 4},
                {x: canvas.width * 0.77, y: canvas.height * 0.73, size: 3},
                {x: canvas.width * 0.83, y: canvas.height * 0.77, size: 5},
                {x: canvas.width * 0.91, y: canvas.height * 0.74, size: 3}
            ];

            burningDebris.forEach(debris => {
                // 불타는 잔해 (오렌지-빨강 그라디언트)
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(debris.x, debris.y, debris.size, 0, Math.PI * 2);
                ctx.fill();

                // 불꽃 효과
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(debris.x, debris.y - 2, debris.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // Military base function removed

        function drawWaterEffects() {
            ctx.save();

            // 정적인 물결 효과 (움직이지 않음)
            ctx.strokeStyle = 'rgba(150, 200, 180, 0.3)';
            ctx.lineWidth = 1;

            // 해안선 정적 물결
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                const waveY = canvas.height * 0.2 + i * 80;
                ctx.moveTo(0, waveY);

                for (let x = 0; x < canvas.width * 0.6; x += 20) {
                    const y = waveY + Math.sin(x * 0.1) * 3; // Date.now() 제거
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            ctx.restore();
        }
        
        function updateGauge() {
            const percentage = (specialGauge / maxGauge) * 100;
            document.getElementById('gaugeFill').style.width = percentage + '%';
            document.getElementById('gaugeText').textContent = `필살기 게이지: ${Math.floor(percentage)}%`;
            // Update overlay gauge as well
            document.getElementById('overlayGaugeFill').style.width = percentage + '%';
            document.getElementById('overlayGaugeText').textContent = `필살기 게이지: ${Math.floor(percentage)}%`;

            // 모바일 필살기 버튼 상태 업데이트
            updateSpecialAttackButton();
        }
        
        function activateSpecialAttack() {
            specialAttackActive = true;
            specialGauge = 0;
            updateGauge();

            // 화염 웨이브 시작
            startFlameWave();

            // 보스를 제외한 적들에게만 특수 공격 적용
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);

                if (enemy.isBoss) {
                    // 보스는 특수 공격으로 큰 데미지 (HP의 20%)
                    const damage = Math.max(1, Math.floor(enemy.maxHp * 0.2));
                    for (let d = 0; d < damage; d++) {
                        if (enemy.takeDamage()) {
                            enemies.splice(i, 1);
                            break;
                        }
                    }
                    if (!bossActive) { // 보스가 없을 때만 점수 증가
                        score += 200; // 보스에게 데미지를 준 보너스
                    }
                } else {
                    // 일반 적은 즉시 제거
                    enemies.splice(i, 1);
                    if (!bossActive) { // 보스가 없을 때만 점수 증가
                        score += 50;
                    }
                }
            }
            updateScore();
        }
        
        function createExplosion(x, y) {
            explosions.push(new Explosion(x, y));
        }
        
        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pauseScreen').style.display = gamePaused ? 'block' : 'none';
        }
        
        function handlePauseKey() {
            if (!pKeyPressed) {
                pKeyPressed = true;
                togglePause();
            }
        }
        
        function spawnItem() {
            const x = Math.random() * (canvas.width - 20);
            items.push(new Item(x, -20));
        }
        
        function collectItem(item) {
            if (playerItems.length < maxItems) {
                // 빈 슬롯이 있으면 추가
                playerItems.push({
                    type: item.type,
                    symbol: item.symbols[item.type],
                    color: item.colors[item.type]
                });
            } else {
                // 슬롯이 가득 찬 경우 첫 번째 아이템 제거하고 새 아이템 추가
                const oldItem = playerItems.shift(); // 첫 번째 아이템 제거
                deactivateItemEffect(oldItem.type);

                playerItems.push({
                    type: item.type,
                    symbol: item.symbols[item.type],
                    color: item.colors[item.type]
                });
            }

            updateInventoryUI();
            updateEquippedItemsDisplay();
            activateItemEffect(item.type);

            // Add sidekick when collecting item
            addSidekick();
        }

        function deactivateItemEffect(type) {
            switch(type) {
                case 'multiShot':
                    multiShotActive = false;
                    break;
                case 'rapidFire':
                    rapidFireActive = false;
                    currentShotDelay = Math.max(30, baseShotDelay - (difficultyLevel * 3));
                    break;
                case 'pierce':
                    pierceActive = false;
                    break;
                case 'homing':
                    homingActive = false;
                    break;
                case 'bouncing':
                    bouncingActive = false;
                    break;
            }
        }
        
        function addSidekick() {
            if (sidekicks.length < maxSidekicks) {
                const hasLeft = sidekicks.some(s => s.side === 'left');
                const hasRight = sidekicks.some(s => s.side === 'right');
                
                if (!hasLeft) {
                    sidekicks.push(new Sidekick('left'));
                } else if (!hasRight) {
                    sidekicks.push(new Sidekick('right'));
                }
            }
        }
        
        function activateItemEffect(type) {
            switch(type) {
                case 'multiShot':
                    multiShotActive = true;
                    itemEffectTimers.multiShot = 10000;
                    break;
                case 'rapidFire':
                    rapidFireActive = true;
                    itemEffectTimers.rapidFire = 10000;
                    // 연사 아이템 활성시 쇇 속도 재계산
                    currentShotDelay = Math.max(15, baseShotDelay - (difficultyLevel * 3)) / 3;
                    break;
                case 'pierce':
                    pierceActive = true;
                    itemEffectTimers.pierce = 10000;
                    break;
                case 'homing':
                    homingActive = true;
                    itemEffectTimers.homing = 10000;
                    break;
                case 'bouncing':
                    bouncingActive = true;
                    itemEffectTimers.bouncing = 10000;
                    break;
            }
        }
        
        function updateItemEffects() {
            // 아이템 효과를 영구적으로 유지 (다른 아이템을 먹기 전까지)
            // 시간 기반 비활성화 제거
        }
        
        function removeItemFromInventory(type) {
            playerItems = playerItems.filter(item => item.type !== type);
            updateInventoryUI();
            updateEquippedItemsDisplay();
        }
        
        function updateInventoryUI() {
            for (let i = 0; i < maxItems; i++) {
                const slot = document.getElementById(`slot${i}`);
                const overlaySlot = document.getElementById(`overlaySlot${i}`);
                if (i < playerItems.length) {
                    if (slot) {
                        slot.textContent = playerItems[i].symbol;
                        slot.style.color = playerItems[i].color;
                        slot.classList.add('filled');
                    }
                    // Update overlay slot as well (with null check)
                    if (overlaySlot) {
                        overlaySlot.textContent = playerItems[i].symbol;
                        overlaySlot.style.color = playerItems[i].color;
                        overlaySlot.classList.add('filled');
                    }
                } else {
                    if (slot) {
                        slot.textContent = '';
                        slot.classList.remove('filled');
                    }
                    // Update overlay slot as well (with null check)
                    if (overlaySlot) {
                        overlaySlot.textContent = '';
                        overlaySlot.classList.remove('filled');
                    }
                }
            }
        }

        function updateEquippedItemsDisplay() {
            const itemDescriptions = {
                multiShot: '다중 발사',
                rapidFire: '연사 강화',
                pierce: '관통 탄환',
                homing: '유도 미사일',
                bouncing: '바운싱 탄환'
            };

            const equippedItemsList = document.getElementById('equippedItemsList');
            equippedItemsList.innerHTML = '';

            if (playerItems.length === 0) {
                const noItemsDiv = document.createElement('div');
                noItemsDiv.style.color = '#888888';
                noItemsDiv.style.textAlign = 'center';
                noItemsDiv.style.fontStyle = 'italic';
                noItemsDiv.textContent = '아이템 없음';
                equippedItemsList.appendChild(noItemsDiv);
                return;
            }

            playerItems.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'equipped-item';

                const symbolDiv = document.createElement('div');
                symbolDiv.className = 'equipped-item-symbol';
                symbolDiv.textContent = item.symbol;
                symbolDiv.style.backgroundColor = item.color;
                symbolDiv.style.color = '#ffffff';

                const descDiv = document.createElement('div');
                descDiv.className = 'equipped-item-desc';
                descDiv.textContent = itemDescriptions[item.type] || item.type;

                itemDiv.appendChild(symbolDiv);
                itemDiv.appendChild(descDiv);
                equippedItemsList.appendChild(itemDiv);
            });
        }

        function startFlameWave() {
            flameWaveActive = true;
            flameWaveHeight = 0;
            flameWave = [];

            // 화염 파티클 생성
            for (let i = 0; i < 100; i++) {
                flameWave.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + Math.random() * 50,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -8 - Math.random() * 12,
                    size: 3 + Math.random() * 8,
                    life: 1.0,
                    color: Math.random() < 0.7 ? 'orange' : 'red'
                });
            }
        }

        function updateFlameWave() {
            if (!flameWaveActive) return;

            flameWaveHeight += 15;

            // 파티클 업데이트
            flameWave.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                particle.size *= 0.98;

                // 바람 효과
                particle.vx += (Math.random() - 0.5) * 0.5;
            });

            // 죽은 파티클 제거
            flameWave = flameWave.filter(particle => particle.life > 0 && particle.size > 0.5);

            // 새로운 파티클 추가
            if (flameWaveHeight < canvas.height + 100) {
                for (let i = 0; i < 5; i++) {
                    flameWave.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height - flameWaveHeight + Math.random() * 30,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -5 - Math.random() * 15,
                        size: 4 + Math.random() * 10,
                        life: 1.0,
                        color: Math.random() < 0.6 ? 'orange' : Math.random() < 0.8 ? 'red' : 'yellow'
                    });
                }
            }

            // 효과 종료 체크
            if (flameWaveHeight > canvas.height + 150 && flameWave.length === 0) {
                flameWaveActive = false;
            }
        }

        function drawFlameWave() {
            if (!flameWaveActive) return;

            // 화염 베이스 그라디언트
            const flameGradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - flameWaveHeight);
            flameGradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
            flameGradient.addColorStop(0.3, 'rgba(255, 150, 0, 0.6)');
            flameGradient.addColorStop(0.7, 'rgba(255, 200, 0, 0.3)');
            flameGradient.addColorStop(1, 'transparent');

            ctx.fillStyle = flameGradient;
            ctx.fillRect(0, canvas.height - flameWaveHeight, canvas.width, flameWaveHeight);

            // 파티클 그리기
            flameWave.forEach(particle => {
                if (particle.life > 0) {
                    ctx.globalAlpha = particle.life;

                    const colors = {
                        orange: `hsl(${30 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`,
                        red: `hsl(${0 + Math.random() * 20}, 100%, ${50 + Math.random() * 30}%)`,
                        yellow: `hsl(${50 + Math.random() * 20}, 100%, ${60 + Math.random() * 30}%)`
                    };

                    ctx.fillStyle = colors[particle.color];
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, 2 * Math.PI);
                    ctx.fill();

                    // 글로우 효과
                    ctx.shadowColor = colors[particle.color];
                    ctx.shadowBlur = particle.size * 2;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            ctx.globalAlpha = 1.0;

            // 필살기 텍스트
            ctx.fillStyle = 'white';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 10;
            ctx.fillText('화염 폭풍!', canvas.width / 2, 100);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'left';
        }

        function drawSpecialAttackEffect() {
            // 기존 번쩍임 제거, 화염 웨이브로 대체
            drawFlameWave();
        }
        
        function gameOver() {
            gameRunning = false;
            showRankingInput();
        }
        
        function restartGame() {
            gameRunning = true;
            gamePaused = false;
            score = 0;
            difficultyLevel = 1;
            currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (1 * 3));
            currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + 1 * 0.03));
            currentShotDelay = Math.max(30, baseShotDelay - (1 * 3));
            enemySpeedMultiplier = Math.min(2.0, 1.0 + (1 * 0.05));
            specialGauge = 0;
            specialAttackActive = false;
            specialAttackTimer = 0;
            playerItems = [];
            multiShotActive = false;
            rapidFireActive = false;
            pierceActive = false;
            homingActive = false;
            bouncingActive = false;
            itemEffectTimers = {
                multiShot: 0,
                rapidFire: 0,
                pierce: 0,
                homing: 0,
                bouncing: 0
            };
            bullets.length = 0;
            sidekickBullets.length = 0;
            bouncingBullets.length = 0;
            enemies.length = 0;
            items.length = 0;
            sidekicks.length = 0;
            explosions.length = 0;
            itemSpawnTimer = 0;
            lastShot = 0;
            lastBouncingShot = 0;
            lastSidekickShot = 0;
            bossActive = false;
            currentBoss = null;
            player.x = canvas.width / 2 - 20;
            player.y = canvas.height - 60;
            updateScore();
            updateGauge();
            updateInventoryUI();
            updateEquippedItemsDisplay();
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
        }
        
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = true;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    keys.right = true;
                    e.preventDefault();
                    break;
                case 'ArrowUp':
                    keys.up = true;
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    keys.down = true;
                    e.preventDefault();
                    break;
                case 'Space':
                    keys.space = true;
                    e.preventDefault();
                    break;
                case 'KeyZ':
                    keys.z = true;
                    e.preventDefault();
                    break;
                case 'KeyP':
                    handlePauseKey();
                    e.preventDefault();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'ArrowUp':
                    keys.up = false;
                    break;
                case 'ArrowDown':
                    keys.down = false;
                    break;
                case 'Space':
                    keys.space = false;
                    break;
                case 'KeyZ':
                    keys.z = false;
                    break;
                case 'KeyP':
                    pKeyPressed = false;
                    break;
            }
        });

        // 모바일 터치 이벤트 핸들러들
        function initMobileControls() {
            const canvas = document.getElementById('gameCanvas');
            const specialAttackBtn = document.getElementById('specialAttackBtn');

            // 캔버스 터치 이벤트 - 이동 및 발사
            let touchActive = false;
            let lastTouchX = 0;
            let lastTouchY = 0;

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();

                touchActive = true;
                lastTouchX = touch.clientX - rect.left;
                lastTouchY = touch.clientY - rect.top;

                // 자동 발사 시작
                keys.space = true;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!touchActive || !gameRunning) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();

                const currentTouchX = touch.clientX - rect.left;
                const currentTouchY = touch.clientY - rect.top;

                // 터치 위치를 게임 좌표로 변환
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                const gameX = currentTouchX * scaleX;
                const gameY = currentTouchY * scaleY;

                // 플레이어를 터치 위치로 이동 (경계 체크 포함)
                if (player) {
                    const targetX = gameX - player.width / 2;
                    const targetY = gameY - player.height / 2;

                    // 경계 체크
                    player.x = Math.max(0, Math.min(canvas.width - player.width, targetX));
                    player.y = Math.max(0, Math.min(canvas.height - player.height, targetY));
                }

                lastTouchX = currentTouchX;
                lastTouchY = currentTouchY;
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchActive = false;

                // 발사 중지
                keys.space = false;

                // 모든 방향키 해제
                keys.left = false;
                keys.right = false;
                keys.up = false;
                keys.down = false;
            });

            // 필살기 버튼 이벤트
            specialAttackBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (specialGauge >= 100) {
                    keys.z = true;
                    touchControls.specialAttack = true;
                    specialAttackBtn.classList.add('btn-pressed');
                }
            });

            specialAttackBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.z = false;
                touchControls.specialAttack = false;
                specialAttackBtn.classList.remove('btn-pressed');
            });
        }

        // 필살기 게이지에 따른 버튼 상태 업데이트
        function updateSpecialAttackButton() {
            const specialAttackBtn = document.getElementById('specialAttackBtn');
            if (specialAttackBtn) {
                if (specialGauge >= 100) {
                    specialAttackBtn.classList.add('show');
                } else {
                    specialAttackBtn.classList.remove('show');
                }
            }
        }

        // 모바일 컨트롤 초기화
        if (isMobile) {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initMobileControls);
            } else {
                initMobileControls();
            }
        }

        // 랭킹 시스템 함수들
        function loadRankings() {
            // 글로벌 명예의 전당 - 실제 플레이어 기록만 표시
            const globalRankings = [];

            const saved = localStorage.getItem('galaxyShooterRankings');
            let localRankings = [];
            if (saved) {
                localRankings = JSON.parse(saved);
            }

            // 글로벌 랭킹과 로컬 랭킹을 합치고 정렬
            rankings = [...globalRankings, ...localRankings];
            rankings.sort((a, b) => b.score - a.score);
            rankings = rankings.slice(0, maxRankings);

            updateLiveRankings(); // 랭킹 로드 후 표시 업데이트
        }

        function updateLiveRankings() {
            const rankingContainer = document.getElementById('liveRankingList');
            if (!rankingContainer) return;

            rankingContainer.innerHTML = '';

            if (rankings.length === 0) {
                rankingContainer.innerHTML = `
                    <div class="ranking-item">
                        <span class="ranking-rank">1</span>
                        <div>
                            <div class="ranking-score">기록 없음</div>
                            <div class="ranking-date">게임을 시작해보세요!</div>
                        </div>
                    </div>
                `;
                // Update last updated date even when no rankings
                updateLastUpdatedDate();
                return;
            }

            rankings.slice(0, 5).forEach((ranking, index) => {
                const medalIcons = ['🥇', '🥈', '🥉'];
                const medal = index < 3 ? medalIcons[index] : `${index + 1}`;

                rankingContainer.innerHTML += `
                    <div class="ranking-item">
                        <span class="ranking-rank">${medal}</span>
                        <div>
                            <div class="ranking-score">${ranking.score.toLocaleString()}점</div>
                            <div class="ranking-date">${ranking.name} | Stage ${ranking.stage}</div>
                        </div>
                    </div>
                `;
            });

            // Update the last updated date
            updateLastUpdatedDate();
        }

        function updateLastUpdatedDate() {
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const now = new Date();
                const koreanDate = now.toLocaleDateString('ko-KR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                lastUpdatedElement.textContent = `마지막 업데이트: ${koreanDate}`;
            }
        }

        function saveRankings() {
            localStorage.setItem('galaxyShooterRankings', JSON.stringify(rankings));
        }

        function addRanking(name, score, stage) {
            const newRecord = {
                name: name || '무명',
                score: score,
                stage: stage,
                date: new Date().toLocaleDateString('ko-KR')
            };

            rankings.push(newRecord);
            rankings.sort((a, b) => b.score - a.score);
            rankings = rankings.slice(0, maxRankings);
            saveRankings();
            updateLiveRankings(); // 실시간 랭킹 업데이트
            return newRecord;
        }

        function showRankingInput() {
            document.getElementById('finalScore').textContent = `최종 점수: ${score}점 (${difficultyLevel}단계)`;
            document.getElementById('rankingModal').style.display = 'block';
            document.getElementById('nameInput').focus();
            displayRankings(null);
        }

        function saveScore() {
            const name = document.getElementById('nameInput').value.trim();
            const newRecord = addRanking(name, score, difficultyLevel);
            document.getElementById('nameInputSection').style.display = 'none';
            displayRankings(newRecord);
        }

        function displayRankings(newRecord) {
            // 우측 패널도 업데이트
            updateLiveRankings();

            const rankingList = document.getElementById('rankingList');
            rankingList.innerHTML = '<h3 style="color: #00ffff; text-align: center; margin-bottom: 15px;">🏅 명예의 전당 🏅</h3>';

            if (rankings.length === 0) {
                rankingList.innerHTML += '<div style="text-align: center; color: #999;">아직 기록이 없습니다.</div>';
                return;
            }

            rankings.forEach((ranking, index) => {
                const isNew = newRecord && ranking === newRecord;
                const rankElement = document.createElement('div');
                rankElement.className = `rankingItem ${isNew ? 'newRecord' : ''}`;

                const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;

                rankElement.innerHTML = `
                    <div>
                        <span style="display: inline-block; width: 30px;">${medal}</span>
                        <strong>${ranking.name}</strong>
                        <span style="margin-left: 10px; color: #aaa; font-size: 12px;">${ranking.date}</span>
                    </div>
                    <div>
                        <span style="color: #ffd700;">${ranking.score}점</span>
                        <span style="margin-left: 10px; color: #00ffff;">${ranking.stage}단계</span>
                    </div>
                `;

                rankingList.appendChild(rankElement);
            });

            // 새로운 기록이 추가된 경우 축하 메시지와 다시 시작 버튼 표시
            if (newRecord) {
                const congratsElement = document.createElement('div');
                congratsElement.style.cssText = 'text-align: center; margin-top: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 8px; border: 1px solid #00ffff;';
                congratsElement.innerHTML = `
                    <div style="color: #00ffff; font-size: 18px; margin-bottom: 10px;">🎉 기록이 저장되었습니다! 🎉</div>
                    <button onclick="restartGameFromModal()" style="
                        font-size: 18px;
                        padding: 12px 24px;
                        background: #00ffff;
                        color: #000;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: bold;
                        margin: 5px;
                    ">🚀 다시 시작</button>
                    <button onclick="closeRanking()" style="
                        font-size: 16px;
                        padding: 10px 20px;
                        background: #666;
                        color: #fff;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        margin: 5px;
                    ">닫기</button>
                `;
                rankingList.appendChild(congratsElement);
            }
        }

        function closeRanking() {
            document.getElementById('rankingModal').style.display = 'none';
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGameFromModal() {
            // 모달 닫기
            document.getElementById('rankingModal').style.display = 'none';
            // 게임 오버 화면 숨기기
            document.getElementById('gameOver').style.display = 'none';
            // 이름 입력 섹션 다시 보이기 (다음 게임을 위해)
            document.getElementById('nameInputSection').style.display = 'block';
            document.getElementById('nameInput').value = '';
            // 게임 재시작
            restartGame();
        }

        // Enter 키로 이름 저장
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('nameInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    saveScore();
                }
            });
        });

        console.log("Starting game...");
        try {
            loadRankings();
            console.log("Rankings loaded");
            initializeGame();
            console.log("Game initialized");
            gameLoop();
            console.log("Game loop started");
        } catch (error) {
            console.error("Game initialization error:", error);
        }
    </script>
</body>
</html>