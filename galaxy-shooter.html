<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê°¤ëŸ­ì‹œ ë¹„í–‰ê¸° ê²Œì„</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            gap: 30px;
        }

        #rightPanel {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        #gameContainer {
            text-align: center;
            position: relative;
        }

        #gameCanvasWrapper {
            position: relative;
            display: inline-block;
        }

        #overlayUI {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #topOverlay {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #bottomOverlay {
            display: block;
        }

        /* Ensure overlay UI doesn't interfere during special effects */
        #overlayUI.special-attack {
            opacity: 0.7;
        }

        #leftOverlay {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #rightOverlay {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .overlay-panel {
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(8px);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
        }

        .overlay-panel:hover {
            background: rgba(0, 0, 0, 0.85);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .score-panel {
            background: none !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            backdrop-filter: none !important;
            box-shadow: none !important;
        }

        .score-panel:hover {
            background: none !important;
            border: none !important;
        }

        #overlayScore {
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            background: none;
            padding: 0;
            border-radius: 0;
            backdrop-filter: none;
            text-align: left;
        }


        #overlayGaugeContainer {
            position: absolute;
            bottom: 0px;
            left: 0px;
            width: 100%;
            height: 8px;
            z-index: 1000;
        }

        #overlayGauge {
            width: 100%;
            height: 100%;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background: rgba(0, 0, 0, 0.7);
            border-radius: 3px;
            overflow: hidden;
            margin: 0;
        }

        #overlayGaugeFill {
            height: 100%;
            background: linear-gradient(to right, #ff4444, #ffff44, #44ff44);
            width: 0%;
            transition: width 0.2s;
            border-radius: 2px;
        }

        #overlayGaugeText {
            display: none;
        }

        /* Removed overlayInventory and overlay-item-slot CSS - top-right items display removed */

        #equippedItemsDisplay {
            position: absolute;
            bottom: 35px;
            right: 10px;
            background: rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 8px;
            min-width: 180px;
            z-index: 1001;
        }

        #equippedItemsTitle {
            color: #00ffff;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 6px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        #equippedItemsList {
            display: flex;
            flex-direction: column;
            gap: 3px;
            font-size: 11px;
        }

        .equipped-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #ffffff;
        }

        .equipped-item-symbol {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            font-weight: bold;
            font-size: 12px;
        }

        .equipped-item-desc {
            flex: 1;
            color: #cccccc;
        }

        #controlsPanel {
            width: 320px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            color: white;
            backdrop-filter: blur(5px);
            margin-top: 20px;
        }

        .item-description {
            color: #ffcc99;
            font-size: 12px;
            margin-left: 10px;
            font-style: italic;
        }

        #controlsTitle {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 12px;
            color: #00ffff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .control-item {
            padding: 6px 0;
            font-size: 14px;
            color: #cccccc;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-item:last-child {
            border-bottom: none;
        }

        .control-key {
            color: #ffd700;
            font-weight: bold;
        }

        #rankingContainer {
            width: 320px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            color: white;
            backdrop-filter: blur(10px);
        }

        #rankingTitle {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 4px solid #FFD700;
        }

        .ranking-rank {
            font-weight: bold;
            font-size: 18px;
            color: #FFD700;
            min-width: 30px;
        }

        .ranking-score {
            font-size: 16px;
            font-weight: bold;
        }

        .ranking-date {
            font-size: 12px;
            color: #aaa;
        }

        .ranking-item:nth-child(1) .ranking-rank { color: #FFD700; }
        .ranking-item:nth-child(2) .ranking-rank { color: #C0C0C0; }
        .ranking-item:nth-child(3) .ranking-rank { color: #CD7F32; }
        
        canvas {
            border: 2px solid #333;
            background: linear-gradient(to bottom, #001122, #000033);
        }
        
        #ui {
            color: white;
            margin-top: 10px;
        }
        
        #score {
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        #gaugeContainer {
            margin-bottom: 10px;
        }
        
        #gauge {
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            background: #333;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        
        #gaugeFill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
            width: 0%;
            transition: width 0.2s;
        }
        
        #gaugeText {
            color: white;
            font-size: 14px;
            margin-top: 5px;
        }
        
        #inventory {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .item-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #666;
            background: #222;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .item-slot.filled {
            border-color: #00ff00;
            background: #004400;
        }
        
        #gameOver {
            display: none;
            color: red;
            font-size: 24px;
            margin-top: 20px;
        }

        #rankingModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        #rankingContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #0f3460;
            border-radius: 10px;
            padding: 30px;
            color: white;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        #nameInput {
            background: #2a2a4e;
            border: 2px solid #0080ff;
            color: white;
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            margin: 10px;
            text-align: center;
        }

        #nameInput:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #rankingList {
            margin: 20px 0;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
        }

        .rankingItem {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border-left: 4px solid #00ffff;
        }

        .rankingItem.newRecord {
            background: rgba(255, 215, 0, 0.2);
            border-left-color: #ffd700;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }
        
        #pauseScreen {
            display: none;
            color: white;
            font-size: 24px;
            margin-top: 20px;
        }
        
        button {
            background: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
        }
        
        button:hover {
            background: #555;
        }

        /* ëª¨ë°”ì¼ ë°˜ì‘í˜• ìŠ¤íƒ€ì¼ */
        @media (max-width: 768px) {
            body {
                padding: 0;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                justify-content: flex-start;
            }

            #gameContainer {
                width: 100%;
                max-width: 100vw;
                order: -1;
                margin-top: 0;
            }

            #gameCanvasWrapper {
                width: 100%;
                height: auto;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
                max-width: 100vw;
                touch-action: none;
            }

            #rightPanel {
                width: 100%;
                padding: 10px;
            }

            .overlay-panel {
                padding: 6px 10px;
                font-size: 14px;
            }

            #overlayGaugeContainer {
                padding: 8px;
            }
        }

        /* ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            z-index: 200;
            pointer-events: none;
            display: none;
        }

        @media (max-width: 768px), (pointer: coarse) {
            #mobileControls {
                display: block;
            }
        }


        /* í•„ì‚´ê¸° ë²„íŠ¼ */
        #specialAttackBtn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 50, 50, 1);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            line-height: 74px;
            pointer-events: all;
            touch-action: none;
            opacity: 1;
            transition: all 0.3s ease;
            display: none;
            box-shadow: 0 0 20px rgba(255, 50, 50, 0.5);
            animation: pulse 1s infinite;
        }

        #specialAttackBtn.show {
            display: block;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* í„°ì¹˜ í”¼ë“œë°± */
        .btn-pressed {
            transform: scale(0.9) !important;
            opacity: 0.7 !important;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameCanvasWrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>

            <!-- Overlay UI Elements -->
            <div id="overlayUI">
                <div id="topOverlay">
                    <div id="leftOverlay">
                        <div class="overlay-panel score-panel">
                            <div id="overlayScore">ì ìˆ˜: 0</div>
                        </div>
                    </div>
                    <div id="rightOverlay">
                        <!-- Top-right items display removed as requested -->
                    </div>
                </div>
                <div id="bottomOverlay">
                    <div id="overlayGaugeContainer">
                        <div id="overlayGauge">
                            <div id="overlayGaugeFill"></div>
                        </div>
                        <div id="overlayGaugeText">í•„ì‚´ê¸° ê²Œì´ì§€: 0%</div>
                    </div>
                    <div id="equippedItemsDisplay">
                        <div id="equippedItemsTitle">ì¥ì°©ëœ ì•„ì´í…œ</div>
                        <div id="equippedItemsList"></div>
                    </div>
                </div>
            </div>

            <!-- ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ -->
            <div id="mobileControls">
                <div id="specialAttackBtn">í•„ì‚´ê¸°</div>
            </div>
        </div>

        <div id="ui">
            <!-- Keep original elements hidden but functional for backwards compatibility -->
            <div id="score" style="display: none;">ì ìˆ˜: 0</div>
            <div id="gaugeContainer" style="display: none;">
                <div id="gauge">
                    <div id="gaugeFill"></div>
                </div>
                <div id="gaugeText">í•„ì‚´ê¸° ê²Œì´ì§€: 0%</div>
            </div>
            <div id="inventory" style="display: none;">
                <div class="item-slot" id="slot0"></div>
                <div class="item-slot" id="slot1"></div>
            </div>

            <div id="pauseScreen">
                <div>ê²Œì„ ì¼ì‹œì •ì§€</div>
                <div style="font-size: 16px; margin-top: 10px;">Pí‚¤ë¥¼ ëˆŒëŸ¬ ê³„ì†</div>
            </div>
            <div id="gameOver">
                <div>ê²Œì„ ì˜¤ë²„!</div>
                <button onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
            </div>
        </div>
    </div>

    <div id="rankingModal">
        <div id="rankingContent">
            <h2 style="color: #00ffff; margin-bottom: 20px;">ğŸ† ê²Œì„ ê²°ê³¼ ğŸ†</h2>
            <div id="finalScore" style="font-size: 24px; color: #ffd700; margin-bottom: 20px;"></div>
            <div id="nameInputSection">
                <div style="margin-bottom: 10px;">ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:</div>
                <input type="text" id="nameInput" maxlength="10" placeholder="í”Œë ˆì´ì–´ ì´ë¦„">
                <br>
                <button onclick="saveScore()" style="margin-top: 15px;">ê¸°ë¡ ì €ì¥</button>
            </div>
            <div id="rankingList"></div>
            <div style="margin-top: 20px;">
                <button onclick="closeRanking()">ë‹«ê¸°</button>
                <button onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
            </div>
        </div>
    </div>

    <div id="rightPanel">
        <div id="rankingContainer">
            <div id="rankingTitle">ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹ ğŸ†</div>
            <div id="liveRankingList">
                <div class="ranking-item">
                    <span class="ranking-rank">1</span>
                    <div>
                        <div class="ranking-score">ê¸°ë¡ ì—†ìŒ</div>
                        <div class="ranking-date">-</div>
                    </div>
                </div>
            </div>
            <div id="lastUpdated" style="font-size: 10px; color: #666; text-align: center; margin-top: 5px; padding: 0 10px;">
                ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: -
            </div>
        </div>

        <div id="controlsPanel">
            <div id="controlsTitle">ğŸ® ê²Œì„ ì¡°ì‘ë²• ğŸ®</div>
            <div class="control-item"><span class="control-key">ë°©í–¥í‚¤</span> : ë¹„í–‰ê¸° ì´ë™</div>
            <div class="control-item"><span class="control-key">Zí‚¤</span> : í•„ì‚´ê¸° ë°œë™</div>
            <div class="control-item"><span class="control-key">Pí‚¤</span> : ì¼ì‹œì •ì§€/ì¬ê°œ</div>
            <div class="control-item" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                <div style="color: #88ff88; font-weight: bold; margin-bottom: 4px;">ğŸ“¦ ì•„ì´í…œ ì¢…ë¥˜</div>
                <div><span class="control-key">H</span> : í˜¸ë° ë¯¸ì‚¬ì¼ <span class="item-description">ì ì„ ì¶”ì í•˜ëŠ” ìœ ë„íƒ„</span></div>
                <div><span class="control-key">R</span> : ì—°ì‚¬ íƒ„í™˜ <span class="item-description">ë¹ ë¥¸ ì—°ì‚¬ ì†ë„</span></div>
                <div><span class="control-key">P</span> : ê´€í†µ íƒ„í™˜ <span class="item-description">ì ì„ ê´€í†µí•´ì„œ ì§€ë‚˜ê°</span></div>
                <div><span class="control-key">M</span> : ë©€í‹°ìƒ· <span class="item-description">3ë°©í–¥ ë™ì‹œ ë°œì‚¬</span></div>
                <div><span class="control-key">B</span> : ë°”ìš´ì‹± íƒ„í™˜ <span class="item-description">ë²½ì— íŠ•ê¸°ëŠ” íƒ„í™˜</span></div>
                <div><span class="control-key">S</span> : ì‚¬ì´ë“œí‚¥ <span class="item-description">ì•„ì´í…œ íšë“ì‹œ ë™ë°˜ì ì¶”ê°€</span></div>
            </div>
            <div class="control-item" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 12px; color: #ff9999;">âš ï¸ 5ì´ˆê°„ ê°€ë§Œíˆ ìˆìœ¼ë©´ ì¹´ë¯¸ì¹´ì œ ì êµ° ì¶œí˜„!</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameRunning = true;
        let gamePaused = false;
        let score = 0;
        let specialGauge = 0;
        let maxGauge = 100;
        let specialAttackActive = false;
        let specialAttackTimer = 0;
        let playerItems = [];
        let maxItems = 2;
        let multiShotActive = false;
        let rapidFireActive = false;
        let pierceActive = false;
        let homingActive = false;
        let bouncingActive = false;
        let itemEffectTimers = {
            multiShot: 0,
            rapidFire: 0,
            pierce: 0,
            homing: 0,
            bouncing: 0
        };
        let sidekicks = [];
        let maxSidekicks = 2;
        let lastSidekickShot = 0;
        let explosions = [];
        let difficultyLevel = 1;
        let maxDifficultyLevel = 999;
        let rankings = [];
        let maxRankings = 5;
        let lastMovementTime = 0;
        let idleThreshold = 5000; // 5ì´ˆ
        let kamikazeActive = false;
        let kamikazeEnemy = null;
        let playerLastX = 0;
        let playerLastY = 0;
        let bossActive = false;
        let currentBoss = null;
        let lastStage = 0;
        let flameWave = [];
        let flameWaveActive = false;
        let flameWaveHeight = 0;
        let baseEnemySpawnRate = 45;
        let currentEnemySpawnRate = 42;
        let basePlayerSpeed = 5;
        let currentPlayerSpeed = 5.15;
        let baseShotDelay = 60;
        let currentShotDelay = 57;
        let enemySpeedMultiplier = 1.05;
        
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false,
            space: false,
            z: false
        };

        let pKeyPressed = false;

        // ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ë³€ìˆ˜ë“¤
        let touchControls = {
            joystick: {
                active: false,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                deltaX: 0,
                deltaY: 0
            },
            firing: false,
            specialAttack: false
        };

        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                      (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
        
        class GameObject {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            
            collidesWith(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }
        
        class Player extends GameObject {
            constructor() {
                super(canvas.width / 2 - 20, canvas.height - 60, 40, 50, '#00ff00');
                this.baseSpeed = 5;
                this.autoPilotTargetX = this.x;
                this.autoPilotTargetY = this.y;
            }
            
            update() {
                const speed = currentPlayerSpeed;
                let moved = false;

                if (keys.left && this.x > 0) {
                    this.x -= speed;
                    moved = true;
                }
                if (keys.right && this.x < canvas.width - this.width) {
                    this.x += speed;
                    moved = true;
                }
                if (keys.up && this.y > 0) {
                    this.y -= speed;
                    moved = true;
                }
                if (keys.down && this.y < canvas.height - this.height) {
                    this.y += speed;
                    moved = true;
                }

                // ì›€ì§ì„ ê°ì§€ (ì¹´ë¯¸ì¹´ì œ ì ì€ ì œê±°í•˜ì§€ ì•ŠìŒ)
                if (moved || this.x !== playerLastX || this.y !== playerLastY) {
                    lastMovementTime = Date.now();
                    playerLastX = this.x;
                    playerLastY = this.y;
                }

                // ì¹´ë¯¸ì¹´ì œ ì  ìŠ¤í° ì²´í¬ (í”Œë ˆì´ì–´ê°€ ê°€ë§Œíˆ ìˆìœ¼ë©´ ê³„ì† ìŠ¤í°) - ëª¨ë°”ì¼ì—ì„œëŠ” ë¹„í™œì„±í™”
                if (!isMobile && Date.now() - lastMovementTime > idleThreshold) {
                    // 3ì´ˆë§ˆë‹¤ ìƒˆë¡œìš´ ì¹´ë¯¸ì¹´ì œ ì  ìŠ¤í°
                    if (Date.now() - lastMovementTime > idleThreshold && (Date.now() - lastMovementTime) % 3000 < 100) {
                        spawnKamikazeEnemy();
                    }
                }
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                ctx.save();

                // í˜„ëŒ€ì‹ ì „íˆ¬ê¸° ìŠ¤íƒ€ì¼ (F-22 ë©í„° ê°™ì€ ëŠë‚Œ)

                // ì œíŠ¸ ì—”ì§„ ë°°ê¸° (ì´ì¤‘ ì—”ì§„)
                const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 12);
                exhaustGradient.addColorStop(0, '#0099ff');
                exhaustGradient.addColorStop(0.3, '#0066cc');
                exhaustGradient.addColorStop(0.7, '#004499');
                exhaustGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = exhaustGradient;
                // ì´ì¤‘ ì œíŠ¸ ì—”ì§„
                ctx.fillRect(centerX - 6, this.y + this.height, 4, 12);
                ctx.fillRect(centerX + 2, this.y + this.height, 4, 12);

                // ë©”ì¸ ë™ì²´ (ìŠ¤í…”ìŠ¤ íšŒìƒ‰)
                const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                fuselageGradient.addColorStop(0, '#4a4a5a');
                fuselageGradient.addColorStop(0.5, '#5a5a6a');
                fuselageGradient.addColorStop(1, '#4a4a5a');

                ctx.fillStyle = fuselageGradient;
                ctx.fillRect(centerX - 10, this.y + 8, 20, 36);

                // ë¸íƒ€ ë‚ ê°œ (ìŠ¤í…”ìŠ¤ í˜•íƒœ)
                const wingGradient = ctx.createLinearGradient(this.x - 22, centerY, this.x + this.width + 22, centerY);
                wingGradient.addColorStop(0, '#5a5a6a');
                wingGradient.addColorStop(0.5, '#6a6a7a');
                wingGradient.addColorStop(1, '#5a5a6a');

                ctx.fillStyle = wingGradient;

                // ì¢Œì¸¡ ë¸íƒ€ ë‚ ê°œ (ì‚¼ê°í˜• ëª¨ì–‘)
                ctx.beginPath();
                ctx.moveTo(this.x - 20, this.y + 30);
                ctx.lineTo(centerX - 8, this.y + 18);
                ctx.lineTo(centerX - 8, this.y + 26);
                ctx.closePath();
                ctx.fill();

                // ìš°ì¸¡ ë¸íƒ€ ë‚ ê°œ
                ctx.beginPath();
                ctx.moveTo(this.x + this.width + 20, this.y + 30);
                ctx.lineTo(centerX + 8, this.y + 18);
                ctx.lineTo(centerX + 8, this.y + 26);
                ctx.closePath();
                ctx.fill();

                // ê¸°ìˆ˜ (ìŠ¤í…”ìŠ¤ ê°ì§„ í˜•íƒœ)
                const noseGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + 15);
                noseGradient.addColorStop(0, '#6a6a7a');
                noseGradient.addColorStop(1, '#5a5a6a');

                ctx.fillStyle = noseGradient;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX - 8, this.y + 12);
                ctx.lineTo(centerX + 8, this.y + 12);
                ctx.closePath();
                ctx.fill();

                // ì¡°ì¢…ì„ (ì–´ë‘ìš´ ìºë…¸í”¼)
                ctx.fillStyle = '#1a1a2a';
                ctx.fillRect(centerX - 4, this.y + 10, 8, 12);

                // ë ˆì´ë” í¡ìˆ˜ ì¬ë£Œ ë””í…Œì¼
                ctx.strokeStyle = '#3a3a4a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX - 8, this.y + 15);
                ctx.lineTo(centerX + 8, this.y + 15);
                ctx.moveTo(centerX - 8, this.y + 25);
                ctx.lineTo(centerX + 8, this.y + 25);
                ctx.stroke();

                // í˜„ëŒ€ì‹ ë§ˆí‚¹ (ë³„ê³¼ ë°”)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(centerX - 8, this.y + 30, 4, 2);
                ctx.fillRect(centerX + 4, this.y + 30, 4, 2);

                ctx.fillStyle = '#0066cc';
                ctx.fillRect(centerX - 7, this.y + 30.5, 2, 1);
                ctx.fillRect(centerX + 5, this.y + 30.5, 2, 1);

                // ë¯¸ì‚¬ì¼ í•˜ë“œí¬ì¸íŠ¸
                ctx.fillStyle = '#666';
                ctx.fillRect(this.x - 18, this.y + 25, 3, 2);
                ctx.fillRect(this.x + this.width + 15, this.y + 25, 3, 2);

                // ê³µê¸° í¡ì…êµ¬
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(centerX - 8, this.y + 20, 3, 6);
                ctx.fillRect(centerX + 5, this.y + 20, 3, 6);

                ctx.restore();
            }
        }
        
        class Bullet extends GameObject {
            constructor(x, y, isHoming = false, isPierce = false) {
                super(x, y, 4, 10, '#ffff00');
                this.speed = isHoming ? 7.2 : 12; // í˜¸ë° ë¯¸ì‚¬ì¼ì€ 60% ì†ë„
                this.isHoming = isHoming;
                this.isPierce = isPierce;
                this.hitEnemies = [];
            }
            
            update() {
                if (this.isHoming && enemies.length > 0) {
                    let nearestEnemy = enemies[0];
                    let minDistance = this.distanceTo(nearestEnemy);

                    enemies.forEach(enemy => {
                        const distance = this.distanceTo(enemy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestEnemy = enemy;
                        }
                    });

                    const dx = (nearestEnemy.x + nearestEnemy.width/2) - (this.x + this.width/2);
                    const dy = (nearestEnemy.y + nearestEnemy.height/2) - (this.y + this.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if (distance > 0) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                } else {
                    this.y -= this.speed;
                }
            }
            
            distanceTo(enemy) {
                const dx = (enemy.x + enemy.width/2) - (this.x + this.width/2);
                const dy = (enemy.y + enemy.height/2) - (this.y + this.height/2);
                return Math.sqrt(dx*dx + dy*dy);
            }
            
            draw() {
                if (this.isHoming) {
                    ctx.fillStyle = '#ff00ff';
                } else if (this.isPierce) {
                    ctx.fillStyle = '#00ffff';
                } else {
                    ctx.fillStyle = '#ffff00';
                }
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class BouncingBullet extends GameObject {
            constructor(x, y) {
                super(x, y, 4, 8, '#ffaa00');
                this.speed = 10;

                // Random direction: 40% straight up, 30% diagonal left, 30% diagonal right
                const direction = Math.random();
                if (direction < 0.4) {
                    // Straight up
                    this.vx = 0;
                    this.vy = -this.speed;
                } else if (direction < 0.7) {
                    // Diagonal left
                    this.vx = -this.speed * 0.7;
                    this.vy = -this.speed * 0.7;
                } else {
                    // Diagonal right
                    this.vx = this.speed * 0.7;
                    this.vy = -this.speed * 0.7;
                }

                this.bounces = 0;
                this.maxBounces = 4;
                this.hitEnemies = [];
                this.isBouncing = true;
            }

            update() {
                // Move the bullet
                this.x += this.vx;
                this.y += this.vy;

                // Check for wall collisions and bounce
                if (this.bounces < this.maxBounces) {
                    // Left wall collision
                    if (this.x <= 0) {
                        this.x = 0;
                        this.vx = Math.abs(this.vx);
                        this.bounces++;
                    }
                    // Right wall collision
                    else if (this.x + this.width >= canvas.width) {
                        this.x = canvas.width - this.width;
                        this.vx = -Math.abs(this.vx);
                        this.bounces++;
                    }

                    // Top wall collision
                    if (this.y <= 0) {
                        this.y = 0;
                        this.vy = Math.abs(this.vy);
                        this.bounces++;
                    }
                    // Bottom wall collision
                    else if (this.y + this.height >= canvas.height) {
                        this.y = canvas.height - this.height;
                        this.vy = -Math.abs(this.vy);
                        this.bounces++;
                    }
                }

                // Remove bullet if it has bounced too many times or goes off screen after max bounces
                return this.bounces >= this.maxBounces && (this.y < 0 || this.y > canvas.height || this.x < 0 || this.x > canvas.width);
            }

            draw() {
                // Create a glowing effect for bouncing bullets
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // Outer glow
                const glowGradient = ctx.createRadialGradient(centerX, centerY, 1, centerX, centerY, 8);
                glowGradient.addColorStop(0, '#ffaa00');
                glowGradient.addColorStop(0.5, '#ff6600');
                glowGradient.addColorStop(1, 'rgba(255, 102, 0, 0)');

                ctx.fillStyle = glowGradient;
                ctx.fillRect(this.x - 4, this.y - 4, this.width + 8, this.height + 8);

                // Main bullet body
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Inner highlight
                ctx.fillStyle = '#ffdd44';
                ctx.fillRect(this.x + 1, this.y + 1, this.width - 2, this.height - 2);
            }
        }

        class KamikazeEnemy extends GameObject {
            constructor(x, y, targetX, targetY) {
                super(x, y, 35, 40, '#ff0000');
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 6;
                this.isKamikaze = true;

                // íƒ€ê²Ÿ ë°©í–¥ ê³„ì‚°
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // ì¹´ë¯¸ì¹´ì œ ì  ë””ìì¸ (ë¹¨ê°„ìƒ‰ + ê²½ê³  íš¨ê³¼)
                const warningGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 20);
                warningGradient.addColorStop(0, '#FF0000');
                warningGradient.addColorStop(0.7, '#AA0000');
                warningGradient.addColorStop(1, '#660000');

                ctx.fillStyle = warningGradient;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX - 15, this.y + 15);
                ctx.lineTo(centerX - 10, centerY);
                ctx.lineTo(centerX - 8, this.y + 30);
                ctx.lineTo(centerX - 4, this.y + this.height);
                ctx.lineTo(centerX + 4, this.y + this.height);
                ctx.lineTo(centerX + 8, this.y + 30);
                ctx.lineTo(centerX + 10, centerY);
                ctx.lineTo(centerX + 15, this.y + 15);
                ctx.closePath();
                ctx.fill();

                // ê²½ê³  í‘œì‹œ
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('!', centerX, centerY + 3);
                ctx.textAlign = 'left';
                ctx.shadowBlur = 0;

                // ì¶”ì§„ íš¨ê³¼
                const engineGradient = ctx.createRadialGradient(centerX, this.y + this.height + 8, 2, centerX, this.y + this.height + 8, 12);
                engineGradient.addColorStop(0, '#FFFFFF');
                engineGradient.addColorStop(0.3, '#FF4500');
                engineGradient.addColorStop(0.7, '#FF0000');
                engineGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = engineGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, this.y + this.height + 8, 8, 15, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        class BossEnemy extends GameObject {
            constructor(stageScore) {
                super(canvas.width / 2 - 60, -120, 120, 100, '#000000');
                this.hp = stageScore; // ìŠ¤í…Œì´ì§€ ì ìˆ˜ë§Œí¼ì˜ HP
                this.maxHp = stageScore;
                this.speed = 1;
                this.shootTimer = 0;
                this.moveTimer = 0;
                this.moveDirection = Math.random() < 0.5 ? -1 : 1; // ëœë¤ ì´ˆê¸° ë°©í–¥
                this.isBoss = true;
                this.phase = 1;
                this.attackPattern = 0;
                this.patternTimer = 0;
            }

            update() {
                // ë³´ìŠ¤ ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ (ìœ„ì—ì„œ ë‚´ë ¤ì˜´)
                if (this.y < 50) {
                    this.y += this.speed;
                } else {
                    // ì¢Œìš° ì›€ì§ì„ (ë” ê· í˜•ì ì´ê³  ì¤‘ì•™ ì§€í–¥ì )
                    this.moveTimer++;
                    if (this.moveTimer > 180) { // 200ì—ì„œ 180ìœ¼ë¡œ ì¡°ì •
                        this.moveDirection *= -1;
                        this.moveTimer = 0;
                    }

                    // ì¤‘ì•™ìœ¼ë¡œ ëŒë¦¬ëŠ” í˜ ì¶”ê°€
                    const centerX = canvas.width / 2 - this.width / 2;
                    const distanceFromCenter = this.x - centerX;
                    const centerPull = distanceFromCenter * -0.02; // ì¤‘ì•™ìœ¼ë¡œ ëŒë¦¬ëŠ” í˜

                    this.x += this.moveDirection * 1.2 + centerPull; // ì›€ì§ì„ ì†ë„ ì•½ê°„ ê°ì†Œ

                    // ê²½ê³„ ì²´í¬ (ë” ì—¬ìœ ë¡­ê²Œ)
                    if (this.x < 20) {
                        this.x = 20;
                        this.moveDirection = 1;
                        this.moveTimer = 0; // ë°©í–¥ ë³€ê²½ ì‹œ íƒ€ì´ë¨¸ ë¦¬ì…‹
                    }
                    if (this.x > canvas.width - this.width - 20) {
                        this.x = canvas.width - this.width - 20;
                        this.moveDirection = -1;
                        this.moveTimer = 0; // ë°©í–¥ ë³€ê²½ ì‹œ íƒ€ì´ë¨¸ ë¦¬ì…‹
                    }

                    // ê³µê²© íŒ¨í„´
                    this.patternTimer++;
                    this.updateAttackPattern();
                }
                return false; // Boss should not be removed by update
            }

            updateAttackPattern() {
                // HPì— ë”°ë¥¸ í˜ì´ì¦ˆ ë³€ê²½
                if (this.hp < this.maxHp * 0.3 && this.phase === 1) {
                    this.phase = 2;
                    this.attackPattern = 0;
                    this.patternTimer = 0;
                }

                if (this.phase === 1) {
                    // í˜ì´ì¦ˆ 1: ì§ì„  ë°œì‚¬ (ë” ëŠë¦¬ê²Œ - 60ì—ì„œ 100ìœ¼ë¡œ ì¦ê°€)
                    if (this.patternTimer % 100 === 0) {
                        this.shootStraight();
                    }
                } else {
                    // í˜ì´ì¦ˆ 2: ì‚°íƒ„ ë°œì‚¬ (ë” ëŠë¦¬ê²Œ - 40ì—ì„œ 70ìœ¼ë¡œ ì¦ê°€)
                    if (this.patternTimer % 70 === 0) {
                        this.shootSpread();
                    }
                }
            }

            shootStraight() {
                // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì§ì„  ë°œì‚¬
                const centerX = this.x + this.width / 2;
                enemies.push(new BossBullet(centerX - 5, this.y + this.height, 0));
                enemies.push(new BossBullet(centerX + 5, this.y + this.height, 0));
            }

            shootSpread() {
                // ì‚°íƒ„ ë°œì‚¬
                const centerX = this.x + this.width / 2;
                for (let i = -2; i <= 2; i++) {
                    enemies.push(new BossBullet(centerX, this.y + this.height, i * 0.5));
                }
            }

            takeDamage(damage = 1) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    // ë³´ìŠ¤ ì²˜ì¹˜ì‹œ í­ë°œ íš¨ê³¼
                    for (let i = 0; i < 10; i++) {
                        createExplosion(
                            this.x + Math.random() * this.width,
                            this.y + Math.random() * this.height
                        );
                    }
                    if (bossActive) { // ì •ìƒì ì¸ ë³´ìŠ¤ ì²˜ì¹˜ì‹œì—ë§Œ ì ìˆ˜ ì¦ê°€
                        const stageScore = difficultyLevel * 500;
                        score += Math.floor(stageScore * 0.5); // ìŠ¤í…Œì´ì§€ ì ìˆ˜ì˜ 50%
                    }
                    bossActive = false;
                    currentBoss = null;

                    // ë³´ìŠ¤ ì²˜ì¹˜ í›„ ë³´ìŠ¤ íƒ„í™˜ ëª¨ë‘ ì œê±°
                    enemies = enemies.filter(enemy => !enemy.isBossBullet);

                    // ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ ë©”ì‹œì§€
                    showStageClearMessage();

                    // ë³´ìŠ¤ ì²˜ì¹˜ í›„ ì§€ì—°ëœ ìŠ¤í…Œì´ì§€ ì§„í–‰ ì²´í¬
                    setTimeout(() => {
                        updateDifficulty();
                    }, 1000);

                    return true;
                }
                return false;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // ìŠ¤íƒ€ì›Œì¦ˆ ìŠ¤íƒ€ ë””ìŠ¤íŠ¸ë¡œì´ì–´ ë””ìì¸
                ctx.save();

                // ë©”ì¸ ì‚¼ê°í˜• ì„ ì²´ (Star Destroyer íŠ¹ì§•ì ì¸ ìê¸° ëª¨ì–‘)
                const hullGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + this.height);
                hullGradient.addColorStop(0, '#C0C0C0');
                hullGradient.addColorStop(0.3, '#909090');
                hullGradient.addColorStop(0.7, '#707070');
                hullGradient.addColorStop(1, '#505050');

                ctx.fillStyle = hullGradient;
                ctx.beginPath();
                // ìŠ¤íƒ€ ë””ìŠ¤íŠ¸ë¡œì´ì–´ ìê¸° ëª¨ì–‘
                ctx.moveTo(centerX, this.y + 10); // ë¾°ì¡±í•œ ì•ë¶€ë¶„
                ctx.lineTo(centerX - 55, this.y + this.height - 10); // ì¢Œì¸¡ í›„ë©´
                ctx.lineTo(centerX + 55, this.y + this.height - 10); // ìš°ì¸¡ í›„ë©´
                ctx.closePath();
                ctx.fill();

                // ìƒë¶€ êµ¬ì¡°ë¬¼ (ë¸Œë¦¬ì§€ íƒ€ì›Œ)
                const bridgeGradient = ctx.createLinearGradient(centerX, this.y + 20, centerX, this.y + 50);
                bridgeGradient.addColorStop(0, '#B0B0B0');
                bridgeGradient.addColorStop(0.5, '#808080');
                bridgeGradient.addColorStop(1, '#606060');

                ctx.fillStyle = bridgeGradient;
                // ì¤‘ì•™ ë¸Œë¦¬ì§€ íƒ€ì›Œ
                ctx.fillRect(centerX - 25, this.y + 20, 50, 25);

                // ë¸Œë¦¬ì§€ ìƒë¶€ êµ¬ì¡°
                ctx.fillRect(centerX - 30, this.y + 15, 60, 15);

                // í•¨êµ (Command Bridge)
                ctx.fillStyle = '#404040';
                ctx.fillRect(centerX - 20, this.y + 8, 40, 12);

                // ë¸Œë¦¬ì§€ ì°½ë¬¸ë“¤ (Imperial officers' viewing windows)
                ctx.fillStyle = 'rgba(100, 150, 255, 0.8)';
                for (let i = 0; i < 8; i++) {
                    ctx.fillRect(centerX - 18 + i * 4.5, this.y + 10, 3, 6);
                }

                // ì—”ì§„ ê¸€ë¡œìš° (í›„ë°© ì¶”ì§„ê¸°ë“¤)
                const engineGradient = ctx.createLinearGradient(centerX, this.y + this.height - 15, centerX, this.y + this.height + 5);
                engineGradient.addColorStop(0, '#4080FF');
                engineGradient.addColorStop(0.5, '#2060FF');
                engineGradient.addColorStop(1, 'rgba(32, 96, 255, 0)');

                ctx.fillStyle = engineGradient;
                // ëŒ€í˜• ì£¼ ì—”ì§„ë“¤ (Star Destroyer íŠ¹ì§•ì ì¸ í›„ë°© ì—”ì§„)
                ctx.fillRect(centerX - 45, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX - 30, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX - 15, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX + 3, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX + 18, this.y + this.height - 12, 12, 18);
                ctx.fillRect(centerX + 33, this.y + this.height - 12, 12, 18);

                // í‘œë©´ ì„¸ë¶€ ì‚¬í•­ (Imperial hull paneling)
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = 1;

                // ì„ ì²´ íŒ¨ë„ ë¼ì¸ë“¤
                ctx.beginPath();
                ctx.moveTo(centerX - 40, this.y + 30);
                ctx.lineTo(centerX + 40, this.y + 30);
                ctx.moveTo(centerX - 35, this.y + 45);
                ctx.lineTo(centerX + 35, this.y + 45);
                ctx.moveTo(centerX - 30, this.y + 60);
                ctx.lineTo(centerX + 30, this.y + 60);
                ctx.stroke();

                // ì¸¡ë©´ ë¬´ê¸° í•˜ë“œí¬ì¸íŠ¸ (Turbolaser batteries)
                ctx.fillStyle = '#505050';

                // ì¢Œì¸¡ í„°ë³´ë ˆì´ì € í¬íƒ‘ë“¤
                ctx.fillRect(centerX - 50, this.y + 40, 8, 6);
                ctx.fillRect(centerX - 50, this.y + 55, 8, 6);
                ctx.fillRect(centerX - 45, this.y + 70, 6, 4);

                // ìš°ì¸¡ í„°ë³´ë ˆì´ì € í¬íƒ‘ë“¤
                ctx.fillRect(centerX + 42, this.y + 40, 8, 6);
                ctx.fillRect(centerX + 42, this.y + 55, 8, 6);
                ctx.fillRect(centerX + 39, this.y + 70, 6, 4);

                // ì œêµ­ ë§ˆí¬/ë¡œê³  ìœ„ì¹˜ (ì¤‘ì•™ ìƒë¶€)
                ctx.fillStyle = '#303030';
                ctx.beginPath();
                ctx.arc(centerX, this.y + 35, 8, 0, Math.PI * 2);
                ctx.fill();

                // ì•ˆí…Œë‚˜/í†µì‹  ì¥ë¹„
                ctx.strokeStyle = '#606060';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX - 10, this.y + 15);
                ctx.lineTo(centerX - 10, this.y + 5);
                ctx.moveTo(centerX + 10, this.y + 15);
                ctx.lineTo(centerX + 10, this.y + 5);
                // Star Destroyer íŠ¹ì§•ì ì¸ ë””í…Œì¼ ì™„ì„±
                ctx.fillStyle = '#808080';

                // í•˜ìœ„ í¬íƒ‘ë“¤ (Heavy turbolaser turrets)
                ctx.fillRect(centerX - 15, this.y + 50, 5, 3);
                ctx.fillRect(centerX + 10, this.y + 50, 5, 3);
                ctx.fillRect(centerX - 8, this.y + 65, 4, 3);
                ctx.fillRect(centerX + 4, this.y + 65, 4, 3);

                // Imperial insignia (ì œêµ­ ë¡œê³ )
                ctx.fillStyle = '#202020';
                ctx.beginPath();
                ctx.arc(centerX, this.y + 55, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // HP ë°”
                const hpBarWidth = this.width;
                const hpBarHeight = 8;
                const hpPercentage = this.hp / this.maxHp;

                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x, this.y - 15, hpBarWidth, hpBarHeight);

                ctx.fillStyle = hpPercentage > 0.3 ? '#00FF00' : '#FF0000';
                ctx.fillRect(this.x, this.y - 15, hpBarWidth * hpPercentage, hpBarHeight);

                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - 15, hpBarWidth, hpBarHeight);

                // í˜ì´ì¦ˆ 2ì—ì„œ ë¹¨ê°„ ê²½ê³  íš¨ê³¼
                if (this.phase === 2) {
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                    ctx.shadowBlur = 0;
                }
            }
        }

        class BossBullet extends GameObject {
            constructor(x, y, angle) {
                super(x, y, 8, 12, '#FF0000');
                this.speed = 4;
                this.angle = angle;
                this.vx = Math.sin(angle) * this.speed;
                this.vy = this.speed;
                this.isBossBullet = true;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // ë³´ìŠ¤ ì´ì•Œì€ í™”ë©´ì„ ë²—ì–´ë‚˜ë©´ ë‹¤ì‹œ ìœ„ì—ì„œ ë‚˜íƒ€ë‚¨ (ìˆœí™˜)
                if (this.y > canvas.height + 20) {
                    this.y = -20;
                }
                if (this.x < -20) {
                    this.x = canvas.width + 20;
                } else if (this.x > canvas.width + 20) {
                    this.x = -20;
                }
                if (this.y < -20) {
                    this.y = canvas.height + 20;
                }
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // ë¹¨ê°„ ì—ë„ˆì§€ íƒ„í™˜
                const bulletGradient = ctx.createRadialGradient(centerX, centerY, 2, centerX, centerY, 6);
                bulletGradient.addColorStop(0, '#FFFF00');
                bulletGradient.addColorStop(0.5, '#FF4500');
                bulletGradient.addColorStop(1, '#FF0000');

                ctx.fillStyle = bulletGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 4, 6, 0, 0, 2 * Math.PI);
                ctx.fill();

                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 2, 3, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class UAPBullet extends GameObject {
            constructor(x, y, vx, vy) {
                super(x, y, 6, 14, '#00FFAA');
                this.vx = vx;
                this.vy = vy;
                this.isUAPBullet = true;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // UAP ì´ì•Œì€ í™”ë©´ì„ ë²—ì–´ë‚˜ë©´ ì œê±°ë¨ (BossBulletê³¼ ë‹¬ë¦¬ ìˆœí™˜í•˜ì§€ ì•ŠìŒ)
                if (this.y < -20 || this.y > canvas.height + 20 ||
                    this.x < -20 || this.x > canvas.width + 20) {
                    return true; // ì œê±° ì‹ í˜¸
                }
                return false;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // ì™¸ê³„ ì—ë„ˆì§€ ë¹” íš¨ê³¼ (ì²­ë¡ìƒ‰)
                const bulletGradient = ctx.createRadialGradient(centerX, centerY, 1, centerX, centerY, 7);
                bulletGradient.addColorStop(0, '#FFFFFF');
                bulletGradient.addColorStop(0.3, '#00FFFF');
                bulletGradient.addColorStop(0.7, '#00CCAA');
                bulletGradient.addColorStop(1, '#004455');

                ctx.fillStyle = bulletGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 3, 7, 0, 0, 2 * Math.PI);
                ctx.fill();

                // ë‚´ë¶€ ë°ì€ ì½”ì–´
                ctx.shadowColor = '#00FFAA';
                ctx.shadowBlur = 12;
                ctx.fillStyle = '#AAFFFF';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 1.5, 4, 0, 0, 2 * Math.PI);
                ctx.fill();

                // ì—ë„ˆì§€ íŒŒì¥ íš¨ê³¼
                ctx.shadowBlur = 6;
                ctx.strokeStyle = '#00FFAA';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 4, 8, 0, 0, 2 * Math.PI);
                ctx.stroke();

                ctx.shadowBlur = 0;
            }
        }

        class EliteEnemy extends GameObject {
            constructor(x, y, hp) {
                super(x, y, 40, 45, '#ff0000');
                this.baseSpeed = 1.5 + Math.random() * 1;
                this.speed = this.baseSpeed * enemySpeedMultiplier;
                this.type = Math.floor(Math.random() * 3);
                this.hp = hp;
                this.maxHp = hp;
                this.isElite = true;
            }

            takeDamage(damage = 1) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    return true; // ì²˜ì¹˜ë¨
                }
                return false;
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // ê°•í™” ì ì€ ê¸°ì¡´ ë””ìì¸ì— í™©ê¸ˆìƒ‰ í…Œë‘ë¦¬ì™€ HP ë°” ì¶”ê°€
                if (this.type === 0) {
                    // UAP ê°•í™”í˜•
                    const uapGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 20);
                    uapGradient.addColorStop(0, '#FFD700');
                    uapGradient.addColorStop(0.4, '#FFA500');
                    uapGradient.addColorStop(0.8, '#FF8C00');
                    uapGradient.addColorStop(1, '#FF4500');

                    ctx.fillStyle = uapGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 18, 10, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // ìƒë‹¨ ë”
                    const domeGradient = ctx.createRadialGradient(centerX, centerY - 3, 2, centerX, centerY - 3, 12);
                    domeGradient.addColorStop(0, '#FFFF00');
                    domeGradient.addColorStop(0.6, '#FFD700');
                    domeGradient.addColorStop(1, '#FFA500');

                    ctx.fillStyle = domeGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY - 3, 12, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // í™©ê¸ˆ ë¹›
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 22, 12, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                } else if (this.type === 1) {
                    // TIE Fighter ê°•í™”í˜•
                    const imperialGold = '#FFD700';
                    const darkGold = '#B8860B';

                    // ì¤‘ì•™ ì¡°ì¢…ì‹¤
                    const cockpitGradient = ctx.createRadialGradient(centerX, centerY, 3, centerX, centerY, 10);
                    cockpitGradient.addColorStop(0, '#FFD700');
                    cockpitGradient.addColorStop(0.7, '#DAA520');
                    cockpitGradient.addColorStop(1, '#B8860B');

                    ctx.fillStyle = cockpitGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 10, 10, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // í™©ê¸ˆ ì†”ë¼ íŒ¨ë„
                    ctx.fillStyle = imperialGold;
                    ctx.beginPath();
                    ctx.moveTo(this.x - 18, centerY - 12);
                    ctx.lineTo(this.x - 5, centerY - 14);
                    ctx.lineTo(this.x - 2, centerY - 10);
                    ctx.lineTo(this.x - 2, centerY + 10);
                    ctx.lineTo(this.x - 5, centerY + 14);
                    ctx.lineTo(this.x - 18, centerY + 12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width + 18, centerY - 12);
                    ctx.lineTo(this.x + this.width + 5, centerY - 14);
                    ctx.lineTo(this.x + this.width + 2, centerY - 10);
                    ctx.lineTo(this.x + this.width + 2, centerY + 10);
                    ctx.lineTo(this.x + this.width + 5, centerY + 14);
                    ctx.lineTo(this.x + this.width + 18, centerY + 12);
                    ctx.closePath();
                    ctx.fill();

                } else {
                    // ê°•í™” êµ¬ì¶•í•¨
                    const goldGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + this.height);
                    goldGradient.addColorStop(0, '#FFD700');
                    goldGradient.addColorStop(0.5, '#DAA520');
                    goldGradient.addColorStop(1, '#B8860B');

                    ctx.fillStyle = goldGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 18, this.y + 10);
                    ctx.lineTo(centerX - 15, this.y + this.height);
                    ctx.lineTo(centerX + 15, this.y + this.height);
                    ctx.lineTo(centerX + 18, this.y + 10);
                    ctx.closePath();
                    ctx.fill();
                }

                // HP ë°”
                const hpBarWidth = this.width + 10;
                const hpBarHeight = 6;
                const hpPercentage = this.hp / this.maxHp;

                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x - 5, this.y - 12, hpBarWidth, hpBarHeight);

                ctx.fillStyle = hpPercentage > 0.5 ? '#FFD700' : hpPercentage > 0.25 ? '#FFA500' : '#FF4500';
                ctx.fillRect(this.x - 5, this.y - 12, hpBarWidth * hpPercentage, hpBarHeight);

                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x - 5, this.y - 12, hpBarWidth, hpBarHeight);

                // í™©ê¸ˆ í…Œë‘ë¦¬ íš¨ê³¼
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
                ctx.shadowBlur = 0;
            }
        }

        class Enemy extends GameObject {
            constructor(x, y) {
                super(x, y, 30, 35, '#ff0000');
                this.baseSpeed = 2 + Math.random() * 2;
                this.speed = this.baseSpeed * enemySpeedMultiplier;
                this.type = Math.floor(Math.random() * 3);
            }
            
            update() {
                this.y += this.speed;
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // ê°’ ìœ íš¨ì„± ê²€ì‚¬
                if (!isFinite(centerX) || !isFinite(centerY) || !isFinite(this.x) || !isFinite(this.y) ||
                    !isFinite(this.width) || !isFinite(this.height)) {
                    return; // ì˜ëª»ëœ ê°’ì´ë©´ ê·¸ë¦¬ê¸° ì¤‘ë‹¨
                }

                ctx.save();

                if (this.type === 0) {
                    // German Messerschmitt Bf 109 style (larger and more detailed)

                    // Engine exhaust (larger)
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 4, this.y + this.height, 8, 10);

                    // Main fuselage (dark gray with better contrast)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                    fuselageGradient.addColorStop(0, '#2a2a2a');
                    fuselageGradient.addColorStop(0.5, '#4a4a4a');
                    fuselageGradient.addColorStop(1, '#2a2a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 8, this.y + 6, 16, 30);

                    // Engine cowling
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(centerX - 6, this.y + 2, 12, 8);

                    // Wings (larger and more realistic)
                    const wingGradient = ctx.createLinearGradient(this.x - 20, centerY, this.x + this.width + 20, centerY);
                    wingGradient.addColorStop(0, '#3a3a3a');
                    wingGradient.addColorStop(0.5, '#5a5a5a');
                    wingGradient.addColorStop(1, '#3a3a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing
                    ctx.fillRect(this.x - 16, this.y + 18, 20, 8);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 18, 20, 8);

                    // Nose/propeller area
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 6, this.y + 10);
                    ctx.lineTo(centerX + 6, this.y + 10);
                    ctx.closePath();
                    ctx.fill();

                    // German Balkenkreuz (Iron Cross)
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(centerX - 1, this.y + 12, 2, 12);
                    ctx.fillRect(centerX - 6, this.y + 17, 12, 2);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 5, this.y + 17.5, 4, 1);
                    ctx.fillRect(centerX + 1, this.y + 17.5, 4, 1);

                    // Wing guns
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(this.x - 14, this.y + 20, 2, 4);
                    ctx.fillRect(this.x + this.width + 12, this.y + 20, 2, 4);

                } else if (this.type === 1) {
                    // Japanese Mitsubishi A6M Zero style (larger and more detailed)

                    // Engine exhaust
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 3, this.y + this.height, 6, 10);

                    // Main fuselage (olive/dark green)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 8, centerY, centerX + 8, centerY);
                    fuselageGradient.addColorStop(0, '#2a3a2a');
                    fuselageGradient.addColorStop(0.5, '#3a4a3a');
                    fuselageGradient.addColorStop(1, '#2a3a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 7, this.y + 4, 14, 32);

                    // Engine cowling
                    ctx.fillStyle = '#1a2a1a';
                    ctx.fillRect(centerX - 5, this.y + 1, 10, 8);

                    // Wings (longer, typical of Zero)
                    const wingGradient = ctx.createLinearGradient(this.x - 18, centerY, this.x + this.width + 18, centerY);
                    wingGradient.addColorStop(0, '#3a4a3a');
                    wingGradient.addColorStop(0.5, '#4a5a4a');
                    wingGradient.addColorStop(1, '#3a4a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing (longer)
                    ctx.fillRect(this.x - 18, this.y + 16, 22, 7);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 16, 22, 7);

                    // Nose
                    ctx.fillStyle = '#4a5a4a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 5, this.y + 8);
                    ctx.lineTo(centerX + 5, this.y + 8);
                    ctx.closePath();
                    ctx.fill();

                    // Japanese Hinomaru (Rising Sun)
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(centerX, this.y + 18, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#cc0000';
                    ctx.beginPath();
                    ctx.arc(centerX, this.y + 18, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Wing guns
                    ctx.fillStyle = '#ffaa44';
                    ctx.fillRect(this.x - 16, this.y + 18, 2, 3);
                    ctx.fillRect(this.x + this.width + 14, this.y + 18, 2, 3);

                } else {
                    // Italian/Other Axis Macchi C.202 style (larger and more detailed)

                    // Engine exhaust
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 4, this.y + this.height, 8, 10);

                    // Main fuselage (sand/brown camo)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                    fuselageGradient.addColorStop(0, '#4a3a2a');
                    fuselageGradient.addColorStop(0.5, '#5a4a3a');
                    fuselageGradient.addColorStop(1, '#4a3a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 8, this.y + 5, 16, 30);

                    // Engine cowling
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(centerX - 6, this.y + 2, 12, 8);

                    // Wings
                    const wingGradient = ctx.createLinearGradient(this.x - 17, centerY, this.x + this.width + 17, centerY);
                    wingGradient.addColorStop(0, '#5a4a3a');
                    wingGradient.addColorStop(0.5, '#6a5a4a');
                    wingGradient.addColorStop(1, '#5a4a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing
                    ctx.fillRect(this.x - 15, this.y + 17, 19, 8);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 17, 19, 8);

                    // Nose
                    ctx.fillStyle = '#6a5a4a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 6, this.y + 9);
                    ctx.lineTo(centerX + 6, this.y + 9);
                    ctx.closePath();
                    ctx.fill();

                    // Italian fasces symbol (simplified)
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(centerX - 4, this.y + 15, 8, 2);
                    ctx.fillRect(centerX - 1, this.y + 13, 2, 6);
                    ctx.fillStyle = '#006600';
                    ctx.fillRect(centerX - 3, this.y + 15.5, 6, 1);

                    // Wing guns
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(this.x - 13, this.y + 19, 2, 4);
                    ctx.fillRect(this.x + this.width + 11, this.y + 19, 2, 4);
                }

                ctx.restore();
            }
        }

        class UAPEnemy extends GameObject {
            constructor() {
                // êµ¬ë¦„ ìœ„ì¹˜ì—ì„œ ìŠ¤í° (êµ¬ë¦„ê³¼ ë¹„ìŠ·í•œ ìœ„ì¹˜)
                const cloudX = Math.random() * canvas.width;
                const cloudY = Math.random() * canvas.height * 0.7; // í™”ë©´ ìƒë‹¨ 70%ì—ì„œ ìŠ¤í°
                super(cloudX, cloudY, 30, 20, '#silver');

                this.speed = 3 + Math.random() * 3; // ë” ë¹ ë¥´ê²Œ
                this.rotationAngle = 0;
                this.glowIntensity = 0;
                this.isUAP = true;
                this.isEmerging = true; // ë“±ì¥ ìƒíƒœ
                this.emergingTimer = 0;
                this.attackMode = false;
                this.shootTimer = 0;

                // ì´ˆê¸°ì—ëŠ” ìˆ¨ì–´ìˆìŒ (íˆ¬ëª…)
                this.alpha = 0;
                this.originalY = this.y;

                // ì ì‹œ í›„ í”Œë ˆì´ì–´ë¥¼ ì¶”ì í•˜ê¸° ì‹œì‘
                this.updateTarget();
            }

            updateTarget() {
                // í”Œë ˆì´ì–´ë¥¼ í–¥í•œ ë°©í–¥ ê³„ì‚°
                const dx = (player.x + player.width / 2) - (this.x + this.width / 2);
                const dy = (player.y + player.height / 2) - (this.y + this.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                }
            }

            update() {
                this.emergingTimer++;

                if (this.isEmerging) {
                    // êµ¬ë¦„ì—ì„œ ì„œì„œíˆ ë“±ì¥ (2ì´ˆê°„)
                    if (this.emergingTimer < 120) {
                        this.alpha = Math.min(1, this.emergingTimer / 60);
                        // ì‚´ì§ ìœ„ì•„ë˜ë¡œ ì›€ì§ì„ (ë“±ì¥ íš¨ê³¼)
                        this.y = this.originalY + Math.sin(this.emergingTimer * 0.1) * 5;
                    } else {
                        // ë“±ì¥ ì™„ë£Œ, ê³µê²© ëª¨ë“œ ì‹œì‘
                        this.isEmerging = false;
                        this.attackMode = true;
                        this.alpha = 1;
                        this.updateTarget(); // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì¬ê³„ì‚°
                    }
                } else if (this.attackMode) {
                    // ê³µê²© ëª¨ë“œ: í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ë¹ ë¥´ê²Œ ëŒì§„
                    this.x += this.vx;
                    this.y += this.vy;

                    // ì£¼ê¸°ì ìœ¼ë¡œ ë°©í–¥ ì—…ë°ì´íŠ¸ (ìœ ë„ ë¯¸ì‚¬ì¼ì²˜ëŸ¼)
                    if (this.emergingTimer % 30 === 0) {
                        this.updateTarget();
                    }

                    // UAP ë°œì‚¬ (ë§¤ 60í”„ë ˆì„ë§ˆë‹¤)
                    this.shootTimer++;
                    if (this.shootTimer >= 60) {
                        this.shoot();
                        this.shootTimer = 0;
                    }
                }

                // íšŒì „ íš¨ê³¼
                this.rotationAngle += 0.1;
                this.glowIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±° ëŒ€ìƒ
                if (this.x < -50 || this.x > canvas.width + 50 ||
                    this.y < -50 || this.y > canvas.height + 50) {
                    return true; // ì œê±° ì‹ í˜¸
                }
                return false;
            }

            shoot() {
                // UAP ì—ë„ˆì§€ íƒ„í™˜ ë°œì‚¬
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // í”Œë ˆì´ì–´ë¥¼ í–¥í•œ ì—ë„ˆì§€ íƒ„í™˜
                const dx = (player.x + player.width / 2) - centerX;
                const dy = (player.y + player.height / 2) - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const bulletSpeed = 4;
                    const vx = (dx / distance) * bulletSpeed;
                    const vy = (dy / distance) * bulletSpeed;

                    // UAP ì „ìš© íƒ„í™˜ ìƒì„±
                    enemies.push(new UAPBullet(centerX - 2, centerY, vx, vy));
                }
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.rotationAngle);

                // UAP ëª¸ì²´ (ì›ë°˜í˜•)
                const uapGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 18);
                uapGradient.addColorStop(0, '#E6E6FA');
                uapGradient.addColorStop(0.4, '#C0C0C0');
                uapGradient.addColorStop(0.8, '#808080');
                uapGradient.addColorStop(1, '#404040');

                ctx.fillStyle = uapGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 8, 0, 0, 2 * Math.PI);
                ctx.fill();

                // ìƒë‹¨ ë”
                const domeGradient = ctx.createRadialGradient(0, -3, 2, 0, -3, 10);
                domeGradient.addColorStop(0, '#F0F8FF');
                domeGradient.addColorStop(0.6, '#B0C4DE');
                domeGradient.addColorStop(1, '#778899');

                ctx.fillStyle = domeGradient;
                ctx.beginPath();
                ctx.ellipse(0, -3, 10, 5, 0, 0, 2 * Math.PI);
                ctx.fill();

                // ì£¼ë³€ ê¸€ë¡œìš° íš¨ê³¼
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 12 * this.glowIntensity;
                ctx.fillStyle = `rgba(0, 255, 255, ${0.4 * this.glowIntensity})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, 18, 10, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;

                // ë¹› ì ë“¤
                ctx.fillStyle = '#00FFFF';
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI / 3) + this.rotationAngle;
                    const lightX = Math.cos(angle) * 12;
                    const lightY = Math.sin(angle) * 7;
                    ctx.beginPath();
                    ctx.arc(lightX, lightY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Cloud {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = 0.3 + Math.random() * 0.8; // êµ¬ë¦„ì€ ë” ì²œì²œíˆ
                this.size = 20 + Math.random() * 40; // êµ¬ë¦„ì€ ë” í¬ê²Œ
                this.alpha = 0.3 + Math.random() * 0.4; // êµ¬ë¦„ì€ ë” íˆ¬ëª…í•˜ê²Œ
                this.offsetX = Math.random() * 10; // ìˆ˜í‰ ì´ë™
            }

            update() {
                this.y += this.speed;
                this.x += Math.sin(Date.now() * 0.001 + this.offsetX) * 0.2; // ë¶€ë“œëŸ¬ìš´ ìˆ˜í‰ ì›€ì§ì„

                if (this.y > canvas.height + 50) {
                    this.y = -50;
                    this.x = Math.random() * canvas.width;
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;

                // êµ¬ë¦„ ê·¸ë¦¬ê¸° (ì—¬ëŸ¬ ì›ì„ ê²¹ì³ì„œ êµ¬ë¦„ ëª¨ì–‘)
                const cloudGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                cloudGradient.addColorStop(0, '#ffffff');
                cloudGradient.addColorStop(0.7, '#e6e6e6');
                cloudGradient.addColorStop(1, 'rgba(200, 200, 200, 0)');

                ctx.fillStyle = cloudGradient;

                // ë©”ì¸ êµ¬ë¦„ ëª¸ì²´ (ì—¬ëŸ¬ ì›ìœ¼ë¡œ êµ¬ì„±)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.3, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x + this.size * 0.3, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x, this.y - this.size * 0.2, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        
        class Item extends GameObject {
            constructor(x, y) {
                super(x, y, 20, 20, '#00ff00');
                this.speed = 3;
                this.types = ['multiShot', 'rapidFire', 'pierce', 'homing', 'bouncing'];
                this.type = this.types[Math.floor(Math.random() * this.types.length)];
                this.colors = {
                    multiShot: '#ff6600',
                    rapidFire: '#ff0066',
                    pierce: '#00ffff',
                    homing: '#ff00ff',
                    bouncing: '#ffaa00'
                };
                this.symbols = {
                    multiShot: 'M',
                    rapidFire: 'R',
                    pierce: 'P',
                    homing: 'H',
                    bouncing: 'B'
                };
                this.color = this.colors[this.type];
            }
            
            update() {
                this.y += this.speed;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.symbols[this.type], this.x + this.width/2, this.y + this.height/2 + 4);
                ctx.textAlign = 'left';
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - 1, this.y - 1, this.width + 2, this.height + 2);
            }
        }
        
        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.timer = 0;
                this.maxTimer = 20;
                
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 1.0
                    });
                }
            }
            
            update() {
                this.timer++;
                this.particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.95;
                    particle.vy *= 0.95;
                    particle.life -= 0.05;
                });
            }
            
            draw() {
                this.particles.forEach(particle => {
                    if (particle.life > 0) {
                        ctx.globalAlpha = particle.life;
                        ctx.fillStyle = `hsl(${30 + Math.random() * 30}, 100%, 60%)`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                });
            }
            
            isDead() {
                return this.timer >= this.maxTimer;
            }
        }
        
        class Sidekick extends GameObject {
            constructor(side) {
                super(0, 0, 15, 20, '#00aa00');
                this.side = side;
                this.lastShot = 0; // ê°œë³„ ë°œì‚¬ íƒ€ì´ë¨¸
                this.lastBouncingShot = 0; // ë°”ìš´ì‹± ì´ì•Œ ë°œì‚¬ íƒ€ì´ë¨¸
                if (side === 'left') {
                    this.offsetX = -30;
                    this.offsetY = 10;
                } else {
                    this.offsetX = 30;
                    this.offsetY = 10;
                }
            }
            
            update(playerX, playerY) {
                // í”Œë ˆì´ì–´ ê¸°ì²´ì˜ ì¤‘ì‹¬ì—ì„œ ê³„ì‚°
                const playerCenterX = playerX + 20;
                const playerCenterY = playerY + 25;
                
                this.x = playerCenterX + this.offsetX - this.width / 2;
                this.y = playerCenterY + this.offsetY - this.height / 2;
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Main body (green)
                ctx.fillStyle = '#00AA00';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 6, 8, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Wing (darker green)
                ctx.fillStyle = '#007700';
                if (this.side === 'left') {
                    ctx.beginPath();
                    ctx.moveTo(this.x - 3, centerY);
                    ctx.lineTo(this.x + 3, centerY - 5);
                    ctx.lineTo(this.x + 3, centerY + 5);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width + 3, centerY);
                    ctx.lineTo(this.x + this.width - 3, centerY - 5);
                    ctx.lineTo(this.x + this.width - 3, centerY + 5);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Engine (bright green)
                ctx.fillStyle = '#00FF00';
                ctx.beginPath();
                ctx.ellipse(centerX, this.y + this.height + 2, 2, 4, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Core (cyan)
                ctx.fillStyle = '#00FFAA';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 3, 4, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        const player = new Player();
        let bullets = [];
        let enemies = [];
        const clouds = []; // êµ¬ë¦„
        let items = [];
        let sidekickBullets = [];
        let bouncingBullets = [];

        // êµ¬ë¦„ ì´ˆê¸°í™” (ê°œìˆ˜ ì¤„ì„)
        for (let i = 0; i < 15; i++) {
            clouds.push(new Cloud());
        }
        
        let lastShot = 0;
        let lastBouncingShot = 0;
        let enemySpawnTimer = 0;
        let itemSpawnTimer = 0;
        
        function spawnEnemy() {
            // í”Œë ˆì´ì–´ ìœ„ì¹˜ì™€ ì†ë„ë¥¼ ê³ ë ¤í•œ ìŠ¤í° ìœ„ì¹˜ ê³„ì‚°
            const playerCenterX = player.x + player.width / 2;
            const playerSpeed = currentPlayerSpeed;

            // ì ì´ í™”ë©´ì„ ê°€ë¡œì§€ë¥´ëŠ” ì‹œê°„ ê³„ì‚° (ëŒ€ëµì )
            const enemySpeed = 2 + Math.random() * 2; // ì ì˜ ê¸°ë³¸ ì†ë„
            const timeToReachPlayer = canvas.height / (enemySpeed * enemySpeedMultiplier);

            // í”Œë ˆì´ì–´ê°€ ì´ë™í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ê±°ë¦¬
            const maxPlayerMovement = playerSpeed * timeToReachPlayer;

            // í”Œë ˆì´ì–´ê°€ ë„ë‹¬ ê°€ëŠ¥í•œ ë²”ìœ„ ê³„ì‚°
            const minReachableX = Math.max(0, playerCenterX - maxPlayerMovement);
            const maxReachableX = Math.min(canvas.width, playerCenterX + maxPlayerMovement);

            // ë„ë‹¬ ê°€ëŠ¥í•œ ë²”ìœ„ì—ì„œ ì  ìŠ¤í° (ì•½ê°„ì˜ ì—¬ìœ  ì¶”ê°€)
            const safetyMargin = 50; // ì—¬ìœ  ê³µê°„
            const spawnMinX = Math.max(0, minReachableX - safetyMargin);
            const spawnMaxX = Math.min(canvas.width - 25, maxReachableX + safetyMargin);

            // ìµœì†Œ ìŠ¤í° ë²”ìœ„ ë³´ì¥
            const minSpawnRange = 200;
            let finalSpawnRange = spawnMaxX - spawnMinX;

            if (finalSpawnRange < minSpawnRange) {
                // ë²”ìœ„ê°€ ë„ˆë¬´ ì¢ìœ¼ë©´ í”Œë ˆì´ì–´ ì¤‘ì‹¬ìœ¼ë¡œ ìµœì†Œ ë²”ìœ„ í™•ë³´
                const centerX = (spawnMinX + spawnMaxX) / 2;
                const halfRange = minSpawnRange / 2;
                const newMinX = Math.max(0, centerX - halfRange);
                const newMaxX = Math.min(canvas.width - 25, centerX + halfRange);

                const x = newMinX + Math.random() * (newMaxX - newMinX);
                enemies.push(new Enemy(x, -25));
            } else {
                const x = spawnMinX + Math.random() * (spawnMaxX - spawnMinX);
                enemies.push(new Enemy(x, -25));
            }
        }
        
        function updateDifficulty() {
            // ìŠ¤í…Œì´ì§€ë³„ í•„ìš” ì ìˆ˜: 1â†’2(500), 2â†’3(1500), 3â†’4(3000), 4â†’5(4500)...
            let newDifficultyLevel = 1;
            const stageThresholds = [];

            // ìŠ¤í…Œì´ì§€ 2: 500ì 
            // ìŠ¤í…Œì´ì§€ 3: 1500ì  (500 + 1000)
            // ìŠ¤í…Œì´ì§€ 4: 3000ì  (1500 + 1500)
            // ìŠ¤í…Œì´ì§€ 5: 4500ì  (3000 + 1500)
            // íŒ¨í„´: në²ˆì§¸ ìŠ¤í…Œì´ì§€ = (n-1) * n * 250
            for (let stage = 2; stage <= 100; stage++) {
                const threshold = (stage - 1) * stage * 250;
                stageThresholds.push(threshold);
            }

            for (let i = 0; i < stageThresholds.length; i++) {
                if (score >= stageThresholds[i]) {
                    newDifficultyLevel = i + 2; // i+2 because stage 1 starts at 0 points
                } else {
                    break;
                }
            }

            // ë³´ìŠ¤ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ìŠ¤í…Œì´ì§€ ì§„í–‰ì„ ë§‰ìŒ
            if (newDifficultyLevel > difficultyLevel && !bossActive) {
                difficultyLevel = newDifficultyLevel;

                // ì  ìŠ¤í° ì†ë„ (ë‹¨ê³„ë³„ 3í”„ë ˆì„ ê°ì†Œ, ìµœì†Œ 8í”„ë ˆì„)
                currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (difficultyLevel * 3));

                // ì  ì´ë™ ì†ë„ (ë‹¨ê³„ë³„ 5% ì¦ê°€, ìµœëŒ€ 2ë°°)
                enemySpeedMultiplier = Math.min(2.0, 1.0 + (difficultyLevel * 0.05));

                // í”Œë ˆì´ì–´ ì´ë™ ì†ë„ (ë‹¨ê³„ë³„ 3% ì¦ê°€, ìµœëŒ€ 1.6ë°°)
                currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + difficultyLevel * 0.03));

                // í”Œë ˆì´ì–´ ìƒ‡ ì†ë„ (ë‹¨ê³„ë³„ 3ms ê°ì†Œ, ìµœì†Œ 30ms)
                currentShotDelay = rapidFireActive ?
                    Math.max(15, baseShotDelay - (difficultyLevel * 3)) / 3 :
                    Math.max(30, baseShotDelay - (difficultyLevel * 3));

                // ìŠ¤í…Œì´ì§€ ì•Œë¦¼ ë¨¼ì € í‘œì‹œ
                showStageMessage();

                // ë³´ìŠ¤ ì†Œí™˜ (2ì´ˆ í›„, HP = ìŠ¤í…Œì´ì§€ ì ìˆ˜)
                setTimeout(() => {
                    if (gameRunning && !gamePaused) { // ê²Œì„ì´ ê³„ì† ì§„í–‰ ì¤‘ì¼ ë•Œë§Œ ë³´ìŠ¤ ì†Œí™˜
                        const stageScore = difficultyLevel * 500;
                        spawnBoss(stageScore);
                    }
                }, 2000);
            }
        }

        function spawnBoss(stageScore) {
            if (!bossActive) {
                bossActive = true;
                currentBoss = new BossEnemy(stageScore);
                enemies.push(currentBoss);

                // ë³´ìŠ¤ ë“±ì¥ ì‹œ ì¼ë°˜ ì  ì¦ê°€ (3-5ë§ˆë¦¬ ì¶”ê°€ ìŠ¤í°)
                const extraEnemyCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < extraEnemyCount; i++) {
                    setTimeout(() => {
                        const x = Math.random() * (canvas.width - 25);
                        enemies.push(new Enemy(x, -25));
                    }, i * 150); // 150ms ê°„ê²©ìœ¼ë¡œ ìŠ¤í°
                }

                showBossMessage();
            }
        }

        function spawnEliteEnemy(hp) {
            // í”Œë ˆì´ì–´ê°€ ë„ë‹¬ ê°€ëŠ¥í•œ ë²”ìœ„ì—ì„œ ê°•í™” ì  ìŠ¤í°
            const playerCenterX = player.x + player.width / 2;
            const playerSpeed = currentPlayerSpeed;
            const enemySpeed = 1.5 + Math.random() * 1;
            const timeToReachPlayer = canvas.height / (enemySpeed * enemySpeedMultiplier);
            const maxPlayerMovement = playerSpeed * timeToReachPlayer;

            const minReachableX = Math.max(0, playerCenterX - maxPlayerMovement);
            const maxReachableX = Math.min(canvas.width, playerCenterX + maxPlayerMovement);

            const safetyMargin = 50;
            const spawnMinX = Math.max(0, minReachableX - safetyMargin);
            const spawnMaxX = Math.min(canvas.width - 40, maxReachableX + safetyMargin);

            const x = spawnMinX + Math.random() * (spawnMaxX - spawnMinX);
            enemies.push(new EliteEnemy(x, -45, hp));
        }

        function showBossMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2;

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #ff0000;
                font-size: 36px;
                font-weight: bold;
                z-index: 1001;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: bossWarning 2.5s ease-in-out;
            `;
            message.textContent = `âš ï¸ STAGE ${difficultyLevel} BOSS âš ï¸`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes bossWarning {
                    0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    10%, 90% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 2500);
        }

        function showStageClearMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2 - 50; // Slightly above center

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #00ff00;
                font-size: 32px;
                font-weight: bold;
                z-index: 1002;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: stageClear 1.8s ease-in-out;
            `;
            message.textContent = `ğŸ‰ STAGE ${difficultyLevel} CLEAR! ğŸ‰`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes stageClear {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 1800);
        }

        function showStageMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2 + 50; // Slightly below center

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #ffd700;
                font-size: 28px;
                font-weight: bold;
                z-index: 1000;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: stageUp 1.5s ease-in-out;
            `;
            message.textContent = `â­ STAGE ${difficultyLevel} â­`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes stageUp {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 1500);
        }
        
        function showDifficultyMessage() {
            // í™”ë©´ì— ì ê¹ ë‚œì´ë„ ì¦ê°€ ë©”ì‹œì§€ í‘œì‹œ
            const message = document.createElement('div');
            const isMaxLevel = difficultyLevel >= maxDifficultyLevel;
            message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${isMaxLevel ? '#ff0000' : '#ff6600'};
                font-size: ${isMaxLevel ? '32px' : '28px'};
                font-weight: bold;
                z-index: 1000;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                pointer-events: none;
            `;
            
            if (isMaxLevel) {
                message.textContent = 'ìµœê³  ë‚œì´ë„ ë‹¬ì„±!';
            } else {
                message.textContent = `ë‚œì´ë„ ${difficultyLevel}ë‹¨ê³„!`;
            }
            
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
            }, isMaxLevel ? 3000 : 2000);
        }
        
        function spawnKamikazeEnemy() {
            kamikazeActive = true;

            // í”Œë ˆì´ì–´ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ í™”ë©´ ê°€ì¥ìë¦¬ì—ì„œ ìŠ¤í°
            let spawnX, spawnY;
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            // ëœë¤í•˜ê²Œ 4ë°©í–¥ ì¤‘ í•˜ë‚˜ì—ì„œ ìŠ¤í°
            const side = Math.floor(Math.random() * 4);
            switch(side) {
                case 0: // ìœ„ìª½
                    spawnX = Math.random() * canvas.width;
                    spawnY = -50;
                    break;
                case 1: // ì•„ë˜ìª½
                    spawnX = Math.random() * canvas.width;
                    spawnY = canvas.height + 50;
                    break;
                case 2: // ì™¼ìª½
                    spawnX = -50;
                    spawnY = Math.random() * canvas.height;
                    break;
                case 3: // ì˜¤ë¥¸ìª½
                    spawnX = canvas.width + 50;
                    spawnY = Math.random() * canvas.height;
                    break;
            }

            kamikazeEnemy = new KamikazeEnemy(spawnX, spawnY, playerCenterX, playerCenterY);
            enemies.push(kamikazeEnemy);
        }

        function update() {
            if (!gameRunning || gamePaused) return;
            
            player.update();
            
            // Regular shooting logic - always fires regardless of bouncing effect
            if (Date.now() - lastShot > currentShotDelay) {
                // ê¸°ë³¸ ë”ë¸” ìƒ·
                bullets.push(new Bullet(player.x + player.width / 2 - 8, player.y - 5));
                bullets.push(new Bullet(player.x + player.width / 2 + 4, player.y - 5));
                lastShot = Date.now();
            }

            // Bouncing bullets - additional shots when bouncing effect is active
            if (bouncingActive) {
                if (Date.now() - lastBouncingShot > 800) {
                    bouncingBullets.push(new BouncingBullet(player.x + player.width / 2 - 2, player.y - 5));
                    lastBouncingShot = Date.now();
                }
            }
            
            // Sidekick shooting with individual item abilities
            sidekicks.forEach((sidekick, index) => {
                // ê° ì‚¬ì´ë“œí‚¥ì€ í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ì•„ì´í…œ íš¨ê³¼ë¥¼ ì‚¬ìš©
                const hasItem = playerItems.length > index;

                if (hasItem) {
                    const item = playerItems[index];
                    const isMultiShot = item.type === 'multiShot';
                    const isHoming = item.type === 'homing';
                    const isPierce = item.type === 'pierce';
                    const isRapidFire = item.type === 'rapidFire';
                    const isBouncing = item.type === 'bouncing';

                    // ê° ì•„ì´í…œ ìœ í˜•ë³„ ë°œì‚¬ ê°„ê²©
                    const baseDelay = 200;
                    let currentDelay = baseDelay;

                    if (isRapidFire) {
                        currentDelay = isHoming ? 230 : 70; // ì—°ì‚¬ + í˜¸ë°ì¡°í•©
                    } else if (isHoming) {
                        currentDelay = 670; // í˜¸ë°ë§Œ
                    }

                    // Regular bullets from sidekicks - always fire regardless of bouncing effect
                    if (Date.now() - sidekick.lastShot > currentDelay) {
                        if (isMultiShot) {
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 6, sidekick.y - 5, isHoming, isPierce));
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, isHoming, isPierce));
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 + 2, sidekick.y - 5, isHoming, isPierce));
                        } else {
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, isHoming, isPierce));
                        }
                        sidekick.lastShot = Date.now();
                    }

                    // Bouncing bullets from sidekicks - additional shots when bouncing effect is active
                    if (isBouncing && Date.now() - sidekick.lastBouncingShot > 1200) {
                        bouncingBullets.push(new BouncingBullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5));
                        sidekick.lastBouncingShot = Date.now();
                    }
                } else {
                    // ì•„ì´í…œì´ ì—†ëŠ” ì‚¬ì´ë“œí‚¥ì€ ê¸°ë³¸ ì´ì•Œ ë°œì‚¬
                    if (Date.now() - sidekick.lastShot > 200) {
                        sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, false, false));
                        sidekick.lastShot = Date.now();
                    }
                }
            });
            
            // Update sidekicks
            sidekicks.forEach(sidekick => {
                sidekick.update(player.x, player.y);
            });
            
            if (keys.z && specialGauge >= maxGauge && !specialAttackActive) {
                activateSpecialAttack();
            }
            
            bullets.forEach((bullet, bulletIndex) => {
                bullet.update();
                if (bullet.y < 0) {
                    bullets.splice(bulletIndex, 1);
                }
            });
            
            sidekickBullets.forEach((bullet, bulletIndex) => {
                bullet.update();
                if (bullet.y < 0) {
                    sidekickBullets.splice(bulletIndex, 1);
                }
            });

            bouncingBullets.forEach((bullet, bulletIndex) => {
                const shouldRemove = bullet.update();
                if (shouldRemove) {
                    bouncingBullets.splice(bulletIndex, 1);
                }
            });

            enemies.forEach((enemy, enemyIndex) => {
                const shouldRemove = enemy.update();
                if ((enemy.y > canvas.height && !enemy.isBoss && !enemy.isBossBullet) ||
                    (enemy.isUAPBullet && shouldRemove)) { // UAP ì´ì•Œì€ updateì—ì„œ ë°˜í™˜ë˜ëŠ” ê°’ìœ¼ë¡œ ì œê±° ê²°ì •
                    enemies.splice(enemyIndex, 1);
                }
                
                if (player.collidesWith(enemy)) {
                    if (enemy.isBossBullet || enemy.isUAPBullet) {
                        // ë³´ìŠ¤ íƒ„í™˜ ë˜ëŠ” UAP íƒ„í™˜ê³¼ ì¶©ëŒ - í”Œë ˆì´ì–´ ì£½ìŒ
                        enemies.splice(enemyIndex, 1);
                        gameOver();
                    } else if (enemy.isUAP) {
                        // UAP ì  ìì²´ì™€ ì¶©ëŒ - í”Œë ˆì´ì–´ëŠ” ì£½ì§€ ì•ŠìŒ (UAPëŠ” ì´ì•Œë¡œë§Œ ìœ„í—˜í•¨)
                        // UAPëŠ” ì œê±°ë˜ì§€ë„ ì•ŠìŒ
                    } else {
                        // ì¼ë°˜ ì  ë˜ëŠ” ë³´ìŠ¤ì™€ ì¶©ëŒ - í”Œë ˆì´ì–´ ì£½ìŒ
                        gameOver();
                    }
                }
                
                // Check sidekick collisions
                sidekicks.forEach((sidekick, sidekickIndex) => {
                    if (sidekick.collidesWith(enemy)) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        sidekicks.splice(sidekickIndex, 1);

                        if (enemy.isBoss) {
                            // ë³´ìŠ¤ëŠ” ì‚¬ì´ë“œí‚¥ ì¶©ëŒë¡œ ë°ë¯¸ì§€ë§Œ ì…ìŒ (ì¦‰ì‹œ ì£½ì§€ ì•ŠìŒ)
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else {
                            // ì¼ë°˜ ì ì€ ì¦‰ì‹œ ì œê±°
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ ì ìˆ˜ ì¦ê°€
                                score += 5;
                                updateScore();
                            }
                        }
                    }
                });
                
                bullets.forEach((bullet, bulletIndex) => {
                    if (bullet.collidesWith(enemy) && !bullet.hitEnemies.includes(enemy) &&
                        !enemy.isBossBullet && !enemy.isUAPBullet) { // ì´ì•Œë¥˜ëŠ” í”Œë ˆì´ì–´ ì´ì•Œê³¼ ì¶©ëŒí•˜ì§€ ì•ŠìŒ
                        if (enemy.isBoss) {
                            // ë³´ìŠ¤ëŠ” HP ì‹œìŠ¤í…œ ì‚¬ìš©
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }

                            if (enemy.takeDamage(2)) { // í”Œë ˆì´ì–´ ì´ì•Œ 2ë°° ë°ë¯¸ì§€
                                // ë³´ìŠ¤ ì²˜ì¹˜ë¨
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else if (enemy.isElite) {
                            // ê°•í™” ì ì€ HP ì‹œìŠ¤í…œ ì‚¬ìš©
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }

                            if (enemy.takeDamage(2)) { // í”Œë ˆì´ì–´ ì´ì•Œ 2ë°° ë°ë¯¸ì§€
                                // ê°•í™” ì  ì²˜ì¹˜ë¨
                                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                enemies.splice(enemyIndex, 1);
                                if (!bossActive) { // ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ ì ìˆ˜ ì¦ê°€
                                    score += 50; // ê°•í™” ì  ë³´ë„ˆìŠ¤
                                    updateScore();
                                }
                                specialGauge = Math.min(specialGauge + 10, maxGauge);
                                updateGauge();
                            }
                        } else {
                            // ì¼ë°˜ ì 
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ ì ìˆ˜ ì¦ê°€
                                score += 10;
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 5, maxGauge);
                            updateGauge();
                        }
                    }
                });
                
                sidekickBullets.forEach((bullet, bulletIndex) => {
                    if (bullet.collidesWith(enemy) && !enemy.isBossBullet && !enemy.isUAPBullet) { // ì´ì•Œë¥˜ëŠ” ì‚¬ì´ë“œí‚¥ ì´ì•Œê³¼ë„ ì¶©ëŒí•˜ì§€ ì•ŠìŒ
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        sidekickBullets.splice(bulletIndex, 1);

                        if (enemy.isBoss) {
                            // ë³´ìŠ¤ëŠ” ì‚¬ì´ë“œí‚¥ ì´ì•Œì—ë„ ë°ë¯¸ì§€ë§Œ ì…ìŒ
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else if (enemy.isElite) {
                            // ê°•í™” ì ë„ HP ì‹œìŠ¤í…œ ì‚¬ìš©
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                if (!bossActive) { // ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ ì ìˆ˜ ì¦ê°€
                                    score += 50;
                                    updateScore();
                                }
                                specialGauge = Math.min(specialGauge + 10, maxGauge);
                                updateGauge();
                            }
                        } else {
                            // ì¼ë°˜ ì ì€ ì¦‰ì‹œ ì œê±°
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ ì ìˆ˜ ì¦ê°€
                                score += 10;
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 3, maxGauge);
                            updateGauge();
                        }
                    }
                });

                bouncingBullets.forEach((bullet, bulletIndex) => {
                    if (bullet.collidesWith(enemy) && !bullet.hitEnemies.includes(enemy) && !enemy.isBossBullet && !enemy.isUAPBullet) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);

                        // Bouncing bullets can hit enemies multiple times like pierce bullets
                        bullet.hitEnemies.push(enemy);

                        if (enemy.isBoss) {
                            // ë³´ìŠ¤ëŠ” ë°”ìš´ì‹± ì´ì•Œì—ë„ ë°ë¯¸ì§€ ì…ìŒ
                            if (enemy.takeDamage(2)) { // ë°”ìš´ì‹± ì´ì•Œì€ í”Œë ˆì´ì–´ ì´ì•Œê³¼ ê°™ì€ ë°ë¯¸ì§€
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else if (enemy.isElite) {
                            // ê°•í™” ì ì€ HP ì‹œìŠ¤í…œ ì‚¬ìš©
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                score += 50; // ê°•í™” ì  ë³´ë„ˆìŠ¤
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 10, maxGauge);
                            updateGauge();
                        } else {
                            // ì¼ë°˜ ì ì€ ì¦‰ì‹œ ì œê±°
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ ì ìˆ˜ ì¦ê°€
                                score += 10;
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 3, maxGauge);
                            updateGauge();
                        }
                    }
                });
            });

            clouds.forEach(particle => particle.update());

            items.forEach((item, itemIndex) => {
                item.update();
                if (item.y > canvas.height) {
                    items.splice(itemIndex, 1);
                }
                
                if (player.collidesWith(item)) {
                    collectItem(item);
                    items.splice(itemIndex, 1);
                }
            });
            
            updateItemEffects();
            updateDifficulty();
            
            explosions.forEach((explosion, index) => {
                explosion.update();
                if (explosion.isDead()) {
                    explosions.splice(index, 1);
                }
            });
            
            if (specialAttackActive) {
                specialAttackTimer++;
                if (specialAttackTimer > 60) {
                    specialAttackActive = false;
                    specialAttackTimer = 0;
                }
            }

            // í™”ì—¼ ì›¨ì´ë¸Œ ì—…ë°ì´íŠ¸
            if (flameWaveActive) {
                updateFlameWave();
            }
            
            // ìŠ¤í…Œì´ì§€ë³„ ì  ìŠ¤í° ì†ë„ ì¦ê°€ (ë” ë¹ ë¥´ê²Œ)
            const baseSpawnRate = 60; // ê¸°ë³¸ ìŠ¤í° ê°„ê²© (120ì—ì„œ 60ìœ¼ë¡œ ë°˜ìœ¼ë¡œ ì¤„ì„)
            const currentSpawnRate = Math.max(15, baseSpawnRate - (difficultyLevel * 8)); // ìŠ¤í…Œì´ì§€ë§ˆë‹¤ 8í”„ë ˆì„ì”© ë¹¨ë¼ì§

            // ì  ìŠ¤í° ì¹´ìš´í„°
            enemySpawnTimer++;
            if (enemySpawnTimer % currentSpawnRate === 0) {
                // ìŠ¤í…Œì´ì§€ë³„ ì  ê°œìˆ˜ ì¦ê°€ (1-3ê°œ)
                const enemyCount = Math.min(3, Math.floor(difficultyLevel / 2) + 1);
                for (let i = 0; i < enemyCount; i++) {
                    const x = Math.random() * (canvas.width - 30);
                    enemies.push(new Enemy(x, -35));
                }
                enemySpawnTimer = 0;
            }

            // UAP ëœë¤ ìŠ¤í° (0.2% í™•ë¥ )
            if (Math.random() < 0.002 && gameRunning && !gamePaused) {
                enemies.push(new UAPEnemy());
            }

            itemSpawnTimer++;
            // ë‚œì´ë„ê°€ ë†’ì„ìˆ˜ë¡ ì•„ì´í…œ ìŠ¤í° ë¹ˆë„ ì¦ê°€
            const itemSpawnDelay = Math.max(150, 350 - (difficultyLevel * 15));
            if (itemSpawnTimer > itemSpawnDelay + Math.random() * 150) {
                spawnItem();
                itemSpawnTimer = 0;
            }
        }
        
        function draw() {
            // ë¯¸ë˜ë„ì‹œ ì¹¨ê³µ ë°°ê²½
            drawCityBackground();

            // ê±´ë¬¼ë“¤ê³¼ êµ¬ë¦„ íš¨ê³¼ ê·¸ë¦¬ê¸°
            clouds.forEach(particle => particle.draw());

            player.draw();
            bullets.forEach(bullet => bullet.draw());
            sidekickBullets.forEach(bullet => bullet.draw());
            bouncingBullets.forEach(bullet => bullet.draw());
            enemies.forEach(enemy => enemy.draw());
            items.forEach(item => item.draw());
            sidekicks.forEach(sidekick => sidekick.draw());
            explosions.forEach(explosion => explosion.draw());

            if (specialAttackActive) {
                drawSpecialAttackEffect();
            }
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // ê²Œì„ ì‹œì‘ ì‹œ 1ë‹¨ê³„ ì„¤ì • ì´ˆê¸°í™”
        function initializeGame() {
            difficultyLevel = 1;
            currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (1 * 3));
            currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + 1 * 0.03));
            currentShotDelay = Math.max(30, baseShotDelay - (1 * 3));
            enemySpeedMultiplier = Math.min(2.0, 1.0 + (1 * 0.05));
            updateEquippedItemsDisplay();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `ì ìˆ˜: ${score}`;
            // Update overlay score as well
            document.getElementById('overlayScore').textContent = `ì ìˆ˜: ${score}`;
        }

        function drawCityBackground() {
            // í‘¸ë¥¸ ë°”ë‹¤ ë°°ê²½ (ì¢Œì¸¡)ê³¼ ìœ¡ì§€ (ìš°ì¸¡)
            const seaGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            seaGradient.addColorStop(0, '#1e3a5f');     // ê¹Šì€ ë°”ë‹¤ìƒ‰
            seaGradient.addColorStop(0.4, '#2d4a6e');   // ì¤‘ê°„ ë°”ë‹¤ìƒ‰
            seaGradient.addColorStop(0.6, '#3a5a7d');   // ì—°í•œ ë°”ë‹¤ìƒ‰
            seaGradient.addColorStop(1, '#4a6a8d');     // í•´ì•ˆ ê·¼ì²˜

            ctx.fillStyle = seaGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ìœ¡ì§€ (í•´ì•ˆì„ ê³¼ ì„¬ë“¤)
            drawLandMasses();

            // ì „ìŸí„° ë°°ê²½
            drawBattlefield();

            // êµ°ì‚¬ ì‹œì„¤ - removed

            // ì •ì  í•´ì•ˆì„  íš¨ê³¼
            drawWaterEffects();
        }

        function drawLandMasses() {
            ctx.save();

            // ì¢Œì¸¡ì€ í‘¸ë¥¸ ë°”ë‹¤ (ë°°ê²½ ê·¸ë¼ë””ì–¸íŠ¸ë¡œ ì´ë¯¸ ì²˜ë¦¬ë¨)

            // ìš°ì¸¡ í•´ì•ˆì„  (ìœ¡ì§€)
            ctx.fillStyle = '#6a5a4a'; // ê°ˆìƒ‰ ìœ¡ì§€

            // ìš°ì¸¡ í•´ì•ˆì„  (ê³¡ì„ ìœ¼ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ)
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.65, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(canvas.width * 0.6, canvas.height);
            ctx.quadraticCurveTo(canvas.width * 0.62, canvas.height * 0.8, canvas.width * 0.64, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.66, canvas.height * 0.4, canvas.width * 0.63, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.65, canvas.height * 0.1, canvas.width * 0.65, 0);
            ctx.fill();

            // í•´ë³€ (ë°ì€ ëª¨ë˜ìƒ‰)
            ctx.fillStyle = '#d4c4a4';
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.65, 0);
            ctx.quadraticCurveTo(canvas.width * 0.62, canvas.height * 0.1, canvas.width * 0.6, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.63, canvas.height * 0.4, canvas.width * 0.61, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.59, canvas.height * 0.8, canvas.width * 0.6, canvas.height);
            ctx.lineTo(canvas.width * 0.62, canvas.height);
            ctx.quadraticCurveTo(canvas.width * 0.64, canvas.height * 0.8, canvas.width * 0.66, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.68, canvas.height * 0.4, canvas.width * 0.65, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.67, canvas.height * 0.1, canvas.width * 0.65, 0);
            ctx.fill();

            ctx.restore();
        }

        function drawBattlefield() {
            ctx.save();

            // ì „ìŸí„° ë°°ê²½ (ìš°ì¸¡ ìœ¡ì§€)

            // íŒŒê´´ëœ ê±´ë¬¼ë“¤ê³¼ íí—ˆ
            const ruins = [
                // íŒŒê´´ëœ ê³ ì¸µ ê±´ë¬¼ë“¤ (ë¶ˆê·œì¹™í•œ ëª¨ì–‘ìœ¼ë¡œ íŒŒê´´ë¨)
                {x: canvas.width * 0.68, y: canvas.height * 0.1, w: 25, h: 80, color: '#3a3a3a', destroyed: true},
                {x: canvas.width * 0.72, y: canvas.height * 0.25, w: 20, h: 60, color: '#4a4a4a', destroyed: true},
                {x: canvas.width * 0.75, y: canvas.height * 0.08, w: 30, h: 90, color: '#2a2a2a', destroyed: true},
                {x: canvas.width * 0.80, y: canvas.height * 0.22, w: 22, h: 70, color: '#5a5a5a', destroyed: true},
                {x: canvas.width * 0.84, y: canvas.height * 0.18, w: 18, h: 50, color: '#3a3a3a', destroyed: true},
                {x: canvas.width * 0.88, y: canvas.height * 0.24, w: 28, h: 65, color: '#4a4a4a', destroyed: true},

                // ì¤‘ê°„ í¬ê¸° íŒŒê´´ëœ ê±´ë¬¼ë“¤
                {x: canvas.width * 0.70, y: canvas.height * 0.45, w: 15, h: 30, color: '#4a4a4a', destroyed: true},
                {x: canvas.width * 0.74, y: canvas.height * 0.48, w: 18, h: 25, color: '#3a3a3a', destroyed: true},
                {x: canvas.width * 0.77, y: canvas.height * 0.42, w: 20, h: 35, color: '#5a5a5a', destroyed: true},
                {x: canvas.width * 0.82, y: canvas.height * 0.50, w: 16, h: 20, color: '#2a2a2a', destroyed: true},
                {x: canvas.width * 0.86, y: canvas.height * 0.46, w: 22, h: 30, color: '#4a4a4a', destroyed: true},

                // ì‘ì€ íŒŒê´´ëœ êµ¬ì¡°ë¬¼ë“¤
                {x: canvas.width * 0.69, y: canvas.height * 0.65, w: 12, h: 15, color: '#5a5a5a', destroyed: true},
                {x: canvas.width * 0.73, y: canvas.height * 0.68, w: 14, h: 12, color: '#3a3a3a', destroyed: true},
                {x: canvas.width * 0.76, y: canvas.height * 0.62, w: 16, h: 18, color: '#4a4a4a', destroyed: true},
                {x: canvas.width * 0.81, y: canvas.height * 0.70, w: 13, h: 10, color: '#2a2a2a', destroyed: true}
            ];

            // íŒŒê´´ëœ ê±´ë¬¼ë“¤ ê·¸ë¦¬ê¸°
            ruins.forEach(ruin => {
                // ê±´ë¬¼ ë³¸ì²´ (ë” ì–´ë‘¡ê³  ì†ìƒëœ ìƒ‰ìƒ)
                ctx.fillStyle = ruin.color;

                if (ruin.destroyed) {
                    // ë¶ˆê·œì¹™í•œ íŒŒê´´ëœ ëª¨ì–‘ ë§Œë“¤ê¸°
                    ctx.beginPath();
                    ctx.moveTo(ruin.x, ruin.y + ruin.h);
                    ctx.lineTo(ruin.x, ruin.y + ruin.h * 0.3);
                    ctx.lineTo(ruin.x + ruin.w * 0.3, ruin.y + ruin.h * 0.2);
                    ctx.lineTo(ruin.x + ruin.w * 0.7, ruin.y);
                    ctx.lineTo(ruin.x + ruin.w, ruin.y + ruin.h * 0.4);
                    ctx.lineTo(ruin.x + ruin.w, ruin.y + ruin.h);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.fillRect(ruin.x, ruin.y, ruin.w, ruin.h);
                }

                // íŒŒê´´ëœ ì°½ë¬¸ë“¤ (ë¶ˆíƒ€ëŠ” ì˜¤ë Œì§€/ë¹¨ê°„ ë¶ˆë¹›)
                if (Math.random() > 0.5) { // ì¼ë¶€ ê±´ë¬¼ë§Œ ë¶ˆíƒ€ê³  ìˆìŒ
                    ctx.fillStyle = '#ff4400';
                    for (let i = 0; i < 3; i++) {
                        const fireX = ruin.x + Math.random() * ruin.w * 0.8;
                        const fireY = ruin.y + Math.random() * ruin.h * 0.8;
                        ctx.fillRect(fireX, fireY, 2, 3);
                    }
                }
            });

            // í­íƒ„ êµ¬ë©ì´ë“¤ (í¬ë ˆì´í„°)
            ctx.fillStyle = '#1a1a1a';
            const craters = [
                {x: canvas.width * 0.71, y: canvas.height * 0.35, size: 8},
                {x: canvas.width * 0.79, y: canvas.height * 0.55, size: 12},
                {x: canvas.width * 0.85, y: canvas.height * 0.65, size: 6},
                {x: canvas.width * 0.73, y: canvas.height * 0.72, size: 10},
                {x: canvas.width * 0.87, y: canvas.height * 0.38, size: 7}
            ];

            craters.forEach(crater => {
                ctx.beginPath();
                ctx.arc(crater.x, crater.y, crater.size, 0, Math.PI * 2);
                ctx.fill();

                // í¬ë ˆì´í„° ê°€ì¥ìë¦¬ (ì•½ê°„ ë°ì€ ìƒ‰)
                ctx.strokeStyle = '#3a3a3a';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Zigzag trenches removed for cleaner battlefield look

            // ì—°ê¸° ê¸°ë‘¥ë“¤
            const smokeColumns = [
                {x: canvas.width * 0.74, y: canvas.height * 0.15, intensity: 0.8},
                {x: canvas.width * 0.81, y: canvas.height * 0.08, intensity: 0.6},
                {x: canvas.width * 0.89, y: canvas.height * 0.20, intensity: 0.9},
                {x: canvas.width * 0.70, y: canvas.height * 0.45, intensity: 0.5}
            ];

            smokeColumns.forEach(smoke => {
                const smokeAlpha = smoke.intensity * 0.4;
                ctx.fillStyle = `rgba(60, 60, 60, ${smokeAlpha})`;

                // ì—°ê¸° ê¸°ë‘¥ì„ ì—¬ëŸ¬ ê°œì˜ ì›ìœ¼ë¡œ ê·¸ë¦¬ê¸°
                for (let i = 0; i < 8; i++) {
                    const offsetX = Math.sin(i * 0.5) * 3;
                    const smokeY = smoke.y - i * 8;
                    const smokeSize = 4 + i * 0.8;

                    ctx.beginPath();
                    ctx.arc(smoke.x + offsetX, smokeY, smokeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // ë¶ˆíƒ€ëŠ” ì”í•´ë“¤
            const burningDebris = [
                {x: canvas.width * 0.69, y: canvas.height * 0.75, size: 4},
                {x: canvas.width * 0.77, y: canvas.height * 0.73, size: 3},
                {x: canvas.width * 0.83, y: canvas.height * 0.77, size: 5},
                {x: canvas.width * 0.91, y: canvas.height * 0.74, size: 3}
            ];

            burningDebris.forEach(debris => {
                // ë¶ˆíƒ€ëŠ” ì”í•´ (ì˜¤ë Œì§€-ë¹¨ê°• ê·¸ë¼ë””ì–¸íŠ¸)
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(debris.x, debris.y, debris.size, 0, Math.PI * 2);
                ctx.fill();

                // ë¶ˆê½ƒ íš¨ê³¼
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(debris.x, debris.y - 2, debris.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // Military base function removed

        function drawWaterEffects() {
            ctx.save();

            // ì •ì ì¸ ë¬¼ê²° íš¨ê³¼ (ì›€ì§ì´ì§€ ì•ŠìŒ)
            ctx.strokeStyle = 'rgba(150, 200, 180, 0.3)';
            ctx.lineWidth = 1;

            // í•´ì•ˆì„  ì •ì  ë¬¼ê²°
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                const waveY = canvas.height * 0.2 + i * 80;
                ctx.moveTo(0, waveY);

                for (let x = 0; x < canvas.width * 0.6; x += 20) {
                    const y = waveY + Math.sin(x * 0.1) * 3; // Date.now() ì œê±°
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            ctx.restore();
        }
        
        function updateGauge() {
            const percentage = (specialGauge / maxGauge) * 100;
            document.getElementById('gaugeFill').style.width = percentage + '%';
            document.getElementById('gaugeText').textContent = `í•„ì‚´ê¸° ê²Œì´ì§€: ${Math.floor(percentage)}%`;
            // Update overlay gauge as well
            document.getElementById('overlayGaugeFill').style.width = percentage + '%';
            document.getElementById('overlayGaugeText').textContent = `í•„ì‚´ê¸° ê²Œì´ì§€: ${Math.floor(percentage)}%`;

            // ëª¨ë°”ì¼ í•„ì‚´ê¸° ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            updateSpecialAttackButton();
        }
        
        function activateSpecialAttack() {
            specialAttackActive = true;
            specialGauge = 0;
            updateGauge();

            // í™”ì—¼ ì›¨ì´ë¸Œ ì‹œì‘
            startFlameWave();

            // ë³´ìŠ¤ë¥¼ ì œì™¸í•œ ì ë“¤ì—ê²Œë§Œ íŠ¹ìˆ˜ ê³µê²© ì ìš©
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);

                if (enemy.isBoss) {
                    // ë³´ìŠ¤ëŠ” íŠ¹ìˆ˜ ê³µê²©ìœ¼ë¡œ í° ë°ë¯¸ì§€ (HPì˜ 20%)
                    const damage = Math.max(1, Math.floor(enemy.maxHp * 0.2));
                    for (let d = 0; d < damage; d++) {
                        if (enemy.takeDamage()) {
                            enemies.splice(i, 1);
                            break;
                        }
                    }
                    if (!bossActive) { // ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ ì ìˆ˜ ì¦ê°€
                        score += 200; // ë³´ìŠ¤ì—ê²Œ ë°ë¯¸ì§€ë¥¼ ì¤€ ë³´ë„ˆìŠ¤
                    }
                } else {
                    // ì¼ë°˜ ì ì€ ì¦‰ì‹œ ì œê±°
                    enemies.splice(i, 1);
                    if (!bossActive) { // ë³´ìŠ¤ê°€ ì—†ì„ ë•Œë§Œ ì ìˆ˜ ì¦ê°€
                        score += 50;
                    }
                }
            }
            updateScore();
        }
        
        function createExplosion(x, y) {
            explosions.push(new Explosion(x, y));
        }
        
        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pauseScreen').style.display = gamePaused ? 'block' : 'none';
        }
        
        function handlePauseKey() {
            if (!pKeyPressed) {
                pKeyPressed = true;
                togglePause();
            }
        }
        
        function spawnItem() {
            const x = Math.random() * (canvas.width - 20);
            items.push(new Item(x, -20));
        }
        
        function collectItem(item) {
            if (playerItems.length < maxItems) {
                // ë¹ˆ ìŠ¬ë¡¯ì´ ìˆìœ¼ë©´ ì¶”ê°€
                playerItems.push({
                    type: item.type,
                    symbol: item.symbols[item.type],
                    color: item.colors[item.type]
                });
            } else {
                // ìŠ¬ë¡¯ì´ ê°€ë“ ì°¬ ê²½ìš° ì²« ë²ˆì§¸ ì•„ì´í…œ ì œê±°í•˜ê³  ìƒˆ ì•„ì´í…œ ì¶”ê°€
                const oldItem = playerItems.shift(); // ì²« ë²ˆì§¸ ì•„ì´í…œ ì œê±°
                deactivateItemEffect(oldItem.type);

                playerItems.push({
                    type: item.type,
                    symbol: item.symbols[item.type],
                    color: item.colors[item.type]
                });
            }

            updateInventoryUI();
            updateEquippedItemsDisplay();
            activateItemEffect(item.type);

            // Add sidekick when collecting item
            addSidekick();
        }

        function deactivateItemEffect(type) {
            switch(type) {
                case 'multiShot':
                    multiShotActive = false;
                    break;
                case 'rapidFire':
                    rapidFireActive = false;
                    currentShotDelay = Math.max(30, baseShotDelay - (difficultyLevel * 3));
                    break;
                case 'pierce':
                    pierceActive = false;
                    break;
                case 'homing':
                    homingActive = false;
                    break;
                case 'bouncing':
                    bouncingActive = false;
                    break;
            }
        }
        
        function addSidekick() {
            if (sidekicks.length < maxSidekicks) {
                const hasLeft = sidekicks.some(s => s.side === 'left');
                const hasRight = sidekicks.some(s => s.side === 'right');
                
                if (!hasLeft) {
                    sidekicks.push(new Sidekick('left'));
                } else if (!hasRight) {
                    sidekicks.push(new Sidekick('right'));
                }
            }
        }
        
        function activateItemEffect(type) {
            switch(type) {
                case 'multiShot':
                    multiShotActive = true;
                    itemEffectTimers.multiShot = 10000;
                    break;
                case 'rapidFire':
                    rapidFireActive = true;
                    itemEffectTimers.rapidFire = 10000;
                    // ì—°ì‚¬ ì•„ì´í…œ í™œì„±ì‹œ ì‡‡ ì†ë„ ì¬ê³„ì‚°
                    currentShotDelay = Math.max(15, baseShotDelay - (difficultyLevel * 3)) / 3;
                    break;
                case 'pierce':
                    pierceActive = true;
                    itemEffectTimers.pierce = 10000;
                    break;
                case 'homing':
                    homingActive = true;
                    itemEffectTimers.homing = 10000;
                    break;
                case 'bouncing':
                    bouncingActive = true;
                    itemEffectTimers.bouncing = 10000;
                    break;
            }
        }
        
        function updateItemEffects() {
            // ì•„ì´í…œ íš¨ê³¼ë¥¼ ì˜êµ¬ì ìœ¼ë¡œ ìœ ì§€ (ë‹¤ë¥¸ ì•„ì´í…œì„ ë¨¹ê¸° ì „ê¹Œì§€)
            // ì‹œê°„ ê¸°ë°˜ ë¹„í™œì„±í™” ì œê±°
        }
        
        function removeItemFromInventory(type) {
            playerItems = playerItems.filter(item => item.type !== type);
            updateInventoryUI();
            updateEquippedItemsDisplay();
        }
        
        function updateInventoryUI() {
            for (let i = 0; i < maxItems; i++) {
                const slot = document.getElementById(`slot${i}`);
                const overlaySlot = document.getElementById(`overlaySlot${i}`);
                if (i < playerItems.length) {
                    if (slot) {
                        slot.textContent = playerItems[i].symbol;
                        slot.style.color = playerItems[i].color;
                        slot.classList.add('filled');
                    }
                    // Update overlay slot as well (with null check)
                    if (overlaySlot) {
                        overlaySlot.textContent = playerItems[i].symbol;
                        overlaySlot.style.color = playerItems[i].color;
                        overlaySlot.classList.add('filled');
                    }
                } else {
                    if (slot) {
                        slot.textContent = '';
                        slot.classList.remove('filled');
                    }
                    // Update overlay slot as well (with null check)
                    if (overlaySlot) {
                        overlaySlot.textContent = '';
                        overlaySlot.classList.remove('filled');
                    }
                }
            }
        }

        function updateEquippedItemsDisplay() {
            const itemDescriptions = {
                multiShot: 'ë‹¤ì¤‘ ë°œì‚¬',
                rapidFire: 'ì—°ì‚¬ ê°•í™”',
                pierce: 'ê´€í†µ íƒ„í™˜',
                homing: 'ìœ ë„ ë¯¸ì‚¬ì¼',
                bouncing: 'ë°”ìš´ì‹± íƒ„í™˜'
            };

            const equippedItemsList = document.getElementById('equippedItemsList');
            equippedItemsList.innerHTML = '';

            if (playerItems.length === 0) {
                const noItemsDiv = document.createElement('div');
                noItemsDiv.style.color = '#888888';
                noItemsDiv.style.textAlign = 'center';
                noItemsDiv.style.fontStyle = 'italic';
                noItemsDiv.textContent = 'ì•„ì´í…œ ì—†ìŒ';
                equippedItemsList.appendChild(noItemsDiv);
                return;
            }

            playerItems.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'equipped-item';

                const symbolDiv = document.createElement('div');
                symbolDiv.className = 'equipped-item-symbol';
                symbolDiv.textContent = item.symbol;
                symbolDiv.style.backgroundColor = item.color;
                symbolDiv.style.color = '#ffffff';

                const descDiv = document.createElement('div');
                descDiv.className = 'equipped-item-desc';
                descDiv.textContent = itemDescriptions[item.type] || item.type;

                itemDiv.appendChild(symbolDiv);
                itemDiv.appendChild(descDiv);
                equippedItemsList.appendChild(itemDiv);
            });
        }

        function startFlameWave() {
            flameWaveActive = true;
            flameWaveHeight = 0;
            flameWave = [];

            // í™”ì—¼ íŒŒí‹°í´ ìƒì„±
            for (let i = 0; i < 100; i++) {
                flameWave.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + Math.random() * 50,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -8 - Math.random() * 12,
                    size: 3 + Math.random() * 8,
                    life: 1.0,
                    color: Math.random() < 0.7 ? 'orange' : 'red'
                });
            }
        }

        function updateFlameWave() {
            if (!flameWaveActive) return;

            flameWaveHeight += 15;

            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            flameWave.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                particle.size *= 0.98;

                // ë°”ëŒ íš¨ê³¼
                particle.vx += (Math.random() - 0.5) * 0.5;
            });

            // ì£½ì€ íŒŒí‹°í´ ì œê±°
            flameWave = flameWave.filter(particle => particle.life > 0 && particle.size > 0.5);

            // ìƒˆë¡œìš´ íŒŒí‹°í´ ì¶”ê°€
            if (flameWaveHeight < canvas.height + 100) {
                for (let i = 0; i < 5; i++) {
                    flameWave.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height - flameWaveHeight + Math.random() * 30,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -5 - Math.random() * 15,
                        size: 4 + Math.random() * 10,
                        life: 1.0,
                        color: Math.random() < 0.6 ? 'orange' : Math.random() < 0.8 ? 'red' : 'yellow'
                    });
                }
            }

            // íš¨ê³¼ ì¢…ë£Œ ì²´í¬
            if (flameWaveHeight > canvas.height + 150 && flameWave.length === 0) {
                flameWaveActive = false;
            }
        }

        function drawFlameWave() {
            if (!flameWaveActive) return;

            // í™”ì—¼ ë² ì´ìŠ¤ ê·¸ë¼ë””ì–¸íŠ¸
            const flameGradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - flameWaveHeight);
            flameGradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
            flameGradient.addColorStop(0.3, 'rgba(255, 150, 0, 0.6)');
            flameGradient.addColorStop(0.7, 'rgba(255, 200, 0, 0.3)');
            flameGradient.addColorStop(1, 'transparent');

            ctx.fillStyle = flameGradient;
            ctx.fillRect(0, canvas.height - flameWaveHeight, canvas.width, flameWaveHeight);

            // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            flameWave.forEach(particle => {
                if (particle.life > 0) {
                    ctx.globalAlpha = particle.life;

                    const colors = {
                        orange: `hsl(${30 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`,
                        red: `hsl(${0 + Math.random() * 20}, 100%, ${50 + Math.random() * 30}%)`,
                        yellow: `hsl(${50 + Math.random() * 20}, 100%, ${60 + Math.random() * 30}%)`
                    };

                    ctx.fillStyle = colors[particle.color];
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, 2 * Math.PI);
                    ctx.fill();

                    // ê¸€ë¡œìš° íš¨ê³¼
                    ctx.shadowColor = colors[particle.color];
                    ctx.shadowBlur = particle.size * 2;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            ctx.globalAlpha = 1.0;

            // í•„ì‚´ê¸° í…ìŠ¤íŠ¸
            ctx.fillStyle = 'white';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 10;
            ctx.fillText('í™”ì—¼ í­í’!', canvas.width / 2, 100);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'left';
        }

        function drawSpecialAttackEffect() {
            // ê¸°ì¡´ ë²ˆì©ì„ ì œê±°, í™”ì—¼ ì›¨ì´ë¸Œë¡œ ëŒ€ì²´
            drawFlameWave();
        }
        
        function gameOver() {
            gameRunning = false;
            showRankingInput();
        }
        
        function restartGame() {
            gameRunning = true;
            gamePaused = false;
            score = 0;
            difficultyLevel = 1;
            currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (1 * 3));
            currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + 1 * 0.03));
            currentShotDelay = Math.max(30, baseShotDelay - (1 * 3));
            enemySpeedMultiplier = Math.min(2.0, 1.0 + (1 * 0.05));
            specialGauge = 0;
            specialAttackActive = false;
            specialAttackTimer = 0;
            playerItems = [];
            multiShotActive = false;
            rapidFireActive = false;
            pierceActive = false;
            homingActive = false;
            bouncingActive = false;
            itemEffectTimers = {
                multiShot: 0,
                rapidFire: 0,
                pierce: 0,
                homing: 0,
                bouncing: 0
            };
            bullets.length = 0;
            sidekickBullets.length = 0;
            bouncingBullets.length = 0;
            enemies.length = 0;
            items.length = 0;
            sidekicks.length = 0;
            explosions.length = 0;
            itemSpawnTimer = 0;
            lastShot = 0;
            lastBouncingShot = 0;
            lastSidekickShot = 0;
            bossActive = false;
            currentBoss = null;
            player.x = canvas.width / 2 - 20;
            player.y = canvas.height - 60;
            updateScore();
            updateGauge();
            updateInventoryUI();
            updateEquippedItemsDisplay();
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
        }
        
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = true;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    keys.right = true;
                    e.preventDefault();
                    break;
                case 'ArrowUp':
                    keys.up = true;
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    keys.down = true;
                    e.preventDefault();
                    break;
                case 'Space':
                    keys.space = true;
                    e.preventDefault();
                    break;
                case 'KeyZ':
                    keys.z = true;
                    e.preventDefault();
                    break;
                case 'KeyP':
                    handlePauseKey();
                    e.preventDefault();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'ArrowUp':
                    keys.up = false;
                    break;
                case 'ArrowDown':
                    keys.down = false;
                    break;
                case 'Space':
                    keys.space = false;
                    break;
                case 'KeyZ':
                    keys.z = false;
                    break;
                case 'KeyP':
                    pKeyPressed = false;
                    break;
            }
        });

        // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë“¤
        function initMobileControls() {
            const canvas = document.getElementById('gameCanvas');
            const specialAttackBtn = document.getElementById('specialAttackBtn');

            // ìº”ë²„ìŠ¤ í„°ì¹˜ ì´ë²¤íŠ¸ - ì´ë™ ë° ë°œì‚¬
            let touchActive = false;
            let lastTouchX = 0;
            let lastTouchY = 0;

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();

                touchActive = true;
                lastTouchX = touch.clientX - rect.left;
                lastTouchY = touch.clientY - rect.top;

                // ìë™ ë°œì‚¬ ì‹œì‘
                keys.space = true;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!touchActive || !gameRunning) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();

                const currentTouchX = touch.clientX - rect.left;
                const currentTouchY = touch.clientY - rect.top;

                // í„°ì¹˜ ìœ„ì¹˜ë¥¼ ê²Œì„ ì¢Œí‘œë¡œ ë³€í™˜
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                const gameX = currentTouchX * scaleX;
                const gameY = currentTouchY * scaleY;

                // í”Œë ˆì´ì–´ë¥¼ í„°ì¹˜ ìœ„ì¹˜ë¡œ ì´ë™ (ê²½ê³„ ì²´í¬ í¬í•¨)
                if (player) {
                    const targetX = gameX - player.width / 2;
                    const targetY = gameY - player.height / 2;

                    // ê²½ê³„ ì²´í¬
                    player.x = Math.max(0, Math.min(canvas.width - player.width, targetX));
                    player.y = Math.max(0, Math.min(canvas.height - player.height, targetY));
                }

                lastTouchX = currentTouchX;
                lastTouchY = currentTouchY;
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchActive = false;

                // ë°œì‚¬ ì¤‘ì§€
                keys.space = false;

                // ëª¨ë“  ë°©í–¥í‚¤ í•´ì œ
                keys.left = false;
                keys.right = false;
                keys.up = false;
                keys.down = false;
            });

            // í•„ì‚´ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
            specialAttackBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (specialGauge >= 100) {
                    keys.z = true;
                    touchControls.specialAttack = true;
                    specialAttackBtn.classList.add('btn-pressed');
                }
            });

            specialAttackBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.z = false;
                touchControls.specialAttack = false;
                specialAttackBtn.classList.remove('btn-pressed');
            });
        }

        // í•„ì‚´ê¸° ê²Œì´ì§€ì— ë”°ë¥¸ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateSpecialAttackButton() {
            const specialAttackBtn = document.getElementById('specialAttackBtn');
            if (specialAttackBtn) {
                if (specialGauge >= 100) {
                    specialAttackBtn.classList.add('show');
                } else {
                    specialAttackBtn.classList.remove('show');
                }
            }
        }

        // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì´ˆê¸°í™”
        if (isMobile) {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initMobileControls);
            } else {
                initMobileControls();
            }
        }

        // ë­í‚¹ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
        function loadRankings() {
            // ê¸€ë¡œë²Œ ëª…ì˜ˆì˜ ì „ë‹¹ - ì‹¤ì œ í”Œë ˆì´ì–´ ê¸°ë¡ë§Œ í‘œì‹œ
            const globalRankings = [];

            const saved = localStorage.getItem('galaxyShooterRankings');
            let localRankings = [];
            if (saved) {
                localRankings = JSON.parse(saved);
            }

            // ê¸€ë¡œë²Œ ë­í‚¹ê³¼ ë¡œì»¬ ë­í‚¹ì„ í•©ì¹˜ê³  ì •ë ¬
            rankings = [...globalRankings, ...localRankings];
            rankings.sort((a, b) => b.score - a.score);
            rankings = rankings.slice(0, maxRankings);

            updateLiveRankings(); // ë­í‚¹ ë¡œë“œ í›„ í‘œì‹œ ì—…ë°ì´íŠ¸
        }

        function updateLiveRankings() {
            const rankingContainer = document.getElementById('liveRankingList');
            if (!rankingContainer) return;

            rankingContainer.innerHTML = '';

            if (rankings.length === 0) {
                rankingContainer.innerHTML = `
                    <div class="ranking-item">
                        <span class="ranking-rank">1</span>
                        <div>
                            <div class="ranking-score">ê¸°ë¡ ì—†ìŒ</div>
                            <div class="ranking-date">ê²Œì„ì„ ì‹œì‘í•´ë³´ì„¸ìš”!</div>
                        </div>
                    </div>
                `;
                // Update last updated date even when no rankings
                updateLastUpdatedDate();
                return;
            }

            rankings.slice(0, 5).forEach((ranking, index) => {
                const medalIcons = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
                const medal = index < 3 ? medalIcons[index] : `${index + 1}`;

                rankingContainer.innerHTML += `
                    <div class="ranking-item">
                        <span class="ranking-rank">${medal}</span>
                        <div>
                            <div class="ranking-score">${ranking.score.toLocaleString()}ì </div>
                            <div class="ranking-date">${ranking.name} | Stage ${ranking.stage}</div>
                        </div>
                    </div>
                `;
            });

            // Update the last updated date
            updateLastUpdatedDate();
        }

        function updateLastUpdatedDate() {
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                const now = new Date();
                const koreanDate = now.toLocaleDateString('ko-KR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                lastUpdatedElement.textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${koreanDate}`;
            }
        }

        function saveRankings() {
            localStorage.setItem('galaxyShooterRankings', JSON.stringify(rankings));
        }

        function addRanking(name, score, stage) {
            const newRecord = {
                name: name || 'ë¬´ëª…',
                score: score,
                stage: stage,
                date: new Date().toLocaleDateString('ko-KR')
            };

            rankings.push(newRecord);
            rankings.sort((a, b) => b.score - a.score);
            rankings = rankings.slice(0, maxRankings);
            saveRankings();
            updateLiveRankings(); // ì‹¤ì‹œê°„ ë­í‚¹ ì—…ë°ì´íŠ¸
            return newRecord;
        }

        function showRankingInput() {
            document.getElementById('finalScore').textContent = `ìµœì¢… ì ìˆ˜: ${score}ì  (${difficultyLevel}ë‹¨ê³„)`;
            document.getElementById('rankingModal').style.display = 'block';
            document.getElementById('nameInput').focus();
            displayRankings(null);
        }

        function saveScore() {
            const name = document.getElementById('nameInput').value.trim();
            const newRecord = addRanking(name, score, difficultyLevel);
            document.getElementById('nameInputSection').style.display = 'none';
            displayRankings(newRecord);
        }

        function displayRankings(newRecord) {
            // ìš°ì¸¡ íŒ¨ë„ë„ ì—…ë°ì´íŠ¸
            updateLiveRankings();

            const rankingList = document.getElementById('rankingList');
            rankingList.innerHTML = '<h3 style="color: #00ffff; text-align: center; margin-bottom: 15px;">ğŸ… ëª…ì˜ˆì˜ ì „ë‹¹ ğŸ…</h3>';

            if (rankings.length === 0) {
                rankingList.innerHTML += '<div style="text-align: center; color: #999;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            rankings.forEach((ranking, index) => {
                const isNew = newRecord && ranking === newRecord;
                const rankElement = document.createElement('div');
                rankElement.className = `rankingItem ${isNew ? 'newRecord' : ''}`;

                const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;

                rankElement.innerHTML = `
                    <div>
                        <span style="display: inline-block; width: 30px;">${medal}</span>
                        <strong>${ranking.name}</strong>
                        <span style="margin-left: 10px; color: #aaa; font-size: 12px;">${ranking.date}</span>
                    </div>
                    <div>
                        <span style="color: #ffd700;">${ranking.score}ì </span>
                        <span style="margin-left: 10px; color: #00ffff;">${ranking.stage}ë‹¨ê³„</span>
                    </div>
                `;

                rankingList.appendChild(rankElement);
            });

            // ìƒˆë¡œìš´ ê¸°ë¡ì´ ì¶”ê°€ëœ ê²½ìš° ì¶•í•˜ ë©”ì‹œì§€ì™€ ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼ í‘œì‹œ
            if (newRecord) {
                const congratsElement = document.createElement('div');
                congratsElement.style.cssText = 'text-align: center; margin-top: 20px; padding: 15px; background: rgba(0, 255, 255, 0.1); border-radius: 8px; border: 1px solid #00ffff;';
                congratsElement.innerHTML = `
                    <div style="color: #00ffff; font-size: 18px; margin-bottom: 10px;">ğŸ‰ ê¸°ë¡ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰</div>
                    <button onclick="restartGameFromModal()" style="
                        font-size: 18px;
                        padding: 12px 24px;
                        background: #00ffff;
                        color: #000;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: bold;
                        margin: 5px;
                    ">ğŸš€ ë‹¤ì‹œ ì‹œì‘</button>
                    <button onclick="closeRanking()" style="
                        font-size: 16px;
                        padding: 10px 20px;
                        background: #666;
                        color: #fff;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        margin: 5px;
                    ">ë‹«ê¸°</button>
                `;
                rankingList.appendChild(congratsElement);
            }
        }

        function closeRanking() {
            document.getElementById('rankingModal').style.display = 'none';
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGameFromModal() {
            // ëª¨ë‹¬ ë‹«ê¸°
            document.getElementById('rankingModal').style.display = 'none';
            // ê²Œì„ ì˜¤ë²„ í™”ë©´ ìˆ¨ê¸°ê¸°
            document.getElementById('gameOver').style.display = 'none';
            // ì´ë¦„ ì…ë ¥ ì„¹ì…˜ ë‹¤ì‹œ ë³´ì´ê¸° (ë‹¤ìŒ ê²Œì„ì„ ìœ„í•´)
            document.getElementById('nameInputSection').style.display = 'block';
            document.getElementById('nameInput').value = '';
            // ê²Œì„ ì¬ì‹œì‘
            restartGame();
        }

        // Enter í‚¤ë¡œ ì´ë¦„ ì €ì¥
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('nameInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    saveScore();
                }
            });
        });

        console.log("Starting game...");
        try {
            loadRankings();
            console.log("Rankings loaded");
            initializeGame();
            console.log("Game initialized");
            gameLoop();
            console.log("Game loop started");
        } catch (error) {
            console.error("Game initialization error:", error);
        }
    </script>
</body>
</html>