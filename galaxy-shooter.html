<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Í∞§Îü≠Ïãú ÎπÑÌñâÍ∏∞ Í≤åÏûÑ</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            gap: 30px;
        }

        #gameContainer {
            text-align: center;
        }

        #rankingContainer {
            width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            color: white;
            backdrop-filter: blur(10px);
        }

        #rankingTitle {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 4px solid #FFD700;
        }

        .ranking-rank {
            font-weight: bold;
            font-size: 18px;
            color: #FFD700;
            min-width: 30px;
        }

        .ranking-score {
            font-size: 16px;
            font-weight: bold;
        }

        .ranking-date {
            font-size: 12px;
            color: #aaa;
        }

        .ranking-item:nth-child(1) .ranking-rank { color: #FFD700; }
        .ranking-item:nth-child(2) .ranking-rank { color: #C0C0C0; }
        .ranking-item:nth-child(3) .ranking-rank { color: #CD7F32; }
        
        canvas {
            border: 2px solid #333;
            background: linear-gradient(to bottom, #001122, #000033);
        }
        
        #ui {
            color: white;
            margin-top: 10px;
        }
        
        #score {
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        #gaugeContainer {
            margin-bottom: 10px;
        }
        
        #gauge {
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            background: #333;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        
        #gaugeFill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
            width: 0%;
            transition: width 0.2s;
        }
        
        #gaugeText {
            color: white;
            font-size: 14px;
            margin-top: 5px;
        }
        
        #inventory {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .item-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #666;
            background: #222;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .item-slot.filled {
            border-color: #00ff00;
            background: #004400;
        }
        
        #gameOver {
            display: none;
            color: red;
            font-size: 24px;
            margin-top: 20px;
        }

        #rankingModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        #rankingContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #0f3460;
            border-radius: 10px;
            padding: 30px;
            color: white;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        #nameInput {
            background: #2a2a4e;
            border: 2px solid #0080ff;
            color: white;
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            margin: 10px;
            text-align: center;
        }

        #nameInput:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #rankingList {
            margin: 20px 0;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
        }

        .rankingItem {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border-left: 4px solid #00ffff;
        }

        .rankingItem.newRecord {
            background: rgba(255, 215, 0, 0.2);
            border-left-color: #ffd700;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }
        
        #pauseScreen {
            display: none;
            color: white;
            font-size: 24px;
            margin-top: 20px;
        }
        
        button {
            background: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
        }
        
        button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div id="score">Ï†êÏàò: 0</div>
            <div id="gaugeContainer">
                <div id="gauge">
                    <div id="gaugeFill"></div>
                </div>
                <div id="gaugeText">ÌïÑÏÇ¥Í∏∞ Í≤åÏù¥ÏßÄ: 0%</div>
            </div>
            <div id="inventory">
                <div class="item-slot" id="slot0"></div>
                <div class="item-slot" id="slot1"></div>
            </div>
            <div>Î∞©Ìñ•ÌÇ§Î°ú Ïù¥Îèô, ZÌÇ§Î°ú ÌïÑÏÇ¥Í∏∞, PÌÇ§Î°ú ÏùºÏãúÏ†ïÏßÄ</div>
            <div style="font-size: 12px; color: #aaa; margin-top: 5px;">‚ö†Ô∏è 5Ï¥àÍ∞Ñ Í∞ÄÎßåÌûà ÏûàÏúºÎ©¥ Ïπ¥ÎØ∏Ïπ¥Ï†ú Ï†ÅÍµ∞ Ï∂úÌòÑ!</div>
            <div id="pauseScreen">
                <div>Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ</div>
                <div style="font-size: 16px; margin-top: 10px;">PÌÇ§Î•º ÎàåÎü¨ Í≥ÑÏÜç</div>
            </div>
            <div id="gameOver">
                <div>Í≤åÏûÑ Ïò§Î≤Ñ!</div>
                <button onclick="restartGame()">Îã§Ïãú ÏãúÏûë</button>
            </div>
        </div>
    </div>

    <div id="rankingModal">
        <div id="rankingContent">
            <h2 style="color: #00ffff; margin-bottom: 20px;">üèÜ Í≤åÏûÑ Í≤∞Í≥º üèÜ</h2>
            <div id="finalScore" style="font-size: 24px; color: #ffd700; margin-bottom: 20px;"></div>
            <div id="nameInputSection">
                <div style="margin-bottom: 10px;">Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:</div>
                <input type="text" id="nameInput" maxlength="10" placeholder="ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶Ñ">
                <br>
                <button onclick="saveScore()" style="margin-top: 15px;">Í∏∞Î°ù Ï†ÄÏû•</button>
            </div>
            <div id="rankingList"></div>
            <div style="margin-top: 20px;">
                <button onclick="closeRanking()">Îã´Í∏∞</button>
                <button onclick="restartGame()">Îã§Ïãú ÏãúÏûë</button>
            </div>
        </div>
    </div>

    <div id="rankingContainer">
        <div id="rankingTitle">üèÜ Î™ÖÏòàÏùò Ï†ÑÎãπ üèÜ</div>
        <div id="liveRankingList">
            <div class="ranking-item">
                <span class="ranking-rank">1</span>
                <div>
                    <div class="ranking-score">Í∏∞Î°ù ÏóÜÏùå</div>
                    <div class="ranking-date">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameRunning = true;
        let gamePaused = false;
        let score = 0;
        let specialGauge = 0;
        let maxGauge = 100;
        let specialAttackActive = false;
        let specialAttackTimer = 0;
        let playerItems = [];
        let maxItems = 2;
        let multiShotActive = false;
        let rapidFireActive = false;
        let pierceActive = false;
        let homingActive = false;
        let itemEffectTimers = {
            multiShot: 0,
            rapidFire: 0,
            pierce: 0,
            homing: 0
        };
        let sidekicks = [];
        let maxSidekicks = 2;
        let lastSidekickShot = 0;
        let explosions = [];
        let difficultyLevel = 1;
        let maxDifficultyLevel = 999;
        let rankings = [];
        let maxRankings = 10;
        let lastMovementTime = 0;
        let idleThreshold = 5000; // 5Ï¥à
        let kamikazeActive = false;
        let kamikazeEnemy = null;
        let playerLastX = 0;
        let playerLastY = 0;
        let bossActive = false;
        let currentBoss = null;
        let lastStage = 0;
        let flameWave = [];
        let flameWaveActive = false;
        let flameWaveHeight = 0;
        let baseEnemySpawnRate = 45;
        let currentEnemySpawnRate = 42;
        let basePlayerSpeed = 5;
        let currentPlayerSpeed = 5.15;
        let baseShotDelay = 60;
        let currentShotDelay = 57;
        let enemySpeedMultiplier = 1.05;
        
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false,
            space: false,
            z: false
        };
        
        let pKeyPressed = false;
        
        class GameObject {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            
            collidesWith(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }
        
        class Player extends GameObject {
            constructor() {
                super(canvas.width / 2 - 20, canvas.height - 60, 40, 50, '#00ff00');
                this.baseSpeed = 5;
                this.autoPilotTargetX = this.x;
                this.autoPilotTargetY = this.y;
            }
            
            update() {
                const speed = currentPlayerSpeed;
                let moved = false;

                if (keys.left && this.x > 0) {
                    this.x -= speed;
                    moved = true;
                }
                if (keys.right && this.x < canvas.width - this.width) {
                    this.x += speed;
                    moved = true;
                }
                if (keys.up && this.y > 0) {
                    this.y -= speed;
                    moved = true;
                }
                if (keys.down && this.y < canvas.height - this.height) {
                    this.y += speed;
                    moved = true;
                }

                // ÏõÄÏßÅÏûÑ Í∞êÏßÄ (Ïπ¥ÎØ∏Ïπ¥Ï†ú Ï†ÅÏùÄ Ï†úÍ±∞ÌïòÏßÄ ÏïäÏùå)
                if (moved || this.x !== playerLastX || this.y !== playerLastY) {
                    lastMovementTime = Date.now();
                    playerLastX = this.x;
                    playerLastY = this.y;
                }

                // Ïπ¥ÎØ∏Ïπ¥Ï†ú Ï†Å Ïä§Ìè∞ Ï≤¥ÌÅ¨ (ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Í∞ÄÎßåÌûà ÏûàÏúºÎ©¥ Í≥ÑÏÜç Ïä§Ìè∞)
                if (Date.now() - lastMovementTime > idleThreshold) {
                    // 3Ï¥àÎßàÎã§ ÏÉàÎ°úÏö¥ Ïπ¥ÎØ∏Ïπ¥Ï†ú Ï†Å Ïä§Ìè∞
                    if (Date.now() - lastMovementTime > idleThreshold && (Date.now() - lastMovementTime) % 3000 < 100) {
                        spawnKamikazeEnemy();
                    }
                }
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                ctx.save();

                // ÌòÑÎåÄÏãù Ï†ÑÌà¨Í∏∞ Ïä§ÌÉÄÏùº (F-22 Îû©ÌÑ∞ Í∞ôÏùÄ ÎäêÎÇå)

                // Ï†úÌä∏ ÏóîÏßÑ Î∞∞Í∏∞ (Ïù¥Ï§ë ÏóîÏßÑ)
                const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 12);
                exhaustGradient.addColorStop(0, '#0099ff');
                exhaustGradient.addColorStop(0.3, '#0066cc');
                exhaustGradient.addColorStop(0.7, '#004499');
                exhaustGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = exhaustGradient;
                // Ïù¥Ï§ë Ï†úÌä∏ ÏóîÏßÑ
                ctx.fillRect(centerX - 6, this.y + this.height, 4, 12);
                ctx.fillRect(centerX + 2, this.y + this.height, 4, 12);

                // Î©îÏù∏ ÎèôÏ≤¥ (Ïä§ÌÖîÏä§ ÌöåÏÉâ)
                const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                fuselageGradient.addColorStop(0, '#4a4a5a');
                fuselageGradient.addColorStop(0.5, '#5a5a6a');
                fuselageGradient.addColorStop(1, '#4a4a5a');

                ctx.fillStyle = fuselageGradient;
                ctx.fillRect(centerX - 10, this.y + 8, 20, 36);

                // Îç∏ÌÉÄ ÎÇ†Í∞ú (Ïä§ÌÖîÏä§ ÌòïÌÉú)
                const wingGradient = ctx.createLinearGradient(this.x - 22, centerY, this.x + this.width + 22, centerY);
                wingGradient.addColorStop(0, '#5a5a6a');
                wingGradient.addColorStop(0.5, '#6a6a7a');
                wingGradient.addColorStop(1, '#5a5a6a');

                ctx.fillStyle = wingGradient;

                // Ï¢åÏ∏° Îç∏ÌÉÄ ÎÇ†Í∞ú (ÏÇºÍ∞ÅÌòï Î™®Ïñë)
                ctx.beginPath();
                ctx.moveTo(this.x - 20, this.y + 30);
                ctx.lineTo(centerX - 8, this.y + 18);
                ctx.lineTo(centerX - 8, this.y + 26);
                ctx.closePath();
                ctx.fill();

                // Ïö∞Ï∏° Îç∏ÌÉÄ ÎÇ†Í∞ú
                ctx.beginPath();
                ctx.moveTo(this.x + this.width + 20, this.y + 30);
                ctx.lineTo(centerX + 8, this.y + 18);
                ctx.lineTo(centerX + 8, this.y + 26);
                ctx.closePath();
                ctx.fill();

                // Í∏∞Ïàò (Ïä§ÌÖîÏä§ Í∞ÅÏßÑ ÌòïÌÉú)
                const noseGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + 15);
                noseGradient.addColorStop(0, '#6a6a7a');
                noseGradient.addColorStop(1, '#5a5a6a');

                ctx.fillStyle = noseGradient;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX - 8, this.y + 12);
                ctx.lineTo(centerX + 8, this.y + 12);
                ctx.closePath();
                ctx.fill();

                // Ï°∞Ï¢ÖÏÑù (Ïñ¥ÎëêÏö¥ Ï∫êÎÖ∏Ìîº)
                ctx.fillStyle = '#1a1a2a';
                ctx.fillRect(centerX - 4, this.y + 10, 8, 12);

                // Î†àÏù¥Îçî Ìù°Ïàò Ïû¨Î£å ÎîîÌÖåÏùº
                ctx.strokeStyle = '#3a3a4a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX - 8, this.y + 15);
                ctx.lineTo(centerX + 8, this.y + 15);
                ctx.moveTo(centerX - 8, this.y + 25);
                ctx.lineTo(centerX + 8, this.y + 25);
                ctx.stroke();

                // ÌòÑÎåÄÏãù ÎßàÌÇπ (Î≥ÑÍ≥º Î∞î)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(centerX - 8, this.y + 30, 4, 2);
                ctx.fillRect(centerX + 4, this.y + 30, 4, 2);

                ctx.fillStyle = '#0066cc';
                ctx.fillRect(centerX - 7, this.y + 30.5, 2, 1);
                ctx.fillRect(centerX + 5, this.y + 30.5, 2, 1);

                // ÎØ∏ÏÇ¨Ïùº ÌïòÎìúÌè¨Ïù∏Ìä∏
                ctx.fillStyle = '#666';
                ctx.fillRect(this.x - 18, this.y + 25, 3, 2);
                ctx.fillRect(this.x + this.width + 15, this.y + 25, 3, 2);

                // Í≥µÍ∏∞ Ìù°ÏûÖÍµ¨
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(centerX - 8, this.y + 20, 3, 6);
                ctx.fillRect(centerX + 5, this.y + 20, 3, 6);

                ctx.restore();
            }
        }
        
        class Bullet extends GameObject {
            constructor(x, y, isHoming = false, isPierce = false) {
                super(x, y, 4, 10, '#ffff00');
                this.speed = isHoming ? 7.2 : 12; // Ìò∏Î∞ç ÎØ∏ÏÇ¨ÏùºÏùÄ 60% ÏÜçÎèÑ
                this.isHoming = isHoming;
                this.isPierce = isPierce;
                this.hitEnemies = [];
            }
            
            update() {
                if (this.isHoming && enemies.length > 0) {
                    let nearestEnemy = enemies[0];
                    let minDistance = this.distanceTo(nearestEnemy);

                    enemies.forEach(enemy => {
                        const distance = this.distanceTo(enemy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestEnemy = enemy;
                        }
                    });

                    const dx = (nearestEnemy.x + nearestEnemy.width/2) - (this.x + this.width/2);
                    const dy = (nearestEnemy.y + nearestEnemy.height/2) - (this.y + this.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    if (distance > 0) {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                } else {
                    this.y -= this.speed;
                }
            }
            
            distanceTo(enemy) {
                const dx = (enemy.x + enemy.width/2) - (this.x + this.width/2);
                const dy = (enemy.y + enemy.height/2) - (this.y + this.height/2);
                return Math.sqrt(dx*dx + dy*dy);
            }
            
            draw() {
                if (this.isHoming) {
                    ctx.fillStyle = '#ff00ff';
                } else if (this.isPierce) {
                    ctx.fillStyle = '#00ffff';
                } else {
                    ctx.fillStyle = '#ffff00';
                }
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
        
        class KamikazeEnemy extends GameObject {
            constructor(x, y, targetX, targetY) {
                super(x, y, 35, 40, '#ff0000');
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 6;
                this.isKamikaze = true;

                // ÌÉÄÍ≤ü Î∞©Ìñ• Í≥ÑÏÇ∞
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // Ïπ¥ÎØ∏Ïπ¥Ï†ú Ï†Å ÎîîÏûêÏù∏ (Îπ®Í∞ÑÏÉâ + Í≤ΩÍ≥† Ìö®Í≥º)
                const warningGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 20);
                warningGradient.addColorStop(0, '#FF0000');
                warningGradient.addColorStop(0.7, '#AA0000');
                warningGradient.addColorStop(1, '#660000');

                ctx.fillStyle = warningGradient;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX - 15, this.y + 15);
                ctx.lineTo(centerX - 10, centerY);
                ctx.lineTo(centerX - 8, this.y + 30);
                ctx.lineTo(centerX - 4, this.y + this.height);
                ctx.lineTo(centerX + 4, this.y + this.height);
                ctx.lineTo(centerX + 8, this.y + 30);
                ctx.lineTo(centerX + 10, centerY);
                ctx.lineTo(centerX + 15, this.y + 15);
                ctx.closePath();
                ctx.fill();

                // Í≤ΩÍ≥† ÌëúÏãú
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('!', centerX, centerY + 3);
                ctx.textAlign = 'left';
                ctx.shadowBlur = 0;

                // Ï∂îÏßÑ Ìö®Í≥º
                const engineGradient = ctx.createRadialGradient(centerX, this.y + this.height + 8, 2, centerX, this.y + this.height + 8, 12);
                engineGradient.addColorStop(0, '#FFFFFF');
                engineGradient.addColorStop(0.3, '#FF4500');
                engineGradient.addColorStop(0.7, '#FF0000');
                engineGradient.addColorStop(1, 'transparent');

                ctx.fillStyle = engineGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, this.y + this.height + 8, 8, 15, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        class BossEnemy extends GameObject {
            constructor(stageScore) {
                super(canvas.width / 2 - 60, -120, 120, 100, '#000000');
                this.hp = stageScore; // Ïä§ÌÖåÏù¥ÏßÄ Ï†êÏàòÎßåÌÅºÏùò HP
                this.maxHp = stageScore;
                this.speed = 1;
                this.shootTimer = 0;
                this.moveTimer = 0;
                this.moveDirection = 1;
                this.isBoss = true;
                this.phase = 1;
                this.attackPattern = 0;
                this.patternTimer = 0;
            }

            update() {
                // Î≥¥Ïä§ Îì±Ïû• Ïï†ÎãàÎ©îÏù¥ÏÖò (ÏúÑÏóêÏÑú ÎÇ¥Î†§Ïò¥)
                if (this.y < 50) {
                    this.y += this.speed;
                } else {
                    // Ï¢åÏö∞ ÏõÄÏßÅÏûÑ (Îçî ÎäêÎ¶¨Í≤å)
                    this.moveTimer++;
                    if (this.moveTimer > 200) { // 120ÏóêÏÑú 200ÏúºÎ°ú Ï¶ùÍ∞Ä (Îçî Ïò§Îûò Ìïú Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô)
                        this.moveDirection *= -1;
                        this.moveTimer = 0;
                    }
                    this.x += this.moveDirection * 1.5; // 2ÏóêÏÑú 1.5Î°ú Í∞êÏÜå (ÏõÄÏßÅÏûÑ ÏÜçÎèÑÎèÑ Ï°∞Í∏à ÎäêÎ¶¨Í≤å)

                    // Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
                    if (this.x < 0) {
                        this.x = 0;
                        this.moveDirection = 1;
                    }
                    if (this.x > canvas.width - this.width) {
                        this.x = canvas.width - this.width;
                        this.moveDirection = -1;
                    }

                    // Í≥µÍ≤© Ìå®ÌÑ¥
                    this.patternTimer++;
                    this.updateAttackPattern();
                }
            }

            updateAttackPattern() {
                // HPÏóê Îî∞Î•∏ ÌéòÏù¥Ï¶à Î≥ÄÍ≤Ω
                if (this.hp < this.maxHp * 0.3 && this.phase === 1) {
                    this.phase = 2;
                    this.attackPattern = 0;
                    this.patternTimer = 0;
                }

                if (this.phase === 1) {
                    // ÌéòÏù¥Ï¶à 1: ÏßÅÏÑ† Î∞úÏÇ¨
                    if (this.patternTimer % 60 === 0) {
                        this.shootStraight();
                    }
                } else {
                    // ÌéòÏù¥Ï¶à 2: ÏÇ∞ÌÉÑ Î∞úÏÇ¨
                    if (this.patternTimer % 40 === 0) {
                        this.shootSpread();
                    }
                }
            }

            shootStraight() {
                // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•ÏúºÎ°ú ÏßÅÏÑ† Î∞úÏÇ¨
                const centerX = this.x + this.width / 2;
                enemies.push(new BossBullet(centerX - 5, this.y + this.height, 0));
                enemies.push(new BossBullet(centerX + 5, this.y + this.height, 0));
            }

            shootSpread() {
                // ÏÇ∞ÌÉÑ Î∞úÏÇ¨
                const centerX = this.x + this.width / 2;
                for (let i = -2; i <= 2; i++) {
                    enemies.push(new BossBullet(centerX, this.y + this.height, i * 0.5));
                }
            }

            takeDamage(damage = 1) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    // Î≥¥Ïä§ Ï≤òÏπòÏãú Ìè≠Î∞ú Ìö®Í≥º
                    for (let i = 0; i < 10; i++) {
                        createExplosion(
                            this.x + Math.random() * this.width,
                            this.y + Math.random() * this.height
                        );
                    }
                    if (bossActive) { // Ï†ïÏÉÅÏ†ÅÏù∏ Î≥¥Ïä§ Ï≤òÏπòÏãúÏóêÎßå Ï†êÏàò Ï¶ùÍ∞Ä
                        const stageScore = difficultyLevel * 500;
                        score += Math.floor(stageScore * 0.5); // Ïä§ÌÖåÏù¥ÏßÄ Ï†êÏàòÏùò 50%
                    }
                    bossActive = false;
                    currentBoss = null;

                    // Î≥¥Ïä§ Ï≤òÏπò ÌõÑ Î≥¥Ïä§ ÌÉÑÌôò Î™®Îëê Ï†úÍ±∞
                    enemies = enemies.filter(enemy => !enemy.isBossBullet);

                    // Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Î©îÏãúÏßÄ
                    showStageClearMessage();

                    // Î≥¥Ïä§ Ï≤òÏπò ÌõÑ ÏßÄÏó∞Îêú Ïä§ÌÖåÏù¥ÏßÄ ÏßÑÌñâ Ï≤¥ÌÅ¨
                    setTimeout(() => {
                        updateDifficulty();
                    }, 1000);

                    return true;
                }
                return false;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // ÎåÄÌòï Ï†ÑÌà¨Í∏∞ Ïä§ÌÉÄÏùº (Î†àÌçºÎü∞Ïä§ Ïù¥ÎØ∏ÏßÄÏôÄ Ïú†ÏÇ¨)
                ctx.save();

                // Î©îÏù∏ ÎèôÏ≤¥ (ÎåÄÌòï Ï†ÑÌà¨Í∏∞)
                const fuselageGradient = ctx.createLinearGradient(centerX - 60, centerY, centerX + 60, centerY);
                fuselageGradient.addColorStop(0, '#2a2a2a');
                fuselageGradient.addColorStop(0.3, '#4a4a4a');
                fuselageGradient.addColorStop(0.7, '#3a3a3a');
                fuselageGradient.addColorStop(1, '#2a2a2a');

                ctx.fillStyle = fuselageGradient;
                ctx.fillRect(centerX - 50, this.y + 15, 100, 70);

                // Í∏∞Ïàò (Îæ∞Ï°±Ìïú ÌòïÌÉú)
                const noseGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + 20);
                noseGradient.addColorStop(0, '#5a5a5a');
                noseGradient.addColorStop(1, '#4a4a4a');

                ctx.fillStyle = noseGradient;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX - 20, this.y + 18);
                ctx.lineTo(centerX + 20, this.y + 18);
                ctx.closePath();
                ctx.fill();

                // ÎåÄÌòï ÎÇ†Í∞ú (Ï¢åÏö∞)
                const wingGradient = ctx.createLinearGradient(centerX - 80, centerY, centerX + 80, centerY);
                wingGradient.addColorStop(0, '#3a3a3a');
                wingGradient.addColorStop(0.5, '#5a5a5a');
                wingGradient.addColorStop(1, '#3a3a3a');

                ctx.fillStyle = wingGradient;
                // Ï¢åÏ∏° ÎÇ†Í∞ú
                ctx.fillRect(this.x - 40, this.y + 35, 50, 20);
                // Ïö∞Ï∏° ÎÇ†Í∞ú
                ctx.fillRect(this.x + this.width - 10, this.y + 35, 50, 20);

                // ÏóîÏßÑ (6Í∞úÏùò Ï†úÌä∏ ÏóîÏßÑ)
                const engineGradient = ctx.createLinearGradient(centerX, this.y + this.height - 15, centerX, this.y + this.height);
                engineGradient.addColorStop(0, '#0099ff');
                engineGradient.addColorStop(0.5, '#0066cc');
                engineGradient.addColorStop(1, '#004499');

                ctx.fillStyle = engineGradient;
                // Î©îÏù∏ ÏóîÏßÑÎì§
                ctx.fillRect(centerX - 35, this.y + this.height - 15, 8, 15);
                ctx.fillRect(centerX - 20, this.y + this.height - 15, 8, 15);
                ctx.fillRect(centerX - 5, this.y + this.height - 15, 8, 15);
                ctx.fillRect(centerX + 10, this.y + this.height - 15, 8, 15);
                ctx.fillRect(centerX + 25, this.y + this.height - 15, 8, 15);
                ctx.fillRect(centerX + 40, this.y + this.height - 15, 8, 15);

                // Aircraft cockpit and nose section
                const cockpitGradient = ctx.createLinearGradient(centerX, this.y + 15, centerX, this.y + 45);
                cockpitGradient.addColorStop(0, '#6A8CAF');
                cockpitGradient.addColorStop(0.5, '#4F6F8F');
                cockpitGradient.addColorStop(1, '#2A3A4A');
                ctx.fillStyle = cockpitGradient;

                // Main cockpit canopy
                ctx.fillRect(centerX - 20, this.y + 15, 40, 25);

                // Cockpit windows (transparent blue)
                ctx.fillStyle = 'rgba(100, 150, 255, 0.7)';
                ctx.fillRect(centerX - 15, this.y + 18, 30, 8);
                ctx.fillRect(centerX - 12, this.y + 28, 24, 6);

                // Nose cone and radar equipment
                ctx.fillStyle = '#404040';
                ctx.fillRect(centerX - 8, this.y + 5, 16, 15);

                // Radar dome
                ctx.fillStyle = '#555555';
                ctx.beginPath();
                ctx.arc(centerX, this.y + 12, 6, 0, Math.PI * 2);
                ctx.fill();

                // Twin jet engines
                const twinEngineGradient = ctx.createLinearGradient(0, this.y + this.height - 12, 0, this.y + this.height);
                twinEngineGradient.addColorStop(0, '#404040');
                twinEngineGradient.addColorStop(0.5, '#2A2A2A');
                twinEngineGradient.addColorStop(1, '#1A1A1A');
                ctx.fillStyle = twinEngineGradient;

                // Left engine nacelle
                ctx.fillRect(centerX - 30, this.y + this.height - 12, 18, 12);
                // Right engine nacelle
                ctx.fillRect(centerX + 12, this.y + this.height - 12, 18, 12);

                // Engine intakes
                ctx.fillStyle = '#1A1A1A';
                ctx.fillRect(centerX - 28, this.y + this.height - 10, 14, 8);
                ctx.fillRect(centerX + 14, this.y + this.height - 10, 14, 8);

                // Wing-mounted weapon systems
                ctx.fillStyle = '#333333';

                // Left wing weapons
                // Gun pod
                ctx.fillRect(centerX - 45, this.y + 35, 12, 6);
                ctx.fillStyle = '#1A1A1A';
                ctx.fillRect(centerX - 43, this.y + 33, 2, 4); // Gun barrel
                ctx.fillRect(centerX - 39, this.y + 33, 2, 4); // Gun barrel

                // Missile hardpoints
                ctx.fillStyle = '#2A2A2A';
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(centerX - 50 + i * 8, this.y + 45 + i * 8, 8, 4);
                    // Missiles
                    ctx.fillStyle = '#404040';
                    ctx.fillRect(centerX - 48 + i * 8, this.y + 43 + i * 8, 4, 12);
                    ctx.fillStyle = '#2A2A2A';
                }

                // Right wing weapons (mirrored)
                ctx.fillStyle = '#333333';
                ctx.fillRect(centerX + 33, this.y + 35, 12, 6);
                ctx.fillStyle = '#1A1A1A';
                ctx.fillRect(centerX + 35, this.y + 33, 2, 4); // Gun barrel
                ctx.fillRect(centerX + 39, this.y + 33, 2, 4); // Gun barrel

                // Right missile hardpoints
                ctx.fillStyle = '#2A2A2A';
                for (let i = 0; i < 2; i++) {
                    ctx.fillRect(centerX + 42 + i * 8, this.y + 45 + i * 8, 8, 4);
                    // Missiles
                    ctx.fillStyle = '#404040';
                    ctx.fillRect(centerX + 44 + i * 8, this.y + 43 + i * 8, 4, 12);
                    ctx.fillStyle = '#2A2A2A';
                }

                // Engine afterburner effects
                const leftEngineGlow = ctx.createRadialGradient(centerX - 21, this.y + this.height - 6, 0, centerX - 21, this.y + this.height - 6, 15);
                leftEngineGlow.addColorStop(0, '#FFAA00');
                leftEngineGlow.addColorStop(0.3, '#FF6600');
                leftEngineGlow.addColorStop(0.7, '#FF3300');
                leftEngineGlow.addColorStop(1, 'rgba(255, 51, 0, 0)');

                ctx.fillStyle = leftEngineGlow;
                ctx.fillRect(centerX - 30, this.y + this.height - 8, 18, 8);

                const rightEngineGlow = ctx.createRadialGradient(centerX + 21, this.y + this.height - 6, 0, centerX + 21, this.y + this.height - 6, 15);
                rightEngineGlow.addColorStop(0, '#FFAA00');
                rightEngineGlow.addColorStop(0.3, '#FF6600');
                rightEngineGlow.addColorStop(0.7, '#FF3300');
                rightEngineGlow.addColorStop(1, 'rgba(255, 51, 0, 0)');

                ctx.fillStyle = rightEngineGlow;
                ctx.fillRect(centerX + 12, this.y + this.height - 8, 18, 8);

                // Aircraft panel lines and details
                ctx.strokeStyle = '#555555';
                ctx.lineWidth = 0.8;
                ctx.beginPath();

                // Fuselage center line
                ctx.moveTo(centerX, this.y + 40);
                ctx.lineTo(centerX, this.y + this.height * 0.85);

                // Wing panel lines
                ctx.moveTo(centerX - 25, this.y + 50);
                ctx.lineTo(centerX - 15, this.y + this.height * 0.7);
                ctx.moveTo(centerX + 25, this.y + 50);
                ctx.lineTo(centerX + 15, this.y + this.height * 0.7);

                // Engine separation lines
                ctx.moveTo(centerX - 35, this.y + 60);
                ctx.lineTo(centerX - 25, this.y + this.height * 0.8);
                ctx.moveTo(centerX + 35, this.y + 60);
                ctx.lineTo(centerX + 25, this.y + this.height * 0.8);

                ctx.stroke();

                // Aircraft markings and insignia
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '8px Arial';
                ctx.fillText('AF-01', centerX - 12, this.y + 70);

                // Warning stripes on weapons
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i < 3; i++) {
                    ctx.moveTo(centerX - 48 + i * 2, this.y + 47);
                    ctx.lineTo(centerX - 46 + i * 2, this.y + 49);
                    ctx.moveTo(centerX + 44 + i * 2, this.y + 47);
                    ctx.lineTo(centerX + 46 + i * 2, this.y + 49);
                }
                ctx.stroke();

                ctx.restore();

                // HP Î∞î
                const hpBarWidth = this.width;
                const hpBarHeight = 8;
                const hpPercentage = this.hp / this.maxHp;

                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x, this.y - 15, hpBarWidth, hpBarHeight);

                ctx.fillStyle = hpPercentage > 0.3 ? '#00FF00' : '#FF0000';
                ctx.fillRect(this.x, this.y - 15, hpBarWidth * hpPercentage, hpBarHeight);

                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - 15, hpBarWidth, hpBarHeight);

                // ÌéòÏù¥Ï¶à 2ÏóêÏÑú Îπ®Í∞Ñ Í≤ΩÍ≥† Ìö®Í≥º
                if (this.phase === 2) {
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                    ctx.shadowBlur = 0;
                }
            }
        }

        class BossBullet extends GameObject {
            constructor(x, y, angle) {
                super(x, y, 8, 12, '#FF0000');
                this.speed = 4;
                this.angle = angle;
                this.vx = Math.sin(angle) * this.speed;
                this.vy = this.speed;
                this.isBossBullet = true;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Î≥¥Ïä§ Ï¥ùÏïåÏùÄ ÌôîÎ©¥ÏùÑ Î≤óÏñ¥ÎÇòÎ©¥ Îã§Ïãú ÏúÑÏóêÏÑú ÎÇòÌÉÄÎÇ® (ÏàúÌôò)
                if (this.y > canvas.height + 20) {
                    this.y = -20;
                }
                if (this.x < -20) {
                    this.x = canvas.width + 20;
                } else if (this.x > canvas.width + 20) {
                    this.x = -20;
                }
                if (this.y < -20) {
                    this.y = canvas.height + 20;
                }
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // Îπ®Í∞Ñ ÏóêÎÑàÏßÄ ÌÉÑÌôò
                const bulletGradient = ctx.createRadialGradient(centerX, centerY, 2, centerX, centerY, 6);
                bulletGradient.addColorStop(0, '#FFFF00');
                bulletGradient.addColorStop(0.5, '#FF4500');
                bulletGradient.addColorStop(1, '#FF0000');

                ctx.fillStyle = bulletGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 4, 6, 0, 0, 2 * Math.PI);
                ctx.fill();

                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 2, 3, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class UAPBullet extends GameObject {
            constructor(x, y, vx, vy) {
                super(x, y, 6, 14, '#00FFAA');
                this.vx = vx;
                this.vy = vy;
                this.isUAPBullet = true;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // UAP Ï¥ùÏïåÏùÄ ÌôîÎ©¥ÏùÑ Î≤óÏñ¥ÎÇòÎ©¥ Ï†úÍ±∞Îê® (BossBulletÍ≥º Îã¨Î¶¨ ÏàúÌôòÌïòÏßÄ ÏïäÏùå)
                if (this.y < -20 || this.y > canvas.height + 20 ||
                    this.x < -20 || this.x > canvas.width + 20) {
                    return true; // Ï†úÍ±∞ Ïã†Ìò∏
                }
                return false;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // Ïô∏Í≥Ñ ÏóêÎÑàÏßÄ Îπî Ìö®Í≥º (Ï≤≠Î°ùÏÉâ)
                const bulletGradient = ctx.createRadialGradient(centerX, centerY, 1, centerX, centerY, 7);
                bulletGradient.addColorStop(0, '#FFFFFF');
                bulletGradient.addColorStop(0.3, '#00FFFF');
                bulletGradient.addColorStop(0.7, '#00CCAA');
                bulletGradient.addColorStop(1, '#004455');

                ctx.fillStyle = bulletGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 3, 7, 0, 0, 2 * Math.PI);
                ctx.fill();

                // ÎÇ¥Î∂Ä Î∞ùÏùÄ ÏΩîÏñ¥
                ctx.shadowColor = '#00FFAA';
                ctx.shadowBlur = 12;
                ctx.fillStyle = '#AAFFFF';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 1.5, 4, 0, 0, 2 * Math.PI);
                ctx.fill();

                // ÏóêÎÑàÏßÄ ÌååÏû• Ìö®Í≥º
                ctx.shadowBlur = 6;
                ctx.strokeStyle = '#00FFAA';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 4, 8, 0, 0, 2 * Math.PI);
                ctx.stroke();

                ctx.shadowBlur = 0;
            }
        }

        class EliteEnemy extends GameObject {
            constructor(x, y, hp) {
                super(x, y, 40, 45, '#ff0000');
                this.baseSpeed = 1.5 + Math.random() * 1;
                this.speed = this.baseSpeed * enemySpeedMultiplier;
                this.type = Math.floor(Math.random() * 3);
                this.hp = hp;
                this.maxHp = hp;
                this.isElite = true;
            }

            takeDamage(damage = 1) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    return true; // Ï≤òÏπòÎê®
                }
                return false;
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // Í∞ïÌôî Ï†ÅÏùÄ Í∏∞Ï°¥ ÎîîÏûêÏù∏Ïóê Ìô©Í∏àÏÉâ ÌÖåÎëêÎ¶¨ÏôÄ HP Î∞î Ï∂îÍ∞Ä
                if (this.type === 0) {
                    // UAP Í∞ïÌôîÌòï
                    const uapGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, 20);
                    uapGradient.addColorStop(0, '#FFD700');
                    uapGradient.addColorStop(0.4, '#FFA500');
                    uapGradient.addColorStop(0.8, '#FF8C00');
                    uapGradient.addColorStop(1, '#FF4500');

                    ctx.fillStyle = uapGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 18, 10, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // ÏÉÅÎã® Îèî
                    const domeGradient = ctx.createRadialGradient(centerX, centerY - 3, 2, centerX, centerY - 3, 12);
                    domeGradient.addColorStop(0, '#FFFF00');
                    domeGradient.addColorStop(0.6, '#FFD700');
                    domeGradient.addColorStop(1, '#FFA500');

                    ctx.fillStyle = domeGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY - 3, 12, 6, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // Ìô©Í∏à Îπõ
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 22, 12, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                } else if (this.type === 1) {
                    // TIE Fighter Í∞ïÌôîÌòï
                    const imperialGold = '#FFD700';
                    const darkGold = '#B8860B';

                    // Ï§ëÏïô Ï°∞Ï¢ÖÏã§
                    const cockpitGradient = ctx.createRadialGradient(centerX, centerY, 3, centerX, centerY, 10);
                    cockpitGradient.addColorStop(0, '#FFD700');
                    cockpitGradient.addColorStop(0.7, '#DAA520');
                    cockpitGradient.addColorStop(1, '#B8860B');

                    ctx.fillStyle = cockpitGradient;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, 10, 10, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // Ìô©Í∏à ÏÜîÎùº Ìå®ÎÑê
                    ctx.fillStyle = imperialGold;
                    ctx.beginPath();
                    ctx.moveTo(this.x - 18, centerY - 12);
                    ctx.lineTo(this.x - 5, centerY - 14);
                    ctx.lineTo(this.x - 2, centerY - 10);
                    ctx.lineTo(this.x - 2, centerY + 10);
                    ctx.lineTo(this.x - 5, centerY + 14);
                    ctx.lineTo(this.x - 18, centerY + 12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width + 18, centerY - 12);
                    ctx.lineTo(this.x + this.width + 5, centerY - 14);
                    ctx.lineTo(this.x + this.width + 2, centerY - 10);
                    ctx.lineTo(this.x + this.width + 2, centerY + 10);
                    ctx.lineTo(this.x + this.width + 5, centerY + 14);
                    ctx.lineTo(this.x + this.width + 18, centerY + 12);
                    ctx.closePath();
                    ctx.fill();

                } else {
                    // Í∞ïÌôî Íµ¨Ï∂ïÌï®
                    const goldGradient = ctx.createLinearGradient(centerX, this.y, centerX, this.y + this.height);
                    goldGradient.addColorStop(0, '#FFD700');
                    goldGradient.addColorStop(0.5, '#DAA520');
                    goldGradient.addColorStop(1, '#B8860B');

                    ctx.fillStyle = goldGradient;
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 18, this.y + 10);
                    ctx.lineTo(centerX - 15, this.y + this.height);
                    ctx.lineTo(centerX + 15, this.y + this.height);
                    ctx.lineTo(centerX + 18, this.y + 10);
                    ctx.closePath();
                    ctx.fill();
                }

                // HP Î∞î
                const hpBarWidth = this.width + 10;
                const hpBarHeight = 6;
                const hpPercentage = this.hp / this.maxHp;

                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x - 5, this.y - 12, hpBarWidth, hpBarHeight);

                ctx.fillStyle = hpPercentage > 0.5 ? '#FFD700' : hpPercentage > 0.25 ? '#FFA500' : '#FF4500';
                ctx.fillRect(this.x - 5, this.y - 12, hpBarWidth * hpPercentage, hpBarHeight);

                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x - 5, this.y - 12, hpBarWidth, hpBarHeight);

                // Ìô©Í∏à ÌÖåÎëêÎ¶¨ Ìö®Í≥º
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
                ctx.shadowBlur = 0;
            }
        }

        class Enemy extends GameObject {
            constructor(x, y) {
                super(x, y, 30, 35, '#ff0000');
                this.baseSpeed = 2 + Math.random() * 2;
                this.speed = this.baseSpeed * enemySpeedMultiplier;
                this.type = Math.floor(Math.random() * 3);
            }
            
            update() {
                this.y += this.speed;
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // Í∞í Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
                if (!isFinite(centerX) || !isFinite(centerY) || !isFinite(this.x) || !isFinite(this.y) ||
                    !isFinite(this.width) || !isFinite(this.height)) {
                    return; // ÏûòÎ™ªÎêú Í∞íÏù¥Î©¥ Í∑∏Î¶¨Í∏∞ Ï§ëÎã®
                }

                ctx.save();

                if (this.type === 0) {
                    // German Messerschmitt Bf 109 style (larger and more detailed)

                    // Engine exhaust (larger)
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 4, this.y + this.height, 8, 10);

                    // Main fuselage (dark gray with better contrast)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                    fuselageGradient.addColorStop(0, '#2a2a2a');
                    fuselageGradient.addColorStop(0.5, '#4a4a4a');
                    fuselageGradient.addColorStop(1, '#2a2a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 8, this.y + 6, 16, 30);

                    // Engine cowling
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(centerX - 6, this.y + 2, 12, 8);

                    // Wings (larger and more realistic)
                    const wingGradient = ctx.createLinearGradient(this.x - 20, centerY, this.x + this.width + 20, centerY);
                    wingGradient.addColorStop(0, '#3a3a3a');
                    wingGradient.addColorStop(0.5, '#5a5a5a');
                    wingGradient.addColorStop(1, '#3a3a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing
                    ctx.fillRect(this.x - 16, this.y + 18, 20, 8);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 18, 20, 8);

                    // Nose/propeller area
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 6, this.y + 10);
                    ctx.lineTo(centerX + 6, this.y + 10);
                    ctx.closePath();
                    ctx.fill();

                    // German Balkenkreuz (Iron Cross)
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(centerX - 1, this.y + 12, 2, 12);
                    ctx.fillRect(centerX - 6, this.y + 17, 12, 2);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(centerX - 5, this.y + 17.5, 4, 1);
                    ctx.fillRect(centerX + 1, this.y + 17.5, 4, 1);

                    // Wing guns
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(this.x - 14, this.y + 20, 2, 4);
                    ctx.fillRect(this.x + this.width + 12, this.y + 20, 2, 4);

                } else if (this.type === 1) {
                    // Japanese Mitsubishi A6M Zero style (larger and more detailed)

                    // Engine exhaust
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 3, this.y + this.height, 6, 10);

                    // Main fuselage (olive/dark green)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 8, centerY, centerX + 8, centerY);
                    fuselageGradient.addColorStop(0, '#2a3a2a');
                    fuselageGradient.addColorStop(0.5, '#3a4a3a');
                    fuselageGradient.addColorStop(1, '#2a3a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 7, this.y + 4, 14, 32);

                    // Engine cowling
                    ctx.fillStyle = '#1a2a1a';
                    ctx.fillRect(centerX - 5, this.y + 1, 10, 8);

                    // Wings (longer, typical of Zero)
                    const wingGradient = ctx.createLinearGradient(this.x - 18, centerY, this.x + this.width + 18, centerY);
                    wingGradient.addColorStop(0, '#3a4a3a');
                    wingGradient.addColorStop(0.5, '#4a5a4a');
                    wingGradient.addColorStop(1, '#3a4a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing (longer)
                    ctx.fillRect(this.x - 18, this.y + 16, 22, 7);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 16, 22, 7);

                    // Nose
                    ctx.fillStyle = '#4a5a4a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 5, this.y + 8);
                    ctx.lineTo(centerX + 5, this.y + 8);
                    ctx.closePath();
                    ctx.fill();

                    // Japanese Hinomaru (Rising Sun)
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(centerX, this.y + 18, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#cc0000';
                    ctx.beginPath();
                    ctx.arc(centerX, this.y + 18, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Wing guns
                    ctx.fillStyle = '#ffaa44';
                    ctx.fillRect(this.x - 16, this.y + 18, 2, 3);
                    ctx.fillRect(this.x + this.width + 14, this.y + 18, 2, 3);

                } else {
                    // Italian/Other Axis Macchi C.202 style (larger and more detailed)

                    // Engine exhaust
                    const exhaustGradient = ctx.createLinearGradient(centerX, this.y + this.height, centerX, this.y + this.height + 10);
                    exhaustGradient.addColorStop(0, '#ff6600');
                    exhaustGradient.addColorStop(0.5, '#ff4400');
                    exhaustGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = exhaustGradient;
                    ctx.fillRect(centerX - 4, this.y + this.height, 8, 10);

                    // Main fuselage (sand/brown camo)
                    const fuselageGradient = ctx.createLinearGradient(centerX - 10, centerY, centerX + 10, centerY);
                    fuselageGradient.addColorStop(0, '#4a3a2a');
                    fuselageGradient.addColorStop(0.5, '#5a4a3a');
                    fuselageGradient.addColorStop(1, '#4a3a2a');
                    ctx.fillStyle = fuselageGradient;
                    ctx.fillRect(centerX - 8, this.y + 5, 16, 30);

                    // Engine cowling
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(centerX - 6, this.y + 2, 12, 8);

                    // Wings
                    const wingGradient = ctx.createLinearGradient(this.x - 17, centerY, this.x + this.width + 17, centerY);
                    wingGradient.addColorStop(0, '#5a4a3a');
                    wingGradient.addColorStop(0.5, '#6a5a4a');
                    wingGradient.addColorStop(1, '#5a4a3a');
                    ctx.fillStyle = wingGradient;

                    // Left wing
                    ctx.fillRect(this.x - 15, this.y + 17, 19, 8);
                    // Right wing
                    ctx.fillRect(this.x + this.width - 4, this.y + 17, 19, 8);

                    // Nose
                    ctx.fillStyle = '#6a5a4a';
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y);
                    ctx.lineTo(centerX - 6, this.y + 9);
                    ctx.lineTo(centerX + 6, this.y + 9);
                    ctx.closePath();
                    ctx.fill();

                    // Italian fasces symbol (simplified)
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(centerX - 4, this.y + 15, 8, 2);
                    ctx.fillRect(centerX - 1, this.y + 13, 2, 6);
                    ctx.fillStyle = '#006600';
                    ctx.fillRect(centerX - 3, this.y + 15.5, 6, 1);

                    // Wing guns
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillRect(this.x - 13, this.y + 19, 2, 4);
                    ctx.fillRect(this.x + this.width + 11, this.y + 19, 2, 4);
                }

                ctx.restore();
            }
        }

        class UAPEnemy extends GameObject {
            constructor() {
                // Íµ¨Î¶Ñ ÏúÑÏπòÏóêÏÑú Ïä§Ìè∞ (Íµ¨Î¶ÑÍ≥º ÎπÑÏä∑Ìïú ÏúÑÏπò)
                const cloudX = Math.random() * canvas.width;
                const cloudY = Math.random() * canvas.height * 0.7; // ÌôîÎ©¥ ÏÉÅÎã® 70%ÏóêÏÑú Ïä§Ìè∞
                super(cloudX, cloudY, 30, 20, '#silver');

                this.speed = 3 + Math.random() * 3; // Îçî Îπ†Î•¥Í≤å
                this.rotationAngle = 0;
                this.glowIntensity = 0;
                this.isUAP = true;
                this.isEmerging = true; // Îì±Ïû• ÏÉÅÌÉú
                this.emergingTimer = 0;
                this.attackMode = false;
                this.shootTimer = 0;

                // Ï¥àÍ∏∞ÏóêÎäî Ïà®Ïñ¥ÏûàÏùå (Ìà¨Î™Ö)
                this.alpha = 0;
                this.originalY = this.y;

                // Ïû†Ïãú ÌõÑ ÌîåÎ†àÏù¥Ïñ¥Î•º Ï∂îÏ†ÅÌïòÍ∏∞ ÏãúÏûë
                this.updateTarget();
            }

            updateTarget() {
                // ÌîåÎ†àÏù¥Ïñ¥Î•º Ìñ•Ìïú Î∞©Ìñ• Í≥ÑÏÇ∞
                const dx = (player.x + player.width / 2) - (this.x + this.width / 2);
                const dy = (player.y + player.height / 2) - (this.y + this.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                }
            }

            update() {
                this.emergingTimer++;

                if (this.isEmerging) {
                    // Íµ¨Î¶ÑÏóêÏÑú ÏÑúÏÑúÌûà Îì±Ïû• (2Ï¥àÍ∞Ñ)
                    if (this.emergingTimer < 120) {
                        this.alpha = Math.min(1, this.emergingTimer / 60);
                        // ÏÇ¥Ïßù ÏúÑÏïÑÎûòÎ°ú ÏõÄÏßÅÏûÑ (Îì±Ïû• Ìö®Í≥º)
                        this.y = this.originalY + Math.sin(this.emergingTimer * 0.1) * 5;
                    } else {
                        // Îì±Ïû• ÏôÑÎ£å, Í≥µÍ≤© Î™®Îìú ÏãúÏûë
                        this.isEmerging = false;
                        this.attackMode = true;
                        this.alpha = 1;
                        this.updateTarget(); // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Ïû¨Í≥ÑÏÇ∞
                    }
                } else if (this.attackMode) {
                    // Í≥µÍ≤© Î™®Îìú: ÌîåÎ†àÏù¥Ïñ¥Î•º Ìñ•Ìï¥ Îπ†Î•¥Í≤å ÎèåÏßÑ
                    this.x += this.vx;
                    this.y += this.vy;

                    // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Î∞©Ìñ• ÏóÖÎç∞Ïù¥Ìä∏ (Ïú†ÎèÑ ÎØ∏ÏÇ¨ÏùºÏ≤òÎüº)
                    if (this.emergingTimer % 30 === 0) {
                        this.updateTarget();
                    }

                    // UAP Î∞úÏÇ¨ (Îß§ 60ÌîÑÎ†àÏûÑÎßàÎã§)
                    this.shootTimer++;
                    if (this.shootTimer >= 60) {
                        this.shoot();
                        this.shootTimer = 0;
                    }
                }

                // ÌöåÏ†Ñ Ìö®Í≥º
                this.rotationAngle += 0.1;
                this.glowIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;

                // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ Ï†úÍ±∞ ÎåÄÏÉÅ
                if (this.x < -50 || this.x > canvas.width + 50 ||
                    this.y < -50 || this.y > canvas.height + 50) {
                    return true; // Ï†úÍ±∞ Ïã†Ìò∏
                }
                return false;
            }

            shoot() {
                // UAP ÏóêÎÑàÏßÄ ÌÉÑÌôò Î∞úÏÇ¨
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                // ÌîåÎ†àÏù¥Ïñ¥Î•º Ìñ•Ìïú ÏóêÎÑàÏßÄ ÌÉÑÌôò
                const dx = (player.x + player.width / 2) - centerX;
                const dy = (player.y + player.height / 2) - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const bulletSpeed = 4;
                    const vx = (dx / distance) * bulletSpeed;
                    const vy = (dy / distance) * bulletSpeed;

                    // UAP Ï†ÑÏö© ÌÉÑÌôò ÏÉùÏÑ±
                    enemies.push(new UAPBullet(centerX - 2, centerY, vx, vy));
                }
            }

            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.rotationAngle);

                // UAP Î™∏Ï≤¥ (ÏõêÎ∞òÌòï)
                const uapGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 18);
                uapGradient.addColorStop(0, '#E6E6FA');
                uapGradient.addColorStop(0.4, '#C0C0C0');
                uapGradient.addColorStop(0.8, '#808080');
                uapGradient.addColorStop(1, '#404040');

                ctx.fillStyle = uapGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 8, 0, 0, 2 * Math.PI);
                ctx.fill();

                // ÏÉÅÎã® Îèî
                const domeGradient = ctx.createRadialGradient(0, -3, 2, 0, -3, 10);
                domeGradient.addColorStop(0, '#F0F8FF');
                domeGradient.addColorStop(0.6, '#B0C4DE');
                domeGradient.addColorStop(1, '#778899');

                ctx.fillStyle = domeGradient;
                ctx.beginPath();
                ctx.ellipse(0, -3, 10, 5, 0, 0, 2 * Math.PI);
                ctx.fill();

                // Ï£ºÎ≥Ä Í∏ÄÎ°úÏö∞ Ìö®Í≥º
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 12 * this.glowIntensity;
                ctx.fillStyle = `rgba(0, 255, 255, ${0.4 * this.glowIntensity})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, 18, 10, 0, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Îπõ Ï†êÎì§
                ctx.fillStyle = '#00FFFF';
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI / 3) + this.rotationAngle;
                    const lightX = Math.cos(angle) * 12;
                    const lightY = Math.sin(angle) * 7;
                    ctx.beginPath();
                    ctx.arc(lightX, lightY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Cloud {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = 0.3 + Math.random() * 0.8; // Íµ¨Î¶ÑÏùÄ Îçî Ï≤úÏ≤úÌûà
                this.size = 20 + Math.random() * 40; // Íµ¨Î¶ÑÏùÄ Îçî ÌÅ¨Í≤å
                this.alpha = 0.3 + Math.random() * 0.4; // Íµ¨Î¶ÑÏùÄ Îçî Ìà¨Î™ÖÌïòÍ≤å
                this.offsetX = Math.random() * 10; // ÏàòÌèâ Ïù¥Îèô
            }

            update() {
                this.y += this.speed;
                this.x += Math.sin(Date.now() * 0.001 + this.offsetX) * 0.2; // Î∂ÄÎìúÎü¨Ïö¥ ÏàòÌèâ ÏõÄÏßÅÏûÑ

                if (this.y > canvas.height + 50) {
                    this.y = -50;
                    this.x = Math.random() * canvas.width;
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;

                // Íµ¨Î¶Ñ Í∑∏Î¶¨Í∏∞ (Ïó¨Îü¨ ÏõêÏùÑ Í≤πÏ≥êÏÑú Íµ¨Î¶Ñ Î™®Ïñë)
                const cloudGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                cloudGradient.addColorStop(0, '#ffffff');
                cloudGradient.addColorStop(0.7, '#e6e6e6');
                cloudGradient.addColorStop(1, 'rgba(200, 200, 200, 0)');

                ctx.fillStyle = cloudGradient;

                // Î©îÏù∏ Íµ¨Î¶Ñ Î™∏Ï≤¥ (Ïó¨Îü¨ ÏõêÏúºÎ°ú Íµ¨ÏÑ±)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.3, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x + this.size * 0.3, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(this.x, this.y - this.size * 0.2, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        
        class Item extends GameObject {
            constructor(x, y) {
                super(x, y, 20, 20, '#00ff00');
                this.speed = 3;
                this.types = ['multiShot', 'rapidFire', 'pierce', 'homing'];
                this.type = this.types[Math.floor(Math.random() * this.types.length)];
                this.colors = {
                    multiShot: '#ff6600',
                    rapidFire: '#ff0066',
                    pierce: '#00ffff',
                    homing: '#ff00ff'
                };
                this.symbols = {
                    multiShot: 'M',
                    rapidFire: 'R',
                    pierce: 'P',
                    homing: 'H'
                };
                this.color = this.colors[this.type];
            }
            
            update() {
                this.y += this.speed;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.symbols[this.type], this.x + this.width/2, this.y + this.height/2 + 4);
                ctx.textAlign = 'left';
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - 1, this.y - 1, this.width + 2, this.height + 2);
            }
        }
        
        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.timer = 0;
                this.maxTimer = 20;
                
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 1.0
                    });
                }
            }
            
            update() {
                this.timer++;
                this.particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.95;
                    particle.vy *= 0.95;
                    particle.life -= 0.05;
                });
            }
            
            draw() {
                this.particles.forEach(particle => {
                    if (particle.life > 0) {
                        ctx.globalAlpha = particle.life;
                        ctx.fillStyle = `hsl(${30 + Math.random() * 30}, 100%, 60%)`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                });
            }
            
            isDead() {
                return this.timer >= this.maxTimer;
            }
        }
        
        class Sidekick extends GameObject {
            constructor(side) {
                super(0, 0, 15, 20, '#00aa00');
                this.side = side;
                this.lastShot = 0; // Í∞úÎ≥Ñ Î∞úÏÇ¨ ÌÉÄÏù¥Î®∏
                if (side === 'left') {
                    this.offsetX = -30;
                    this.offsetY = 10;
                } else {
                    this.offsetX = 30;
                    this.offsetY = 10;
                }
            }
            
            update(playerX, playerY) {
                // ÌîåÎ†àÏù¥Ïñ¥ Í∏∞Ï≤¥Ïùò Ï§ëÏã¨ÏóêÏÑú Í≥ÑÏÇ∞
                const playerCenterX = playerX + 20;
                const playerCenterY = playerY + 25;
                
                this.x = playerCenterX + this.offsetX - this.width / 2;
                this.y = playerCenterY + this.offsetY - this.height / 2;
            }
            
            draw() {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                // Main body (green)
                ctx.fillStyle = '#00AA00';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 6, 8, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Wing (darker green)
                ctx.fillStyle = '#007700';
                if (this.side === 'left') {
                    ctx.beginPath();
                    ctx.moveTo(this.x - 3, centerY);
                    ctx.lineTo(this.x + 3, centerY - 5);
                    ctx.lineTo(this.x + 3, centerY + 5);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width + 3, centerY);
                    ctx.lineTo(this.x + this.width - 3, centerY - 5);
                    ctx.lineTo(this.x + this.width - 3, centerY + 5);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Engine (bright green)
                ctx.fillStyle = '#00FF00';
                ctx.beginPath();
                ctx.ellipse(centerX, this.y + this.height + 2, 2, 4, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Core (cyan)
                ctx.fillStyle = '#00FFAA';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, 3, 4, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        const player = new Player();
        let bullets = [];
        let enemies = [];
        const clouds = []; // Íµ¨Î¶Ñ
        let items = [];
        let sidekickBullets = [];

        // Íµ¨Î¶Ñ Ï¥àÍ∏∞Ìôî (Í∞úÏàò Ï§ÑÏûÑ)
        for (let i = 0; i < 15; i++) {
            clouds.push(new Cloud());
        }
        
        let lastShot = 0;
        let enemySpawnTimer = 0;
        let itemSpawnTimer = 0;
        
        function spawnEnemy() {
            // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπòÏôÄ ÏÜçÎèÑÎ•º Í≥†Î†§Ìïú Ïä§Ìè∞ ÏúÑÏπò Í≥ÑÏÇ∞
            const playerCenterX = player.x + player.width / 2;
            const playerSpeed = currentPlayerSpeed;

            // Ï†ÅÏù¥ ÌôîÎ©¥ÏùÑ Í∞ÄÎ°úÏßÄÎ•¥Îäî ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (ÎåÄÎûµÏ†Å)
            const enemySpeed = 2 + Math.random() * 2; // Ï†ÅÏùò Í∏∞Î≥∏ ÏÜçÎèÑ
            const timeToReachPlayer = canvas.height / (enemySpeed * enemySpeedMultiplier);

            // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Ïù¥ÎèôÌï† Ïàò ÏûàÎäî ÏµúÎåÄ Í±∞Î¶¨
            const maxPlayerMovement = playerSpeed * timeToReachPlayer;

            // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÎèÑÎã¨ Í∞ÄÎä•Ìïú Î≤îÏúÑ Í≥ÑÏÇ∞
            const minReachableX = Math.max(0, playerCenterX - maxPlayerMovement);
            const maxReachableX = Math.min(canvas.width, playerCenterX + maxPlayerMovement);

            // ÎèÑÎã¨ Í∞ÄÎä•Ìïú Î≤îÏúÑÏóêÏÑú Ï†Å Ïä§Ìè∞ (ÏïΩÍ∞ÑÏùò Ïó¨Ïú† Ï∂îÍ∞Ä)
            const safetyMargin = 50; // Ïó¨Ïú† Í≥µÍ∞Ñ
            const spawnMinX = Math.max(0, minReachableX - safetyMargin);
            const spawnMaxX = Math.min(canvas.width - 25, maxReachableX + safetyMargin);

            // ÏµúÏÜå Ïä§Ìè∞ Î≤îÏúÑ Î≥¥Ïû•
            const minSpawnRange = 200;
            let finalSpawnRange = spawnMaxX - spawnMinX;

            if (finalSpawnRange < minSpawnRange) {
                // Î≤îÏúÑÍ∞Ä ÎÑàÎ¨¥ Ï¢ÅÏúºÎ©¥ ÌîåÎ†àÏù¥Ïñ¥ Ï§ëÏã¨ÏúºÎ°ú ÏµúÏÜå Î≤îÏúÑ ÌôïÎ≥¥
                const centerX = (spawnMinX + spawnMaxX) / 2;
                const halfRange = minSpawnRange / 2;
                const newMinX = Math.max(0, centerX - halfRange);
                const newMaxX = Math.min(canvas.width - 25, centerX + halfRange);

                const x = newMinX + Math.random() * (newMaxX - newMinX);
                enemies.push(new Enemy(x, -25));
            } else {
                const x = spawnMinX + Math.random() * (spawnMaxX - spawnMinX);
                enemies.push(new Enemy(x, -25));
            }
        }
        
        function updateDifficulty() {
            // Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ ÌïÑÏöî Ï†êÏàò: 1‚Üí2(500), 2‚Üí3(1500), 3‚Üí4(3000), 4‚Üí5(4500)...
            let newDifficultyLevel = 1;
            const stageThresholds = [];

            // Ïä§ÌÖåÏù¥ÏßÄ 2: 500Ï†ê
            // Ïä§ÌÖåÏù¥ÏßÄ 3: 1500Ï†ê (500 + 1000)
            // Ïä§ÌÖåÏù¥ÏßÄ 4: 3000Ï†ê (1500 + 1500)
            // Ïä§ÌÖåÏù¥ÏßÄ 5: 4500Ï†ê (3000 + 1500)
            // Ìå®ÌÑ¥: nÎ≤àÏß∏ Ïä§ÌÖåÏù¥ÏßÄ = (n-1) * n * 250
            for (let stage = 2; stage <= 100; stage++) {
                const threshold = (stage - 1) * stage * 250;
                stageThresholds.push(threshold);
            }

            for (let i = 0; i < stageThresholds.length; i++) {
                if (score >= stageThresholds[i]) {
                    newDifficultyLevel = i + 2; // i+2 because stage 1 starts at 0 points
                } else {
                    break;
                }
            }

            // Î≥¥Ïä§Í∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏúºÎ©¥ Ïä§ÌÖåÏù¥ÏßÄ ÏßÑÌñâÏùÑ ÎßâÏùå
            if (newDifficultyLevel > difficultyLevel && !bossActive) {
                difficultyLevel = newDifficultyLevel;

                // Ï†Å Ïä§Ìè∞ ÏÜçÎèÑ (Îã®Í≥ÑÎ≥Ñ 3ÌîÑÎ†àÏûÑ Í∞êÏÜå, ÏµúÏÜå 8ÌîÑÎ†àÏûÑ)
                currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (difficultyLevel * 3));

                // Ï†Å Ïù¥Îèô ÏÜçÎèÑ (Îã®Í≥ÑÎ≥Ñ 5% Ï¶ùÍ∞Ä, ÏµúÎåÄ 2Î∞∞)
                enemySpeedMultiplier = Math.min(2.0, 1.0 + (difficultyLevel * 0.05));

                // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô ÏÜçÎèÑ (Îã®Í≥ÑÎ≥Ñ 3% Ï¶ùÍ∞Ä, ÏµúÎåÄ 1.6Î∞∞)
                currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + difficultyLevel * 0.03));

                // ÌîåÎ†àÏù¥Ïñ¥ ÏÉá ÏÜçÎèÑ (Îã®Í≥ÑÎ≥Ñ 3ms Í∞êÏÜå, ÏµúÏÜå 30ms)
                currentShotDelay = rapidFireActive ?
                    Math.max(15, baseShotDelay - (difficultyLevel * 3)) / 3 :
                    Math.max(30, baseShotDelay - (difficultyLevel * 3));

                // Ïä§ÌÖåÏù¥ÏßÄ ÏïåÎ¶º Î®ºÏ†Ä ÌëúÏãú
                showStageMessage();

                // Î≥¥Ïä§ ÏÜåÌôò (2Ï¥à ÌõÑ, HP = Ïä§ÌÖåÏù¥ÏßÄ Ï†êÏàò)
                setTimeout(() => {
                    if (gameRunning && !gamePaused) { // Í≤åÏûÑÏù¥ Í≥ÑÏÜç ÏßÑÌñâ Ï§ëÏùº ÎïåÎßå Î≥¥Ïä§ ÏÜåÌôò
                        const stageScore = difficultyLevel * 500;
                        spawnBoss(stageScore);
                    }
                }, 2000);
            }
        }

        function spawnBoss(stageScore) {
            if (!bossActive) {
                bossActive = true;
                currentBoss = new BossEnemy(stageScore);
                enemies.push(currentBoss);

                // Î≥¥Ïä§ Îì±Ïû• Ïãú ÏùºÎ∞ò Ï†Å Ï¶ùÍ∞Ä (3-5ÎßàÎ¶¨ Ï∂îÍ∞Ä Ïä§Ìè∞)
                const extraEnemyCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < extraEnemyCount; i++) {
                    setTimeout(() => {
                        const x = Math.random() * (canvas.width - 25);
                        enemies.push(new Enemy(x, -25));
                    }, i * 150); // 150ms Í∞ÑÍ≤©ÏúºÎ°ú Ïä§Ìè∞
                }

                showBossMessage();
            }
        }

        function spawnEliteEnemy(hp) {
            // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÎèÑÎã¨ Í∞ÄÎä•Ìïú Î≤îÏúÑÏóêÏÑú Í∞ïÌôî Ï†Å Ïä§Ìè∞
            const playerCenterX = player.x + player.width / 2;
            const playerSpeed = currentPlayerSpeed;
            const enemySpeed = 1.5 + Math.random() * 1;
            const timeToReachPlayer = canvas.height / (enemySpeed * enemySpeedMultiplier);
            const maxPlayerMovement = playerSpeed * timeToReachPlayer;

            const minReachableX = Math.max(0, playerCenterX - maxPlayerMovement);
            const maxReachableX = Math.min(canvas.width, playerCenterX + maxPlayerMovement);

            const safetyMargin = 50;
            const spawnMinX = Math.max(0, minReachableX - safetyMargin);
            const spawnMaxX = Math.min(canvas.width - 40, maxReachableX + safetyMargin);

            const x = spawnMinX + Math.random() * (spawnMaxX - spawnMinX);
            enemies.push(new EliteEnemy(x, -45, hp));
        }

        function showBossMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2;

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #ff0000;
                font-size: 36px;
                font-weight: bold;
                z-index: 1001;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: bossWarning 2.5s ease-in-out;
            `;
            message.textContent = `‚ö†Ô∏è STAGE ${difficultyLevel} BOSS ‚ö†Ô∏è`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes bossWarning {
                    0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    10%, 90% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 2500);
        }

        function showStageClearMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2 - 50; // Slightly above center

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #00ff00;
                font-size: 32px;
                font-weight: bold;
                z-index: 1002;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: stageClear 1.8s ease-in-out;
            `;
            message.textContent = `üéâ STAGE ${difficultyLevel} CLEAR! üéâ`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes stageClear {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 1800);
        }

        function showStageMessage() {
            const message = document.createElement('div');
            const canvasRect = canvas.getBoundingClientRect();
            const centerX = canvasRect.left + canvasRect.width / 2;
            const centerY = canvasRect.top + canvasRect.height / 2 + 50; // Slightly below center

            message.style.cssText = `
                position: fixed;
                top: ${centerY}px;
                left: ${centerX}px;
                transform: translate(-50%, -50%);
                color: #ffd700;
                font-size: 28px;
                font-weight: bold;
                z-index: 1000;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                pointer-events: none;
                animation: stageUp 1.5s ease-in-out;
            `;
            message.textContent = `‚≠ê STAGE ${difficultyLevel} ‚≠ê`;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes stageUp {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(message);

            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
                if (document.head.contains(style)) {
                    document.head.removeChild(style);
                }
            }, 1500);
        }
        
        function showDifficultyMessage() {
            // ÌôîÎ©¥Ïóê Ïû†Íπê ÎÇúÏù¥ÎèÑ Ï¶ùÍ∞Ä Î©îÏãúÏßÄ ÌëúÏãú
            const message = document.createElement('div');
            const isMaxLevel = difficultyLevel >= maxDifficultyLevel;
            message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${isMaxLevel ? '#ff0000' : '#ff6600'};
                font-size: ${isMaxLevel ? '32px' : '28px'};
                font-weight: bold;
                z-index: 1000;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                pointer-events: none;
            `;
            
            if (isMaxLevel) {
                message.textContent = 'ÏµúÍ≥† ÎÇúÏù¥ÎèÑ Îã¨ÏÑ±!';
            } else {
                message.textContent = `ÎÇúÏù¥ÎèÑ ${difficultyLevel}Îã®Í≥Ñ!`;
            }
            
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (document.body.contains(message)) {
                    document.body.removeChild(message);
                }
            }, isMaxLevel ? 3000 : 2000);
        }
        
        function spawnKamikazeEnemy() {
            kamikazeActive = true;

            // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Í∏∞Ï§ÄÏúºÎ°ú ÌôîÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨ÏóêÏÑú Ïä§Ìè∞
            let spawnX, spawnY;
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            // ÎûúÎç§ÌïòÍ≤å 4Î∞©Ìñ• Ï§ë ÌïòÎÇòÏóêÏÑú Ïä§Ìè∞
            const side = Math.floor(Math.random() * 4);
            switch(side) {
                case 0: // ÏúÑÏ™Ω
                    spawnX = Math.random() * canvas.width;
                    spawnY = -50;
                    break;
                case 1: // ÏïÑÎûòÏ™Ω
                    spawnX = Math.random() * canvas.width;
                    spawnY = canvas.height + 50;
                    break;
                case 2: // ÏôºÏ™Ω
                    spawnX = -50;
                    spawnY = Math.random() * canvas.height;
                    break;
                case 3: // Ïò§Î•∏Ï™Ω
                    spawnX = canvas.width + 50;
                    spawnY = Math.random() * canvas.height;
                    break;
            }

            kamikazeEnemy = new KamikazeEnemy(spawnX, spawnY, playerCenterX, playerCenterY);
            enemies.push(kamikazeEnemy);
        }

        function update() {
            if (!gameRunning || gamePaused) return;
            
            player.update();
            
            if (Date.now() - lastShot > currentShotDelay) {
                // Í∏∞Î≥∏ ÎçîÎ∏î ÏÉ∑
                bullets.push(new Bullet(player.x + player.width / 2 - 8, player.y - 5));
                bullets.push(new Bullet(player.x + player.width / 2 + 4, player.y - 5));
                lastShot = Date.now();
            }
            
            // Sidekick shooting with individual item abilities
            sidekicks.forEach((sidekick, index) => {
                // Í∞Å ÏÇ¨Ïù¥ÎìúÌÇ•ÏùÄ Ìï¥Îãπ Ïù∏Îç±Ïä§Ïùò ÏïÑÏù¥ÌÖú Ìö®Í≥ºÎ•º ÏÇ¨Ïö©
                const hasItem = playerItems.length > index;

                if (hasItem) {
                    const item = playerItems[index];
                    const isMultiShot = item.type === 'multiShot';
                    const isHoming = item.type === 'homing';
                    const isPierce = item.type === 'pierce';
                    const isRapidFire = item.type === 'rapidFire';

                    // Í∞Å ÏïÑÏù¥ÌÖú Ïú†ÌòïÎ≥Ñ Î∞úÏÇ¨ Í∞ÑÍ≤©
                    const baseDelay = 200;
                    let currentDelay = baseDelay;

                    if (isRapidFire) {
                        currentDelay = isHoming ? 230 : 70; // Ïó∞ÏÇ¨ + Ìò∏Î∞çÏ°∞Ìï©
                    } else if (isHoming) {
                        currentDelay = 670; // Ìò∏Î∞çÎßå
                    }

                    if (Date.now() - sidekick.lastShot > currentDelay) {
                        if (isMultiShot) {
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 6, sidekick.y - 5, isHoming, isPierce));
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, isHoming, isPierce));
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 + 2, sidekick.y - 5, isHoming, isPierce));
                        } else {
                            sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, isHoming, isPierce));
                        }
                        sidekick.lastShot = Date.now();
                    }
                } else {
                    // ÏïÑÏù¥ÌÖúÏù¥ ÏóÜÎäî ÏÇ¨Ïù¥ÎìúÌÇ•ÏùÄ Í∏∞Î≥∏ Ï¥ùÏïå Î∞úÏÇ¨
                    if (Date.now() - sidekick.lastShot > 200) {
                        sidekickBullets.push(new Bullet(sidekick.x + sidekick.width / 2 - 2, sidekick.y - 5, false, false));
                        sidekick.lastShot = Date.now();
                    }
                }
            });
            
            // Update sidekicks
            sidekicks.forEach(sidekick => {
                sidekick.update(player.x, player.y);
            });
            
            if (keys.z && specialGauge >= maxGauge && !specialAttackActive) {
                activateSpecialAttack();
            }
            
            bullets.forEach((bullet, bulletIndex) => {
                bullet.update();
                if (bullet.y < 0) {
                    bullets.splice(bulletIndex, 1);
                }
            });
            
            sidekickBullets.forEach((bullet, bulletIndex) => {
                bullet.update();
                if (bullet.y < 0) {
                    sidekickBullets.splice(bulletIndex, 1);
                }
            });
            
            enemies.forEach((enemy, enemyIndex) => {
                const shouldRemove = enemy.update();
                if ((enemy.y > canvas.height && !enemy.isBoss && !enemy.isBossBullet) ||
                    (enemy.isUAPBullet && shouldRemove)) { // UAP Ï¥ùÏïåÏùÄ updateÏóêÏÑú Î∞òÌôòÎêòÎäî Í∞íÏúºÎ°ú Ï†úÍ±∞ Í≤∞Ï†ï
                    enemies.splice(enemyIndex, 1);
                }
                
                if (player.collidesWith(enemy)) {
                    if (enemy.isBossBullet || enemy.isUAPBullet) {
                        // Î≥¥Ïä§ ÌÉÑÌôò ÎòêÎäî UAP ÌÉÑÌôòÍ≥º Ï∂©Îèå - ÌîåÎ†àÏù¥Ïñ¥ Ï£ΩÏùå
                        enemies.splice(enemyIndex, 1);
                        gameOver();
                    } else if (enemy.isUAP) {
                        // UAP Ï†Å ÏûêÏ≤¥ÏôÄ Ï∂©Îèå - ÌîåÎ†àÏù¥Ïñ¥Îäî Ï£ΩÏßÄ ÏïäÏùå (UAPÎäî Ï¥ùÏïåÎ°úÎßå ÏúÑÌóòÌï®)
                        // UAPÎäî Ï†úÍ±∞ÎêòÏßÄÎèÑ ÏïäÏùå
                    } else {
                        // ÏùºÎ∞ò Ï†Å ÎòêÎäî Î≥¥Ïä§ÏôÄ Ï∂©Îèå - ÌîåÎ†àÏù¥Ïñ¥ Ï£ΩÏùå
                        gameOver();
                    }
                }
                
                // Check sidekick collisions
                sidekicks.forEach((sidekick, sidekickIndex) => {
                    if (sidekick.collidesWith(enemy)) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        sidekicks.splice(sidekickIndex, 1);

                        if (enemy.isBoss) {
                            // Î≥¥Ïä§Îäî ÏÇ¨Ïù¥ÎìúÌÇ• Ï∂©ÎèåÎ°ú Îç∞ÎØ∏ÏßÄÎßå ÏûÖÏùå (Ï¶âÏãú Ï£ΩÏßÄ ÏïäÏùå)
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else {
                            // ÏùºÎ∞ò Ï†ÅÏùÄ Ï¶âÏãú Ï†úÍ±∞
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // Î≥¥Ïä§Í∞Ä ÏóÜÏùÑ ÎïåÎßå Ï†êÏàò Ï¶ùÍ∞Ä
                                score += 5;
                                updateScore();
                            }
                        }
                    }
                });
                
                bullets.forEach((bullet, bulletIndex) => {
                    if (bullet.collidesWith(enemy) && !bullet.hitEnemies.includes(enemy) &&
                        !enemy.isBossBullet && !enemy.isUAPBullet) { // Ï¥ùÏïåÎ•òÎäî ÌîåÎ†àÏù¥Ïñ¥ Ï¥ùÏïåÍ≥º Ï∂©ÎèåÌïòÏßÄ ÏïäÏùå
                        if (enemy.isBoss) {
                            // Î≥¥Ïä§Îäî HP ÏãúÏä§ÌÖú ÏÇ¨Ïö©
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }

                            if (enemy.takeDamage(2)) { // ÌîåÎ†àÏù¥Ïñ¥ Ï¥ùÏïå 2Î∞∞ Îç∞ÎØ∏ÏßÄ
                                // Î≥¥Ïä§ Ï≤òÏπòÎê®
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else if (enemy.isElite) {
                            // Í∞ïÌôî Ï†ÅÏùÄ HP ÏãúÏä§ÌÖú ÏÇ¨Ïö©
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }

                            if (enemy.takeDamage(2)) { // ÌîåÎ†àÏù¥Ïñ¥ Ï¥ùÏïå 2Î∞∞ Îç∞ÎØ∏ÏßÄ
                                // Í∞ïÌôî Ï†Å Ï≤òÏπòÎê®
                                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                enemies.splice(enemyIndex, 1);
                                if (!bossActive) { // Î≥¥Ïä§Í∞Ä ÏóÜÏùÑ ÎïåÎßå Ï†êÏàò Ï¶ùÍ∞Ä
                                    score += 50; // Í∞ïÌôî Ï†Å Î≥¥ÎÑàÏä§
                                    updateScore();
                                }
                                specialGauge = Math.min(specialGauge + 10, maxGauge);
                                updateGauge();
                            }
                        } else {
                            // ÏùºÎ∞ò Ï†Å
                            if (bullet.isPierce) {
                                bullet.hitEnemies.push(enemy);
                            } else {
                                bullets.splice(bulletIndex, 1);
                            }
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // Î≥¥Ïä§Í∞Ä ÏóÜÏùÑ ÎïåÎßå Ï†êÏàò Ï¶ùÍ∞Ä
                                score += 10;
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 5, maxGauge);
                            updateGauge();
                        }
                    }
                });
                
                sidekickBullets.forEach((bullet, bulletIndex) => {
                    if (bullet.collidesWith(enemy) && !enemy.isBossBullet && !enemy.isUAPBullet) { // Ï¥ùÏïåÎ•òÎäî ÏÇ¨Ïù¥ÎìúÌÇ• Ï¥ùÏïåÍ≥ºÎèÑ Ï∂©ÎèåÌïòÏßÄ ÏïäÏùå
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        sidekickBullets.splice(bulletIndex, 1);

                        if (enemy.isBoss) {
                            // Î≥¥Ïä§Îäî ÏÇ¨Ïù¥ÎìúÌÇ• Ï¥ùÏïåÏóêÎèÑ Îç∞ÎØ∏ÏßÄÎßå ÏûÖÏùå
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                updateScore();
                                updateGauge();
                            }
                        } else if (enemy.isElite) {
                            // Í∞ïÌôî Ï†ÅÎèÑ HP ÏãúÏä§ÌÖú ÏÇ¨Ïö©
                            if (enemy.takeDamage()) {
                                enemies.splice(enemyIndex, 1);
                                if (!bossActive) { // Î≥¥Ïä§Í∞Ä ÏóÜÏùÑ ÎïåÎßå Ï†êÏàò Ï¶ùÍ∞Ä
                                    score += 50;
                                    updateScore();
                                }
                                specialGauge = Math.min(specialGauge + 10, maxGauge);
                                updateGauge();
                            }
                        } else {
                            // ÏùºÎ∞ò Ï†ÅÏùÄ Ï¶âÏãú Ï†úÍ±∞
                            enemies.splice(enemyIndex, 1);
                            if (!bossActive) { // Î≥¥Ïä§Í∞Ä ÏóÜÏùÑ ÎïåÎßå Ï†êÏàò Ï¶ùÍ∞Ä
                                score += 10;
                                updateScore();
                            }
                            specialGauge = Math.min(specialGauge + 3, maxGauge);
                            updateGauge();
                        }
                    }
                });
            });
            
            clouds.forEach(particle => particle.update());
            
            items.forEach((item, itemIndex) => {
                item.update();
                if (item.y > canvas.height) {
                    items.splice(itemIndex, 1);
                }
                
                if (player.collidesWith(item)) {
                    collectItem(item);
                    items.splice(itemIndex, 1);
                }
            });
            
            updateItemEffects();
            updateDifficulty();
            
            explosions.forEach((explosion, index) => {
                explosion.update();
                if (explosion.isDead()) {
                    explosions.splice(index, 1);
                }
            });
            
            if (specialAttackActive) {
                specialAttackTimer++;
                if (specialAttackTimer > 60) {
                    specialAttackActive = false;
                    specialAttackTimer = 0;
                }
            }

            // ÌôîÏóº Ïõ®Ïù¥Î∏å ÏóÖÎç∞Ïù¥Ìä∏
            if (flameWaveActive) {
                updateFlameWave();
            }
            
            // Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ Ï†Å Ïä§Ìè∞ ÏÜçÎèÑ Ï¶ùÍ∞Ä (Îçî Îπ†Î•¥Í≤å)
            const baseSpawnRate = 60; // Í∏∞Î≥∏ Ïä§Ìè∞ Í∞ÑÍ≤© (120ÏóêÏÑú 60ÏúºÎ°ú Î∞òÏúºÎ°ú Ï§ÑÏûÑ)
            const currentSpawnRate = Math.max(15, baseSpawnRate - (difficultyLevel * 8)); // Ïä§ÌÖåÏù¥ÏßÄÎßàÎã§ 8ÌîÑÎ†àÏûÑÏî© Îπ®ÎùºÏßê

            // Ï†Å Ïä§Ìè∞ Ïπ¥Ïö¥ÌÑ∞
            enemySpawnTimer++;
            if (enemySpawnTimer % currentSpawnRate === 0) {
                // Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ Ï†Å Í∞úÏàò Ï¶ùÍ∞Ä (1-3Í∞ú)
                const enemyCount = Math.min(3, Math.floor(difficultyLevel / 2) + 1);
                for (let i = 0; i < enemyCount; i++) {
                    const x = Math.random() * (canvas.width - 30);
                    enemies.push(new Enemy(x, -35));
                }
                enemySpawnTimer = 0;
            }

            // UAP ÎûúÎç§ Ïä§Ìè∞ (0.5% ÌôïÎ•†)
            if (Math.random() < 0.005 && gameRunning && !gamePaused) {
                enemies.push(new UAPEnemy());
            }

            itemSpawnTimer++;
            // ÎÇúÏù¥ÎèÑÍ∞Ä ÎÜíÏùÑÏàòÎ°ù ÏïÑÏù¥ÌÖú Ïä§Ìè∞ ÎπàÎèÑ Ï¶ùÍ∞Ä
            const itemSpawnDelay = Math.max(150, 350 - (difficultyLevel * 15));
            if (itemSpawnTimer > itemSpawnDelay + Math.random() * 150) {
                spawnItem();
                itemSpawnTimer = 0;
            }
        }
        
        function draw() {
            // ÎØ∏ÎûòÎèÑÏãú Ïπ®Í≥µ Î∞∞Í≤Ω
            drawCityBackground();

            // Í±¥Î¨ºÎì§Í≥º Íµ¨Î¶Ñ Ìö®Í≥º Í∑∏Î¶¨Í∏∞
            clouds.forEach(particle => particle.draw());
            
            player.draw();
            bullets.forEach(bullet => bullet.draw());
            sidekickBullets.forEach(bullet => bullet.draw());
            enemies.forEach(enemy => enemy.draw());
            items.forEach(item => item.draw());
            sidekicks.forEach(sidekick => sidekick.draw());
            explosions.forEach(explosion => explosion.draw());
            
            if (specialAttackActive) {
                drawSpecialAttackEffect();
            }
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Í≤åÏûÑ ÏãúÏûë Ïãú 1Îã®Í≥Ñ ÏÑ§Ï†ï Ï¥àÍ∏∞Ìôî
        function initializeGame() {
            difficultyLevel = 1;
            currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (1 * 3));
            currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + 1 * 0.03));
            currentShotDelay = Math.max(30, baseShotDelay - (1 * 3));
            enemySpeedMultiplier = Math.min(2.0, 1.0 + (1 * 0.05));
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Ï†êÏàò: ${score}`;
        }

        function drawCityBackground() {
            // Ìë∏Î•∏ Î∞îÎã§ Î∞∞Í≤Ω (Ï¢åÏ∏°)Í≥º Ïú°ÏßÄ (Ïö∞Ï∏°)
            const seaGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            seaGradient.addColorStop(0, '#1e3a5f');     // ÍπäÏùÄ Î∞îÎã§ÏÉâ
            seaGradient.addColorStop(0.4, '#2d4a6e');   // Ï§ëÍ∞Ñ Î∞îÎã§ÏÉâ
            seaGradient.addColorStop(0.6, '#3a5a7d');   // Ïó∞Ìïú Î∞îÎã§ÏÉâ
            seaGradient.addColorStop(1, '#4a6a8d');     // Ìï¥Ïïà Í∑ºÏ≤ò

            ctx.fillStyle = seaGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ïú°ÏßÄ (Ìï¥ÏïàÏÑ†Í≥º ÏÑ¨Îì§)
            drawLandMasses();

            // Ïà≤Í≥º Î∞≠
            drawForests();

            // Íµ∞ÏÇ¨ ÏãúÏÑ§
            drawMilitaryBuildings();

            // Ï†ïÏ†Å Ìï¥ÏïàÏÑ† Ìö®Í≥º
            drawWaterEffects();
        }

        function drawLandMasses() {
            ctx.save();

            // Ï¢åÏ∏°ÏùÄ Ìë∏Î•∏ Î∞îÎã§ (Î∞∞Í≤Ω Í∑∏ÎùºÎîîÏñ∏Ìä∏Î°ú Ïù¥ÎØ∏ Ï≤òÎ¶¨Îê®)

            // Ïö∞Ï∏° Ìï¥ÏïàÏÑ† (Ïú°ÏßÄ)
            ctx.fillStyle = '#6a5a4a'; // Í∞àÏÉâ Ïú°ÏßÄ

            // Ïö∞Ï∏° Ìï¥ÏïàÏÑ† (Í≥°ÏÑ†ÏúºÎ°ú ÏûêÏó∞Ïä§ÎüΩÍ≤å)
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.65, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(canvas.width * 0.6, canvas.height);
            ctx.quadraticCurveTo(canvas.width * 0.62, canvas.height * 0.8, canvas.width * 0.64, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.66, canvas.height * 0.4, canvas.width * 0.63, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.65, canvas.height * 0.1, canvas.width * 0.65, 0);
            ctx.fill();

            // Ìï¥Î≥Ä (Î∞ùÏùÄ Î™®ÎûòÏÉâ)
            ctx.fillStyle = '#d4c4a4';
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.65, 0);
            ctx.quadraticCurveTo(canvas.width * 0.62, canvas.height * 0.1, canvas.width * 0.6, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.63, canvas.height * 0.4, canvas.width * 0.61, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.59, canvas.height * 0.8, canvas.width * 0.6, canvas.height);
            ctx.lineTo(canvas.width * 0.62, canvas.height);
            ctx.quadraticCurveTo(canvas.width * 0.64, canvas.height * 0.8, canvas.width * 0.66, canvas.height * 0.6);
            ctx.quadraticCurveTo(canvas.width * 0.68, canvas.height * 0.4, canvas.width * 0.65, canvas.height * 0.2);
            ctx.quadraticCurveTo(canvas.width * 0.67, canvas.height * 0.1, canvas.width * 0.65, 0);
            ctx.fill();

            ctx.restore();
        }

        function drawForests() {
            ctx.save();

            // Ïö∞Ï∏° ÎèÑÏãú (Í±¥Î¨ºÎì§Í≥º Í±∞Î¶¨)

            // ÎèÑÏãú Î∏îÎ°ùÎì§ (Í±¥Î¨ºÎì§)
            const buildings = [
                // Í≥†Ï∏µ ÎπåÎî©Îì§
                {x: canvas.width * 0.68, y: canvas.height * 0.1, w: 25, h: 120, color: '#4a4a4a'},
                {x: canvas.width * 0.72, y: canvas.height * 0.15, w: 20, h: 100, color: '#5a5a5a'},
                {x: canvas.width * 0.75, y: canvas.height * 0.08, w: 30, h: 140, color: '#3a3a3a'},
                {x: canvas.width * 0.80, y: canvas.height * 0.12, w: 22, h: 110, color: '#6a6a6a'},
                {x: canvas.width * 0.84, y: canvas.height * 0.18, w: 18, h: 90, color: '#4a4a4a'},
                {x: canvas.width * 0.88, y: canvas.height * 0.14, w: 28, h: 105, color: '#5a5a5a'},

                // Ï§ëÏ∏µ ÎπåÎî©Îì§
                {x: canvas.width * 0.70, y: canvas.height * 0.35, w: 15, h: 60, color: '#5a5a5a'},
                {x: canvas.width * 0.74, y: canvas.height * 0.38, w: 18, h: 55, color: '#4a4a4a'},
                {x: canvas.width * 0.77, y: canvas.height * 0.32, w: 20, h: 70, color: '#6a6a6a'},
                {x: canvas.width * 0.82, y: canvas.height * 0.40, w: 16, h: 50, color: '#3a3a3a'},
                {x: canvas.width * 0.86, y: canvas.height * 0.36, w: 22, h: 65, color: '#5a5a5a'},

                // Ï†ÄÏ∏µ ÎπåÎî©Îì§
                {x: canvas.width * 0.69, y: canvas.height * 0.55, w: 12, h: 35, color: '#6a6a6a'},
                {x: canvas.width * 0.73, y: canvas.height * 0.58, w: 14, h: 30, color: '#4a4a4a'},
                {x: canvas.width * 0.76, y: canvas.height * 0.52, w: 16, h: 40, color: '#5a5a5a'},
                {x: canvas.width * 0.81, y: canvas.height * 0.60, w: 13, h: 28, color: '#3a3a3a'},
                {x: canvas.width * 0.85, y: canvas.height * 0.56, w: 18, h: 35, color: '#6a6a6a'},
                {x: canvas.width * 0.89, y: canvas.height * 0.59, w: 15, h: 32, color: '#4a4a4a'}
            ];

            // Í±¥Î¨ºÎì§ Í∑∏Î¶¨Í∏∞
            buildings.forEach(building => {
                // Í±¥Î¨º Î≥∏Ï≤¥
                ctx.fillStyle = building.color;
                ctx.fillRect(building.x, building.y, building.w, building.h);

                // Í±¥Î¨º Ï∞ΩÎ¨∏Îì§ (ÎÖ∏ÎûÄ Î∂àÎπõ)
                ctx.fillStyle = '#ffdd44';
                for (let floor = 0; floor < Math.floor(building.h / 8); floor++) {
                    for (let window = 0; window < Math.floor(building.w / 4); window++) {
                        if ((floor + window) % 3 !== 0) { // ÏùºÎ∂Ä Ï∞ΩÎ¨∏Îßå ÏºúÏ†∏ÏûàÍ≤å
                            const windowX = building.x + 2 + window * 4;
                            const windowY = building.y + 2 + floor * 8;
                            ctx.fillRect(windowX, windowY, 2, 3);
                        }
                    }
                }
            });

            // ÎèÑÎ°úÎì§
            ctx.fillStyle = '#2a2a2a';
            // ÏàòÏßÅ ÎèÑÎ°ú
            ctx.fillRect(canvas.width * 0.71, canvas.height * 0.1, 3, canvas.height * 0.6);
            ctx.fillRect(canvas.width * 0.79, canvas.height * 0.1, 3, canvas.height * 0.6);
            ctx.fillRect(canvas.width * 0.87, canvas.height * 0.1, 3, canvas.height * 0.6);

            // ÏàòÌèâ ÎèÑÎ°ú
            ctx.fillRect(canvas.width * 0.68, canvas.height * 0.30, canvas.width * 0.25, 3);
            ctx.fillRect(canvas.width * 0.68, canvas.height * 0.50, canvas.width * 0.25, 3);

            // ÎèÑÏãú Í∑ºÏ≤ò ÎÇòÎ¨¥Îì§ (ÏûëÏùÄ Í≥µÏõêÍ≥º Í∞ÄÎ°úÏàò)
            ctx.fillStyle = '#2d4a2d'; // Ïñ¥ÎëêÏö¥ ÎÖπÏÉâ

            // ÏûëÏùÄ Í≥µÏõê (ÎèÑÏãú Ï§ëÏïô)
            const parkTrees = [
                {x: canvas.width * 0.75, y: canvas.height * 0.65, size: 6},
                {x: canvas.width * 0.77, y: canvas.height * 0.67, size: 5},
                {x: canvas.width * 0.73, y: canvas.height * 0.68, size: 7},
                {x: canvas.width * 0.78, y: canvas.height * 0.64, size: 4},
                {x: canvas.width * 0.76, y: canvas.height * 0.70, size: 6}
            ];

            parkTrees.forEach(tree => {
                ctx.beginPath();
                ctx.arc(tree.x, tree.y, tree.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Í∞ÄÎ°úÏàò (ÎèÑÎ°úÎ≥Ä)
            ctx.fillStyle = '#3a5a3a';
            for (let i = 0; i < 8; i++) {
                const treeX = canvas.width * 0.68 + i * 25;
                const treeY = canvas.height * 0.72;
                ctx.beginPath();
                ctx.arc(treeX, treeY, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Ìï¥ÏïàÍ∞Ä ÎÇòÎ¨¥Îì§
            ctx.fillStyle = '#2d4a2d';
            for (let i = 0; i < 6; i++) {
                const coastTreeX = canvas.width * 0.62 + i * 8;
                const coastTreeY = canvas.height * 0.15 + i * 60;
                ctx.beginPath();
                ctx.arc(coastTreeX, coastTreeY, 5 + Math.sin(i) * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawMilitaryBuildings() {
            ctx.save();

            // Íµ∞ÏÇ¨ Í∏∞ÏßÄ (Ïö∞Ï∏° Ìï¥Ïïà ÏÉÅÎã®)
            const baseX = canvas.width * 0.78;
            const baseY = canvas.height * 0.15;

            // Íµ∞ÏÇ¨ Í±¥Î¨ºÎì§ (Ï†ïÏ†Å)
            const buildings = [
                {x: baseX, y: baseY, w: 30, h: 20, color: '#6a6a6a'},
                {x: baseX + 35, y: baseY, w: 25, h: 25, color: '#5a5a5a'},
                {x: baseX, y: baseY + 30, w: 35, h: 15, color: '#7a7a7a'},
                {x: baseX + 40, y: baseY + 30, w: 20, h: 20, color: '#6a6a6a'},
                {x: baseX - 25, y: baseY + 15, w: 22, h: 22, color: '#5a5a5a'}
            ];

            buildings.forEach(building => {
                ctx.fillStyle = building.color;
                ctx.fillRect(building.x, building.y, building.w, building.h);

                // Í±¥Î¨º ÎîîÌÖåÏùº (Ï∞ΩÎ¨∏/Î¨∏)
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(building.x + 2, building.y + 2, building.w - 4, building.h - 4);
            });

            // ÌôúÏ£ºÎ°ú (ÌöåÏÉâ ÏßÅÏÇ¨Í∞ÅÌòï)
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(canvas.width * 0.72, canvas.height * 0.6, 80, 8);

            // ÌôúÏ£ºÎ°ú Ï§ëÏïôÏÑ† (Ï†êÏÑ†)
            ctx.fillStyle = '#ffffff';
            for (let x = canvas.width * 0.72; x < canvas.width * 0.72 + 80; x += 10) {
                ctx.fillRect(x, canvas.height * 0.6 + 3, 5, 2);
            }

            // Î†àÏù¥Îçî ÌÉÄÏõå
            ctx.fillStyle = '#8a8a8a';
            ctx.fillRect(canvas.width * 0.85, canvas.height * 0.25, 6, 15);
            ctx.beginPath();
            ctx.arc(canvas.width * 0.88, canvas.height * 0.25, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawWaterEffects() {
            ctx.save();

            // Ï†ïÏ†ÅÏù∏ Î¨ºÍ≤∞ Ìö®Í≥º (ÏõÄÏßÅÏù¥ÏßÄ ÏïäÏùå)
            ctx.strokeStyle = 'rgba(150, 200, 180, 0.3)';
            ctx.lineWidth = 1;

            // Ìï¥ÏïàÏÑ† Ï†ïÏ†Å Î¨ºÍ≤∞
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                const waveY = canvas.height * 0.2 + i * 80;
                ctx.moveTo(0, waveY);

                for (let x = 0; x < canvas.width * 0.6; x += 20) {
                    const y = waveY + Math.sin(x * 0.1) * 3; // Date.now() Ï†úÍ±∞
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            ctx.restore();
        }
        
        function updateGauge() {
            const percentage = (specialGauge / maxGauge) * 100;
            document.getElementById('gaugeFill').style.width = percentage + '%';
            document.getElementById('gaugeText').textContent = `ÌïÑÏÇ¥Í∏∞ Í≤åÏù¥ÏßÄ: ${Math.floor(percentage)}%`;
        }
        
        function activateSpecialAttack() {
            specialAttackActive = true;
            specialGauge = 0;
            updateGauge();

            // ÌôîÏóº Ïõ®Ïù¥Î∏å ÏãúÏûë
            startFlameWave();

            // Î≥¥Ïä§Î•º Ï†úÏô∏Ìïú Ï†ÅÎì§ÏóêÍ≤åÎßå ÌäπÏàò Í≥µÍ≤© Ï†ÅÏö©
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);

                if (enemy.isBoss) {
                    // Î≥¥Ïä§Îäî ÌäπÏàò Í≥µÍ≤©ÏúºÎ°ú ÌÅ∞ Îç∞ÎØ∏ÏßÄ (HPÏùò 20%)
                    const damage = Math.max(1, Math.floor(enemy.maxHp * 0.2));
                    for (let d = 0; d < damage; d++) {
                        if (enemy.takeDamage()) {
                            enemies.splice(i, 1);
                            break;
                        }
                    }
                    if (!bossActive) { // Î≥¥Ïä§Í∞Ä ÏóÜÏùÑ ÎïåÎßå Ï†êÏàò Ï¶ùÍ∞Ä
                        score += 200; // Î≥¥Ïä§ÏóêÍ≤å Îç∞ÎØ∏ÏßÄÎ•º Ï§Ä Î≥¥ÎÑàÏä§
                    }
                } else {
                    // ÏùºÎ∞ò Ï†ÅÏùÄ Ï¶âÏãú Ï†úÍ±∞
                    enemies.splice(i, 1);
                    if (!bossActive) { // Î≥¥Ïä§Í∞Ä ÏóÜÏùÑ ÎïåÎßå Ï†êÏàò Ï¶ùÍ∞Ä
                        score += 50;
                    }
                }
            }
            updateScore();
        }
        
        function createExplosion(x, y) {
            explosions.push(new Explosion(x, y));
        }
        
        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pauseScreen').style.display = gamePaused ? 'block' : 'none';
        }
        
        function handlePauseKey() {
            if (!pKeyPressed) {
                pKeyPressed = true;
                togglePause();
            }
        }
        
        function spawnItem() {
            const x = Math.random() * (canvas.width - 20);
            items.push(new Item(x, -20));
        }
        
        function collectItem(item) {
            if (playerItems.length < maxItems) {
                // Îπà Ïä¨Î°ØÏù¥ ÏûàÏúºÎ©¥ Ï∂îÍ∞Ä
                playerItems.push({
                    type: item.type,
                    symbol: item.symbols[item.type],
                    color: item.colors[item.type]
                });
            } else {
                // Ïä¨Î°ØÏù¥ Í∞ÄÎìù Ï∞¨ Í≤ΩÏö∞ Ï≤´ Î≤àÏß∏ ÏïÑÏù¥ÌÖú Ï†úÍ±∞ÌïòÍ≥† ÏÉà ÏïÑÏù¥ÌÖú Ï∂îÍ∞Ä
                const oldItem = playerItems.shift(); // Ï≤´ Î≤àÏß∏ ÏïÑÏù¥ÌÖú Ï†úÍ±∞
                deactivateItemEffect(oldItem.type);

                playerItems.push({
                    type: item.type,
                    symbol: item.symbols[item.type],
                    color: item.colors[item.type]
                });
            }

            updateInventoryUI();
            activateItemEffect(item.type);

            // Add sidekick when collecting item
            addSidekick();
        }

        function deactivateItemEffect(type) {
            switch(type) {
                case 'multiShot':
                    multiShotActive = false;
                    break;
                case 'rapidFire':
                    rapidFireActive = false;
                    currentShotDelay = Math.max(30, baseShotDelay - (difficultyLevel * 3));
                    break;
                case 'pierce':
                    pierceActive = false;
                    break;
                case 'homing':
                    homingActive = false;
                    break;
            }
        }
        
        function addSidekick() {
            if (sidekicks.length < maxSidekicks) {
                const hasLeft = sidekicks.some(s => s.side === 'left');
                const hasRight = sidekicks.some(s => s.side === 'right');
                
                if (!hasLeft) {
                    sidekicks.push(new Sidekick('left'));
                } else if (!hasRight) {
                    sidekicks.push(new Sidekick('right'));
                }
            }
        }
        
        function activateItemEffect(type) {
            switch(type) {
                case 'multiShot':
                    multiShotActive = true;
                    itemEffectTimers.multiShot = 10000;
                    break;
                case 'rapidFire':
                    rapidFireActive = true;
                    itemEffectTimers.rapidFire = 10000;
                    // Ïó∞ÏÇ¨ ÏïÑÏù¥ÌÖú ÌôúÏÑ±Ïãú Ïáá ÏÜçÎèÑ Ïû¨Í≥ÑÏÇ∞
                    currentShotDelay = Math.max(15, baseShotDelay - (difficultyLevel * 3)) / 3;
                    break;
                case 'pierce':
                    pierceActive = true;
                    itemEffectTimers.pierce = 10000;
                    break;
                case 'homing':
                    homingActive = true;
                    itemEffectTimers.homing = 10000;
                    break;
            }
        }
        
        function updateItemEffects() {
            // ÏïÑÏù¥ÌÖú Ìö®Í≥ºÎ•º ÏòÅÍµ¨Ï†ÅÏúºÎ°ú Ïú†ÏßÄ (Îã§Î•∏ ÏïÑÏù¥ÌÖúÏùÑ Î®πÍ∏∞ Ï†ÑÍπåÏßÄ)
            // ÏãúÍ∞Ñ Í∏∞Î∞ò ÎπÑÌôúÏÑ±Ìôî Ï†úÍ±∞
        }
        
        function removeItemFromInventory(type) {
            playerItems = playerItems.filter(item => item.type !== type);
            updateInventoryUI();
        }
        
        function updateInventoryUI() {
            for (let i = 0; i < maxItems; i++) {
                const slot = document.getElementById(`slot${i}`);
                if (i < playerItems.length) {
                    slot.textContent = playerItems[i].symbol;
                    slot.style.color = playerItems[i].color;
                    slot.classList.add('filled');
                } else {
                    slot.textContent = '';
                    slot.classList.remove('filled');
                }
            }
        }
        
        function startFlameWave() {
            flameWaveActive = true;
            flameWaveHeight = 0;
            flameWave = [];

            // ÌôîÏóº ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
            for (let i = 0; i < 100; i++) {
                flameWave.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + Math.random() * 50,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -8 - Math.random() * 12,
                    size: 3 + Math.random() * 8,
                    life: 1.0,
                    color: Math.random() < 0.7 ? 'orange' : 'red'
                });
            }
        }

        function updateFlameWave() {
            if (!flameWaveActive) return;

            flameWaveHeight += 15;

            // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
            flameWave.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                particle.size *= 0.98;

                // Î∞îÎûå Ìö®Í≥º
                particle.vx += (Math.random() - 0.5) * 0.5;
            });

            // Ï£ΩÏùÄ ÌååÌã∞ÌÅ¥ Ï†úÍ±∞
            flameWave = flameWave.filter(particle => particle.life > 0 && particle.size > 0.5);

            // ÏÉàÎ°úÏö¥ ÌååÌã∞ÌÅ¥ Ï∂îÍ∞Ä
            if (flameWaveHeight < canvas.height + 100) {
                for (let i = 0; i < 5; i++) {
                    flameWave.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height - flameWaveHeight + Math.random() * 30,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -5 - Math.random() * 15,
                        size: 4 + Math.random() * 10,
                        life: 1.0,
                        color: Math.random() < 0.6 ? 'orange' : Math.random() < 0.8 ? 'red' : 'yellow'
                    });
                }
            }

            // Ìö®Í≥º Ï¢ÖÎ£å Ï≤¥ÌÅ¨
            if (flameWaveHeight > canvas.height + 150 && flameWave.length === 0) {
                flameWaveActive = false;
            }
        }

        function drawFlameWave() {
            if (!flameWaveActive) return;

            // ÌôîÏóº Î≤†Ïù¥Ïä§ Í∑∏ÎùºÎîîÏñ∏Ìä∏
            const flameGradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - flameWaveHeight);
            flameGradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
            flameGradient.addColorStop(0.3, 'rgba(255, 150, 0, 0.6)');
            flameGradient.addColorStop(0.7, 'rgba(255, 200, 0, 0.3)');
            flameGradient.addColorStop(1, 'transparent');

            ctx.fillStyle = flameGradient;
            ctx.fillRect(0, canvas.height - flameWaveHeight, canvas.width, flameWaveHeight);

            // ÌååÌã∞ÌÅ¥ Í∑∏Î¶¨Í∏∞
            flameWave.forEach(particle => {
                if (particle.life > 0) {
                    ctx.globalAlpha = particle.life;

                    const colors = {
                        orange: `hsl(${30 + Math.random() * 30}, 100%, ${50 + Math.random() * 30}%)`,
                        red: `hsl(${0 + Math.random() * 20}, 100%, ${50 + Math.random() * 30}%)`,
                        yellow: `hsl(${50 + Math.random() * 20}, 100%, ${60 + Math.random() * 30}%)`
                    };

                    ctx.fillStyle = colors[particle.color];
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, 2 * Math.PI);
                    ctx.fill();

                    // Í∏ÄÎ°úÏö∞ Ìö®Í≥º
                    ctx.shadowColor = colors[particle.color];
                    ctx.shadowBlur = particle.size * 2;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            ctx.globalAlpha = 1.0;

            // ÌïÑÏÇ¥Í∏∞ ÌÖçÏä§Ìä∏
            ctx.fillStyle = 'white';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 10;
            ctx.fillText('ÌôîÏóº Ìè≠Ìíç!', canvas.width / 2, 100);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'left';
        }

        function drawSpecialAttackEffect() {
            // Í∏∞Ï°¥ Î≤àÏ©çÏûÑ Ï†úÍ±∞, ÌôîÏóº Ïõ®Ïù¥Î∏åÎ°ú ÎåÄÏ≤¥
            drawFlameWave();
        }
        
        function gameOver() {
            gameRunning = false;
            showRankingInput();
        }
        
        function restartGame() {
            gameRunning = true;
            gamePaused = false;
            score = 0;
            difficultyLevel = 1;
            currentEnemySpawnRate = Math.max(8, baseEnemySpawnRate - (1 * 3));
            currentPlayerSpeed = Math.min(basePlayerSpeed * 1.6, basePlayerSpeed * (1.0 + 1 * 0.03));
            currentShotDelay = Math.max(30, baseShotDelay - (1 * 3));
            enemySpeedMultiplier = Math.min(2.0, 1.0 + (1 * 0.05));
            specialGauge = 0;
            specialAttackActive = false;
            specialAttackTimer = 0;
            playerItems = [];
            multiShotActive = false;
            rapidFireActive = false;
            pierceActive = false;
            homingActive = false;
            itemEffectTimers = {
                multiShot: 0,
                rapidFire: 0,
                pierce: 0,
                homing: 0
            };
            bullets.length = 0;
            sidekickBullets.length = 0;
            enemies.length = 0;
            items.length = 0;
            sidekicks.length = 0;
            explosions.length = 0;
            itemSpawnTimer = 0;
            lastSidekickShot = 0;
            bossActive = false;
            currentBoss = null;
            player.x = canvas.width / 2 - 20;
            player.y = canvas.height - 60;
            updateScore();
            updateGauge();
            updateInventoryUI();
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
        }
        
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = true;
                    break;
                case 'ArrowRight':
                    keys.right = true;
                    break;
                case 'ArrowUp':
                    keys.up = true;
                    break;
                case 'ArrowDown':
                    keys.down = true;
                    break;
                case 'Space':
                    keys.space = true;
                    e.preventDefault();
                    break;
                case 'KeyZ':
                    keys.z = true;
                    e.preventDefault();
                    break;
                case 'KeyP':
                    handlePauseKey();
                    e.preventDefault();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'ArrowUp':
                    keys.up = false;
                    break;
                case 'ArrowDown':
                    keys.down = false;
                    break;
                case 'Space':
                    keys.space = false;
                    break;
                case 'KeyZ':
                    keys.z = false;
                    break;
                case 'KeyP':
                    pKeyPressed = false;
                    break;
            }
        });
        
        // Îû≠ÌÇπ ÏãúÏä§ÌÖú Ìï®ÏàòÎì§
        function loadRankings() {
            const saved = localStorage.getItem('galaxyShooterRankings');
            if (saved) {
                rankings = JSON.parse(saved);
            }
            updateLiveRankings(); // Îû≠ÌÇπ Î°úÎìú ÌõÑ ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
        }

        function updateLiveRankings() {
            const rankingContainer = document.getElementById('liveRankingList');
            if (!rankingContainer) return;

            rankingContainer.innerHTML = '';

            if (rankings.length === 0) {
                rankingContainer.innerHTML = `
                    <div class="ranking-item">
                        <span class="ranking-rank">1</span>
                        <div>
                            <div class="ranking-score">Í∏∞Î°ù ÏóÜÏùå</div>
                            <div class="ranking-date">Í≤åÏûÑÏùÑ ÏãúÏûëÌï¥Î≥¥ÏÑ∏Ïöî!</div>
                        </div>
                    </div>
                `;
                return;
            }

            rankings.slice(0, 10).forEach((ranking, index) => {
                const medalIcons = ['ü•á', 'ü•à', 'ü•â'];
                const medal = index < 3 ? medalIcons[index] : `${index + 1}`;

                rankingContainer.innerHTML += `
                    <div class="ranking-item">
                        <span class="ranking-rank">${medal}</span>
                        <div>
                            <div class="ranking-score">${ranking.score.toLocaleString()}Ï†ê</div>
                            <div class="ranking-date">${ranking.name} | Stage ${ranking.stage}</div>
                        </div>
                    </div>
                `;
            });
        }

        function saveRankings() {
            localStorage.setItem('galaxyShooterRankings', JSON.stringify(rankings));
        }

        function addRanking(name, score, stage) {
            const newRecord = {
                name: name || 'Î¨¥Î™Ö',
                score: score,
                stage: stage,
                date: new Date().toLocaleDateString('ko-KR')
            };

            rankings.push(newRecord);
            rankings.sort((a, b) => b.score - a.score);
            rankings = rankings.slice(0, maxRankings);
            saveRankings();
            updateLiveRankings(); // Ïã§ÏãúÍ∞Ñ Îû≠ÌÇπ ÏóÖÎç∞Ïù¥Ìä∏
            return newRecord;
        }

        function showRankingInput() {
            document.getElementById('finalScore').textContent = `ÏµúÏ¢Ö Ï†êÏàò: ${score}Ï†ê (${difficultyLevel}Îã®Í≥Ñ)`;
            document.getElementById('rankingModal').style.display = 'block';
            document.getElementById('nameInput').focus();
            displayRankings(null);
        }

        function saveScore() {
            const name = document.getElementById('nameInput').value.trim();
            const newRecord = addRanking(name, score, difficultyLevel);
            document.getElementById('nameInputSection').style.display = 'none';
            displayRankings(newRecord);
        }

        function displayRankings(newRecord) {
            // Ïö∞Ï∏° Ìå®ÎÑêÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            updateLiveRankings();

            const rankingList = document.getElementById('rankingList');
            rankingList.innerHTML = '<h3 style="color: #00ffff; text-align: center; margin-bottom: 15px;">üèÖ Î™ÖÏòàÏùò Ï†ÑÎãπ üèÖ</h3>';

            if (rankings.length === 0) {
                rankingList.innerHTML += '<div style="text-align: center; color: #999;">ÏïÑÏßÅ Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.</div>';
                return;
            }

            rankings.forEach((ranking, index) => {
                const isNew = newRecord && ranking === newRecord;
                const rankElement = document.createElement('div');
                rankElement.className = `rankingItem ${isNew ? 'newRecord' : ''}`;

                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;

                rankElement.innerHTML = `
                    <div>
                        <span style="display: inline-block; width: 30px;">${medal}</span>
                        <strong>${ranking.name}</strong>
                        <span style="margin-left: 10px; color: #aaa; font-size: 12px;">${ranking.date}</span>
                    </div>
                    <div>
                        <span style="color: #ffd700;">${ranking.score}Ï†ê</span>
                        <span style="margin-left: 10px; color: #00ffff;">${ranking.stage}Îã®Í≥Ñ</span>
                    </div>
                `;

                rankingList.appendChild(rankElement);
            });
        }

        function closeRanking() {
            document.getElementById('rankingModal').style.display = 'none';
            document.getElementById('gameOver').style.display = 'block';
        }

        // Enter ÌÇ§Î°ú Ïù¥Î¶Ñ Ï†ÄÏû•
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('nameInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    saveScore();
                }
            });
        });

        console.log("Starting game...");
        try {
            loadRankings();
            console.log("Rankings loaded");
            initializeGame();
            console.log("Game initialized");
            gameLoop();
            console.log("Game loop started");
        } catch (error) {
            console.error("Game initialization error:", error);
        }
    </script>
</body>
</html>